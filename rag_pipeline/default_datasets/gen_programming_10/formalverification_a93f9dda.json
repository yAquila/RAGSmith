{
  "article": {
    "id": "formalverification_a93f9dda",
    "title": "Formal verification",
    "url": "https://en.wikipedia.org/wiki/Formal_verification",
    "lang": "en",
    "created_at": "2025-07-28T12:11:43.110978",
    "content": "---\nid: formalverification_a93f9dda\nurl: https://en.wikipedia.org/wiki/Formal_verification\ntitle: Formal verification\nlang: en\ncreated_at: '2025-07-28T12:09:45.661156'\nchecksum: 5126b4e3435d0936f3c5fa5343b231d12ca141a2c2d6dcbefe194e65e335fbd8\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gpt-4.1\nstats:\n  word_count: 1349\n  char_count: 9354\n  num_chunks: 15\n  num_sections: 0\n---\nIn the context of hardware and software systems, formal verification is the act of proving or disproving the correctness of a system with respect to a certain formal specification or property, using formal methods of mathematics. Formal verification is a key incentive for formal specification of systems, and is at the core of formal methods. It represents an important dimension of analysis and verification in electronic design automation and is one approach to software verification. The use of formal verification enables the highest Evaluation Assurance Level (EAL7) in the framework of common criteria for computer security certification. Formal verification can be helpful in proving the correctness of systems such as: cryptographic protocols, combinational circuits, digital circuits with internal memory, and software expressed as source code in a programming language. Prominent examples of verified software systems include the CompCert verified C compiler and the seL4 high-assurance operating system kernel. The verification of these systems is done by ensuring the existence of a formal proof of a mathematical model of the system. Examples of mathematical objects used to model systems are: finite-state machines, labelled transition systems, Horn clauses, Petri nets, vector addition systems, timed automata, hybrid automata, process algebra, formal semantics of programming languages such as operational semantics, denotational semantics, axiomatic semantics and Hoare logic. == Approaches == === Model checking === Model checking involves a systematic and exhaustive exploration of the mathematical model. Such exploration is possible for finite models, but also for some infinite models, where infinite sets of states can be effectively represented finitely by using abstraction or taking advantage of symmetry. Usually, this consists of exploring all states and transitions in the model, by using smart and domain-specific abstraction techniques to consider whole groups of states in a single operation and reduce computing time. Implementation techniques include state space enumeration, symbolic state space enumeration, abstract interpretation, symbolic simulation, abstraction refinement. The properties to be verified are often described in temporal logics, such as linear temporal logic (LTL), Property Specification Language (PSL), SystemVerilog Assertions (SVA), or computational tree logic (CTL). The great advantage of model checking is that it is often fully automatic; its primary disadvantage is that it does not in general scale to large systems; symbolic models are typically limited to a few hundred bits of state, while explicit state enumeration requires the state space being explored to be relatively small. === Deductive verification === Another approach is deductive verification. It consists of generating from the system and its specifications (and possibly other annotations) a collection of mathematical proof obligations, the truth of which imply conformance of the system to its specification, and discharging these obligations using either proof assistants (interactive theorem provers) (such as HOL, ACL2, Isabelle, Rocq (previously known as Coq) or PVS), or automatic theorem provers, including in particular satisfiability modulo theories (SMT) solvers. This approach has the disadvantage that it may require the user to understand in detail why the system works correctly, and to convey this information to the verification system, either in the form of a sequence of theorems to be proved or in the form of specifications (invariants, preconditions, postconditions) of system components (e.g. functions or procedures) and perhaps subcomponents (such as loops or data structures). === Application to software === Formal verification of software programs involves proving that a program satisfies a formal specification of its behavior. Subareas of formal verification include deductive verification (see above), abstract interpretation, automated theorem proving, type systems, and lightweight formal methods. A promising type-based verification approach is dependently typed programming, in which the types of functions include (at least part of) those functions' specifications, and type-checking the code establishes its correctness against those specifications. Fully featured dependently typed languages support deductive verification as a special case. Another complementary approach is program derivation, in which efficient code is produced from functional specifications by a series of correctness-preserving steps. An example of this approach is the Bird–Meertens formalism, and this approach can be seen as another form of program synthesis. These techniques can be sound, meaning that the verified properties can be logically deduced from the semantics, or unsound, meaning that there is no such guarantee. A sound technique yields a result only once it has covered the entire space of possibilities. An example of an unsound technique is one that covers only a subset of the possibilities, for instance only integers up to a certain number, and give a \"good-enough\" result. Techniques can also be decidable, meaning that their algorithmic implementations are guaranteed to terminate with an answer, or undecidable, meaning that they may never terminate. By bounding the scope of possibilities, unsound techniques that are decidable might be able to be constructed when no decidable sound techniques are available. == Verification and validation == Verification is one aspect of testing a product's fitness for purpose. Validation is the complementary aspect. Often one refers to the overall checking process as V & V. Validation: \"Are we trying to make the right thing?\", i.e., is the product specified to the user's actual needs? Verification: \"Have we made what we were trying to make?\", i.e., does the product conform to the specifications? The verification process consists of static/structural and dynamic/behavioral aspects. E.g., for a software product one can inspect the source code (static) and run against specific test cases (dynamic). Validation usually can be done only dynamically, i.e., the product is tested by putting it through typical and atypical usages (\"Does it satisfactorily meet all use cases?\"). == Automated program repair == Program repair is performed with respect to an oracle, encompassing the desired functionality of the program which is used for validation of the generated fix. A simple example is a test-suite—the input/output pairs specify the functionality of the program. A variety of techniques are employed, most notably using satisfiability modulo theories (SMT) solvers, and genetic programming, using evolutionary computing to generate and evaluate possible candidates for fixes. The former method is deterministic, while the latter is randomized. Program repair combines techniques from formal verification and program synthesis. Fault-localization techniques in formal verification are used to compute program points which might be possible bug-locations, which can be targeted by the synthesis modules. Repair systems often focus on a small pre-defined class of bugs in order to reduce the search space. Industrial use is limited owing to the computational cost of existing techniques. == Industry use == The growth in complexity of designs increases the importance of formal verification techniques in the hardware industry. At present, formal verification is used by most or all leading hardware companies, but its use in the software industry is still languishing. This could be attributed to the greater need in the hardware industry, where errors have greater commercial significance. Because of the potential subtle interactions between components, it is increasingly difficult to exercise a realistic set of possibilities by simulation. Important aspects of hardware design are amenable to automated proof methods, making formal verification easier to introduce and more productive. As of 2011, several operating systems have been formally verified: NICTA's Secure Embedded L4 microkernel, sold commercially as seL4 by OK Labs; OSEK/VDX based real-time operating system ORIENTAIS by East China Normal University; Green Hills Software's Integrity operating system; and SYSGO's PikeOS. In 2016, a team led by Zhong Shao at Yale developed a formally verified operating system kernel called CertiKOS. As of 2017, formal verification has been applied to the design of large computer networks through a mathematical model of the network, and as part of a new network technology category, intent-based networking. Network software vendors that offer formal verification solutions include Cisco Forward Networks and Veriflow Systems. The SPARK programming language provides a toolset which enables software development with formal verification and is used in several high-integrity systems. The CompCert C compiler is a formally verified C compiler implementing the majority of ISO C. == See also == Automated theorem proving Model checking List of model checking tools Formal equivalence checking Proof checker Property Specification Language Static code analysis Temporal logic in finite-state verification Post-silicon validation Intelligent verification Runtime verification Software verification Hardware verification == References =="
  },
  "chunks": [
    {
      "id": "formalverification_a93f9dda_c0000",
      "article_id": "formalverification_a93f9dda",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 881,
      "content": "In the context of hardware and software systems, formal verification is the act of proving or disproving the correctness of a system with respect to a certain formal specification or property, using formal methods of mathematics. Formal verification is a key incentive for formal specification of systems, and is at the core of formal methods. It represents an important dimension of analysis and verification in electronic design automation and is one approach to software verification. The use of formal verification enables the highest Evaluation Assurance Level (EAL7) in the framework of common criteria for computer security certification. Formal verification can be helpful in proving the correctness of systems such as: cryptographic protocols, combinational circuits, digital circuits with internal memory, and software expressed as source code in a programming language.",
      "char_count": 880,
      "token_estimate": 220,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0001",
      "article_id": "formalverification_a93f9dda",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 881,
      "end_char": 1494,
      "content": "Prominent examples of verified software systems include the CompCert verified C compiler and the seL4 high-assurance operating system kernel. The verification of these systems is done by ensuring the existence of a formal proof of a mathematical model of the system. Examples of mathematical objects used to model systems are: finite-state machines, labelled transition systems, Horn clauses, Petri nets, vector addition systems, timed automata, hybrid automata, process algebra, formal semantics of programming languages such as operational semantics, denotational semantics, axiomatic semantics and Hoare logic.",
      "char_count": 613,
      "token_estimate": 153,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0002",
      "article_id": "formalverification_a93f9dda",
      "section": "== Approaches ==",
      "heading_path": "== Approaches ==",
      "start_char": 1511,
      "end_char": 1512,
      "content": "== Approaches ==",
      "char_count": 16,
      "token_estimate": 4,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0003",
      "article_id": "formalverification_a93f9dda",
      "section": "== = Model checking ==",
      "heading_path": "== = Model checking ==",
      "start_char": 1534,
      "end_char": 2451,
      "content": "== = Model checking === Model checking involves a systematic and exhaustive exploration of the mathematical model. Such exploration is possible for finite models, but also for some infinite models, where infinite sets of states can be effectively represented finitely by using abstraction or taking advantage of symmetry. Usually, this consists of exploring all states and transitions in the model, by using smart and domain-specific abstraction techniques to consider whole groups of states in a single operation and reduce computing time. Implementation techniques include state space enumeration, symbolic state space enumeration, abstract interpretation, symbolic simulation, abstraction refinement. The properties to be verified are often described in temporal logics, such as linear temporal logic (LTL), Property Specification Language (PSL), SystemVerilog Assertions (SVA), or computational tree logic (CTL).",
      "char_count": 916,
      "token_estimate": 229,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0004",
      "article_id": "formalverification_a93f9dda",
      "section": "== = Model checking ==",
      "heading_path": "== = Model checking ==",
      "start_char": 2451,
      "end_char": 2772,
      "content": "The great advantage of model checking is that it is often fully automatic; its primary disadvantage is that it does not in general scale to large systems; symbolic models are typically limited to a few hundred bits of state, while explicit state enumeration requires the state space being explored to be relatively small.",
      "char_count": 321,
      "token_estimate": 80,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0005",
      "article_id": "formalverification_a93f9dda",
      "section": "== = Deductive verification ==",
      "heading_path": "== = Deductive verification ==",
      "start_char": 2781,
      "end_char": 3738,
      "content": "== = Deductive verification === Another approach is deductive verification. It consists of generating from the system and its specifications (and possibly other annotations) a collection of mathematical proof obligations, the truth of which imply conformance of the system to its specification, and discharging these obligations using either proof assistants (interactive theorem provers) (such as HOL, ACL2, Isabelle, Rocq (previously known as Coq) or PVS), or automatic theorem provers, including in particular satisfiability modulo theories (SMT) solvers. This approach has the disadvantage that it may require the user to understand in detail why the system works correctly, and to convey this information to the verification system, either in the form of a sequence of theorems to be proved or in the form of specifications (invariants, preconditions, postconditions) of system components (e.g. functions or procedures) and perhaps subcomponents (such as loops or data structures).",
      "char_count": 986,
      "token_estimate": 246,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0006",
      "article_id": "formalverification_a93f9dda",
      "section": "== = Application to software ==",
      "heading_path": "== = Application to software ==",
      "start_char": 3769,
      "end_char": 4614,
      "content": "== = Application to software === Formal verification of software programs involves proving that a program satisfies a formal specification of its behavior. Subareas of formal verification include deductive verification (see above), abstract interpretation, automated theorem proving, type systems, and lightweight formal methods. A promising type-based verification approach is dependently typed programming, in which the types of functions include (at least part of) those functions' specifications, and type-checking the code establishes its correctness against those specifications. Fully featured dependently typed languages support deductive verification as a special case. Another complementary approach is program derivation, in which efficient code is produced from functional specifications by a series of correctness-preserving steps.",
      "char_count": 844,
      "token_estimate": 211,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0007",
      "article_id": "formalverification_a93f9dda",
      "section": "== = Application to software ==",
      "heading_path": "== = Application to software ==",
      "start_char": 4614,
      "end_char": 5515,
      "content": "An example of this approach is the Bird–Meertens formalism, and this approach can be seen as another form of program synthesis. These techniques can be sound, meaning that the verified properties can be logically deduced from the semantics, or unsound, meaning that there is no such guarantee. A sound technique yields a result only once it has covered the entire space of possibilities. An example of an unsound technique is one that covers only a subset of the possibilities, for instance only integers up to a certain number, and give a \"good-enough\" result. Techniques can also be decidable, meaning that their algorithmic implementations are guaranteed to terminate with an answer, or undecidable, meaning that they may never terminate. By bounding the scope of possibilities, unsound techniques that are decidable might be able to be constructed when no decidable sound techniques are available.",
      "char_count": 901,
      "token_estimate": 225,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0008",
      "article_id": "formalverification_a93f9dda",
      "section": "== Verification and validation ==",
      "heading_path": "== Verification and validation ==",
      "start_char": 5518,
      "end_char": 6294,
      "content": "== Verification and validation == Verification is one aspect of testing a product's fitness for purpose. Validation is the complementary aspect. Often one refers to the overall checking process as V & V. Validation: \"Are we trying to make the right thing?\", i.e., is the product specified to the user's actual needs? Verification: \"Have we made what we were trying to make?\", i.e., does the product conform to the specifications? The verification process consists of static/structural and dynamic/behavioral aspects. E.g., for a software product one can inspect the source code (static) and run against specific test cases (dynamic). Validation usually can be done only dynamically, i.e., the product is tested by putting it through typical and atypical usages (\"Does it satisfactorily meet all use cases?\").",
      "char_count": 808,
      "token_estimate": 202,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0009",
      "article_id": "formalverification_a93f9dda",
      "section": "== Automated program repair ==",
      "heading_path": "== Automated program repair ==",
      "start_char": 6324,
      "end_char": 7253,
      "content": "== Automated program repair == Program repair is performed with respect to an oracle, encompassing the desired functionality of the program which is used for validation of the generated fix. A simple example is a test-suite—the input/output pairs specify the functionality of the program. A variety of techniques are employed, most notably using satisfiability modulo theories (SMT) solvers, and genetic programming, using evolutionary computing to generate and evaluate possible candidates for fixes. The former method is deterministic, while the latter is randomized. Program repair combines techniques from formal verification and program synthesis. Fault-localization techniques in formal verification are used to compute program points which might be possible bug-locations, which can be targeted by the synthesis modules. Repair systems often focus on a small pre-defined class of bugs in order to reduce the search space.",
      "char_count": 928,
      "token_estimate": 232,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0010",
      "article_id": "formalverification_a93f9dda",
      "section": "== Automated program repair ==",
      "heading_path": "== Automated program repair ==",
      "start_char": 7253,
      "end_char": 7334,
      "content": "Industrial use is limited owing to the computational cost of existing techniques.",
      "char_count": 81,
      "token_estimate": 20,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0011",
      "article_id": "formalverification_a93f9dda",
      "section": "== Industry use ==",
      "heading_path": "== Industry use ==",
      "start_char": 7323,
      "end_char": 8027,
      "content": "== Industry use == The growth in complexity of designs increases the importance of formal verification techniques in the hardware industry. At present, formal verification is used by most or all leading hardware companies, but its use in the software industry is still languishing. This could be attributed to the greater need in the hardware industry, where errors have greater commercial significance. Because of the potential subtle interactions between components, it is increasingly difficult to exercise a realistic set of possibilities by simulation. Important aspects of hardware design are amenable to automated proof methods, making formal verification easier to introduce and more productive.",
      "char_count": 703,
      "token_estimate": 175,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0012",
      "article_id": "formalverification_a93f9dda",
      "section": "== Industry use ==",
      "heading_path": "== Industry use ==",
      "start_char": 8027,
      "end_char": 9020,
      "content": "As of 2011, several operating systems have been formally verified: NICTA's Secure Embedded L4 microkernel, sold commercially as seL4 by OK Labs; OSEK/VDX based real-time operating system ORIENTAIS by East China Normal University; Green Hills Software's Integrity operating system; and SYSGO's PikeOS. In 2016, a team led by Zhong Shao at Yale developed a formally verified operating system kernel called CertiKOS. As of 2017, formal verification has been applied to the design of large computer networks through a mathematical model of the network, and as part of a new network technology category, intent-based networking. Network software vendors that offer formal verification solutions include Cisco Forward Networks and Veriflow Systems. The SPARK programming language provides a toolset which enables software development with formal verification and is used in several high-integrity systems. The CompCert C compiler is a formally verified C compiler implementing the majority of ISO C.",
      "char_count": 993,
      "token_estimate": 248,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0013",
      "article_id": "formalverification_a93f9dda",
      "section": "== See also ==",
      "heading_path": "== See also ==",
      "start_char": 9017,
      "end_char": 9341,
      "content": "== See also == Automated theorem proving Model checking List of model checking tools Formal equivalence checking Proof checker Property Specification Language Static code analysis Temporal logic in finite-state verification Post-silicon validation Intelligent verification Runtime verification Software verification Hardware verification",
      "char_count": 337,
      "token_estimate": 84,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "formalverification_a93f9dda_c0014",
      "article_id": "formalverification_a93f9dda",
      "section": "== References ==",
      "heading_path": "== References ==",
      "start_char": 9357,
      "end_char": 9357,
      "content": "== References ==",
      "char_count": 16,
      "token_estimate": 4,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 10,
    "items": [
      {
        "question": "Which operating systems had been formally verified as of 2011?",
        "answer": "As of 2011, the formally verified operating systems were NICTA's Secure Embedded L4 microkernel (sold as seL4 by OK Labs), OSEK/VDX based real-time operating system ORIENTAIS by East China Normal University, Green Hills Software's Integrity operating system, and SYSGO's PikeOS.",
        "related_chunk_ids": [
          "formalverification_a93f9dda_c0012"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What are some examples of proof assistants used in deductive verification?",
        "answer": "Examples of proof assistants used in deductive verification include HOL, ACL2, Isabelle, Rocq (previously known as Coq), and PVS.",
        "related_chunk_ids": [
          "formalverification_a93f9dda_c0005"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What are two notable techniques used in automated program repair?",
        "answer": "Satisfiability modulo theories (SMT) solvers and genetic programming.",
        "related_chunk_ids": [
          "formalverification_a93f9dda_c0009"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "Which temporal logics are commonly used to describe properties to be verified in model checking?",
        "answer": "Linear temporal logic (LTL), Property Specification Language (PSL), SystemVerilog Assertions (SVA), and computational tree logic (CTL) are commonly used.",
        "related_chunk_ids": [
          "formalverification_a93f9dda_c0003"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What is an example of an unsound technique mentioned in the text?",
        "answer": "An example of an unsound technique is one that covers only a subset of the possibilities, for instance only integers up to a certain number, and gives a 'good-enough' result.",
        "related_chunk_ids": [
          "formalverification_a93f9dda_c0007"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What is the highest Evaluation Assurance Level that the use of formal verification enables in the framework of common criteria for computer security certification?",
        "answer": "EAL7",
        "related_chunk_ids": [
          "formalverification_a93f9dda_c0000"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "How does formal verification utilize mathematical models to ensure the correctness of hardware and software systems, and what are some examples of systems and models involved?",
        "answer": "Formal verification uses mathematical models to rigorously prove or disprove the correctness of hardware and software systems with respect to formal specifications. This process involves constructing formal proofs for mathematical representations of systems, such as finite-state machines, labelled transition systems, and formal semantics. Notable examples of systems that have undergone formal verification include the CompCert verified C compiler and the seL4 high-assurance operating system kernel, both of which rely on formal proofs of their mathematical models to ensure correctness.",
        "related_chunk_ids": [
          "formalverification_a93f9dda_c0000",
          "formalverification_a93f9dda_c0001"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "How does model checking fit within the broader category of approaches discussed, and what techniques and logics are commonly used in model checking?",
        "answer": "Model checking is one of the approaches used for systematic and exhaustive exploration of mathematical models, particularly for verifying properties of finite and some infinite models. It employs techniques such as state space enumeration, symbolic state space enumeration, abstract interpretation, symbolic simulation, and abstraction refinement to efficiently explore all states and transitions. The properties to be verified in model checking are often described using temporal logics like linear temporal logic (LTL), Property Specification Language (PSL), SystemVerilog Assertions (SVA), or computational tree logic (CTL).",
        "related_chunk_ids": [
          "formalverification_a93f9dda_c0002",
          "formalverification_a93f9dda_c0003"
        ],
        "category": "LONG_ANSWER"
      },
      {
        "question": "How does formal verification utilize mathematical models to ensure the correctness of hardware and software systems, and what are some examples of systems and models involved?",
        "answer": "Formal verification uses mathematical models to prove or disprove the correctness of hardware and software systems with respect to formal specifications. This process involves creating a formal proof of a mathematical model of the system, such as finite-state machines, labelled transition systems, or Petri nets. Examples of systems that have been formally verified using these methods include the CompCert verified C compiler and the seL4 high-assurance operating system kernel.",
        "related_chunk_ids": [
          "formalverification_a93f9dda_c0000",
          "formalverification_a93f9dda_c0001"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "How do abstraction techniques in model checking help address the scalability limitations of exploring large state spaces?",
        "answer": "Abstraction techniques in model checking, such as using domain-specific abstractions or exploiting symmetry, allow groups of states to be considered in a single operation, which reduces computing time and helps manage the exploration of large or infinite state spaces. However, despite these techniques, model checking still faces scalability limitations, as symbolic models are typically restricted to a few hundred bits of state and explicit state enumeration requires relatively small state spaces.",
        "related_chunk_ids": [
          "formalverification_a93f9dda_c0003",
          "formalverification_a93f9dda_c0004"
        ],
        "category": "INTERPRETATION"
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-28T12:09:33.091Z",
    "content_format": "markdown",
    "total_chunks": 15,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}