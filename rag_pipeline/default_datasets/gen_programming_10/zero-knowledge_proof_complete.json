{
  "article": {
    "id": "zeroknowledgeproof_1c1efb23",
    "title": "Zero-knowledge proof",
    "url": "https://en.wikipedia.org/wiki/Zero-knowledge_proof",
    "lang": "en",
    "created_at": "2025-07-28T12:11:45.784489",
    "content": "---\nid: zeroknowledgeproof_1c1efb23\nurl: https://en.wikipedia.org/wiki/Zero-knowledge_proof\ntitle: Zero-knowledge proof\nlang: en\ncreated_at: '2025-07-28T12:09:46.790128'\nchecksum: 6e83cd6ca0f8e1a6d149c2a223428ed3337937c531f8ae4266d9b3ae2692784b\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gpt-4.1\nstats:\n  word_count: 5706\n  char_count: 34211\n  num_chunks: 49\n  num_sections: 0\n---\nIn cryptography, a zero-knowledge proof (also known as a ZK proof or ZKP) is a protocol in which one party (the prover) can convince another party (the verifier) that some given statement is true, without conveying to the verifier any information beyond the mere fact of that statement's truth. The intuition underlying zero-knowledge proofs is that it is trivial to prove possession of the relevant information simply by revealing it; the hard part is to prove this possession without revealing this information (or any aspect of it whatsoever). In light of the fact that one should be able to generate a proof of some statement only when in possession of certain secret information connected to the statement, the verifier, even after having become convinced of the statement's truth, should nonetheless remain unable to prove the statement to further third parties. Zero-knowledge proofs can be interactive, meaning that the prover and verifier exchange messages according to some protocol, or noninteractive, meaning that the verifier is convinced by a single prover message and no other communication is needed. In the standard model, interaction is required, except for trivial proofs of BPP problems. In the common random string and random oracle models, non-interactive zero-knowledge proofs exist. The Fiat–Shamir heuristic can be used to transform certain interactive zero-knowledge proofs into noninteractive ones. == Abstract examples == === The red card proof === One example of a math-free zero knowledge proof is if Peggy wants to prove to Victor that she has drawn a red card from a standard deck of 52 playing cards, without revealing which specific red card she holds. Victor observes Peggy draw a card at random from the shuffled deck, but she keeps the card face-down so he cannot see it. To prove her card is red without revealing its identity, Peggy takes the remaining 51 cards from the deck and systematically shows Victor all 26 black cards (the 13 spades and 13 clubs) one by one, placing them face-up on the table. Since a standard deck contains exactly 26 red cards and 26 black cards, and Peggy has demonstrated that all the black cards remain in the deck, Victor can conclude with certainty that Peggy's hidden card must be red. This proof is zero-knowledge because Victor learns only that Peggy's card is red, but gains no information about whether it is a heart or diamond, or which specific red card she holds. The proof would be equally convincing whether Peggy held the Ace of Hearts or the Two of Diamonds. Furthermore, even if the interaction were recorded, the recording would not reveal Peggy's specific card to future observers, maintaining the zero-knowledge property. If Peggy was lying and actually held a black card, she would be unable to produce all 26 black cards from the remaining deck, making deception impossible. This demonstrates the soundness of the proof system. This type of physical zero-knowledge proof using standard playing cards belongs to a broader class of card-based cryptographic protocols that allow participants to perform secure computations using everyday objects. === Where's Wally === Another well-known example of a zero-knowledge proof is the \"Where's Wally\" example. In this example, the prover wants to prove to the verifier that they know where Wally is on a page in a Where's Wally? book, without revealing his location to the verifier. The prover starts by taking a large black board with a small hole in it, the size of Wally. The board is twice the size of the book in both directions, so the verifier cannot see where on the page the prover is placing it. The prover then places the board over the page so that Wally is in the hole. The verifier can now look through the hole and see Wally, but cannot see any other part of the page. Therefore, the prover has proven to the verifier that they know where Wally is, without revealing any other information about his location. This example is not a perfect zero-knowledge proof, because the prover does reveal some information about Wally's location, such as his body position. However, it is a decent illustration of the basic concept of a zero-knowledge proof. === The Ali Baba cave === There is a well-known story presenting the fundamental ideas of zero-knowledge proofs, first published in 1990 by Jean-Jacques Quisquater and others in their paper \"How to Explain Zero-Knowledge Protocols to Your Children\". The two parties in the zero-knowledge proof story are Peggy as the prover of the statement, and Victor, the verifier of the statement. In this story, Peggy has uncovered the secret word used to open a magic door in a cave. The cave is shaped like a ring, with the entrance on one side and the magic door blocking the opposite side. Victor wants to know whether Peggy knows the secret word; but Peggy, being a very private person, does not want to reveal her knowledge (the secret word) to Victor or to reveal the fact of her knowledge to the world in general. They label the left and right paths from the entrance A and B. First, Victor waits outside the cave as Peggy goes in. Peggy takes either path A or B; Victor is not allowed to see which path she takes. Then, Victor enters the cave and shouts the name of the path he wants her to use to return, either A or B, chosen at random. Providing she really does know the magic word, this is easy: she opens the door, if necessary, and returns along the desired path. However, suppose she did not know the word. Then, she would only be able to return by the named path if Victor were to give the name of the same path by which she had entered. Since Victor would choose A or B at random, she would have a 50% chance of guessing correctly. If they were to repeat this trick many times, say 20 times in a row, her chance of successfully anticipating all of Victor's requests would be reduced to 1 in 220, or 9.54 × 10−7. Thus, if Peggy repeatedly appears at the exit Victor names, then he can conclude that it is extremely probable that Peggy does, in fact, know the secret word. One side note with respect to third-party observers: even if Victor is wearing a hidden camera that records the whole transaction, the only thing the camera will record is in one case Victor shouting \"A!\" and Peggy appearing at A or in the other case Victor shouting \"B!\" and Peggy appearing at B. A recording of this type would be trivial for any two people to fake (requiring only that Peggy and Victor agree beforehand on the sequence of As and Bs that Victor will shout). Such a recording will certainly never be convincing to anyone but the original participants. In fact, even a person who was present as an observer at the original experiment should be unconvinced, since Victor and Peggy could have orchestrated the whole \"experiment\" from start to finish. Further, if Victor chooses his As and Bs by flipping a coin on-camera, this protocol loses its zero-knowledge property; the on-camera coin flip would probably be convincing to any person watching the recording later. Thus, although this does not reveal the secret word to Victor, it does make it possible for Victor to convince the world in general that Peggy has that knowledge—counter to Peggy's stated wishes. However, digital cryptography generally \"flips coins\" by relying on a pseudo-random number generator, which is akin to a coin with a fixed pattern of heads and tails known only to the coin's owner. If Victor's coin behaved this way, then again it would be possible for Victor and Peggy to have faked the experiment, so using a pseudo-random number generator would not reveal Peggy's knowledge to the world in the same way that using a flipped coin would. Peggy could prove to Victor that she knows the magic word, without revealing it to him, in a single trial. If both Victor and Peggy go together to the mouth of the cave, Victor can watch Peggy go in through A and come out through B. This would prove with certainty that Peggy knows the magic word, without revealing the magic word to Victor. However, such a proof could be observed by a third party, or recorded by Victor and such a proof would be convincing to anybody. In other words, Peggy could not refute such proof by claiming she colluded with Victor, and she is therefore no longer in control of who is aware of her knowledge. === Two balls and the colour-blind friend === Imagine Victor is red-green colour-blind (while Peggy is not) and Peggy has two balls: one red and one green, but otherwise identical. To Victor, the balls seem completely identical. Victor is skeptical that the balls are actually distinguishable. Peggy wants to prove to Victor that the balls are in fact differently coloured, but nothing else. In particular, Peggy does not want to reveal which ball is the red one and which is the green. Here is the proof system: Peggy gives the two balls to Victor and he puts them behind his back. Next, he takes one of the balls and brings it out from behind his back and displays it. He then places it behind his back again and then chooses to reveal just one of the two balls, picking one of the two at random with equal probability. He will ask Peggy, \"Did I switch the ball?\" This whole procedure is then repeated as often as necessary. By looking at the balls' colours, Peggy can, of course, say with certainty whether or not he switched them. On the other hand, if the balls were the same colour and hence indistinguishable, Peggy's ability to determine whether a switch occurred would be no better than random guessing. Since the probability that Peggy would have randomly succeeded at identifying each switch/non-switch is 50%, the probability of having randomly succeeded at all switch/non-switches approaches zero. Over multiple trials, the success rate would statistically converge to 50%, and Peggy could not achieve a performance significantly better than chance. If Peggy and Victor repeat this \"proof\" multiple times (e.g. 20 times), Victor should become convinced that the balls are indeed differently coloured. The above proof is zero-knowledge because Victor never learns which ball is green and which is red; indeed, he gains no knowledge about how to distinguish the balls. == Definition == A zero-knowledge proof of some statement must satisfy three properties: Completeness: if the statement is true, then an honest verifier (that is, one following the protocol properly) will be convinced of this fact by an honest prover. Soundness: if the statement is false, then no cheating prover can convince an honest verifier that it is true, except with some small probability. Zero-knowledge: if the statement is true, then no verifier learns anything other than the fact that the statement is true. In other words, just knowing the statement (not the secret) is sufficient to imagine a scenario showing that the prover knows the secret. This is formalized by showing that every verifier has some simulator that, given only the statement to be proved (and no access to the prover), can produce a transcript that \"looks like\" an interaction between an honest prover and the verifier in question. The first two of these are properties of more general interactive proof systems. The third is what makes the proof zero-knowledge. Zero-knowledge proofs are not proofs in the mathematical sense of the term because there is some small probability, the soundness error, that a cheating prover will be able to convince the verifier of a false statement. In other words, zero-knowledge proofs are probabilistic \"proofs\" rather than deterministic proofs. However, there are techniques to decrease the soundness error to negligibly small values (for example, guessing correctly on a hundred or thousand binary decisions has a 1/2100 or 1/21000 soundness error, respectively. As the number of bits increases, the soundness error decreases toward zero). A formal definition of zero-knowledge must use some computational model, the most common one being that of a Turing machine. Let P, V, and S be Turing machines. An interactive proof system with (P,V) for a language L is zero-knowledge if for any probabilistic polynomial time (PPT) verifier V ^ {\\displaystyle {\\hat {V}}} there exists a PPT simulator S such that: ∀ x ∈ L , z ∈ { 0 , 1 } ∗ , View V ^ ⁡ [ P ( x ) ↔ V ^ ( x , z ) ] = S ( x , z ) , {\\displaystyle \\forall x\\in L,z\\in \\{0,1\\}^{*},\\operatorname {View} _{\\hat {V}}\\left[P(x)\\leftrightarrow {\\hat {V}}(x,z)\\right]=S(x,z),} where View V ^ {\\displaystyle {\\hat {V}}} [P(x)↔ V ^ {\\displaystyle {\\hat {V}}} (x,z)] is a record of the interactions between P(x) and V(x,z). The prover P is modeled as having unlimited computation power (in practice, P usually is a probabilistic Turing machine). Intuitively, the definition states that an interactive proof system (P,V) is zero-knowledge if for any verifier V ^ {\\displaystyle {\\hat {V}}} there exists an efficient simulator S (depending on V ^ {\\displaystyle {\\hat {V}}} ) that can reproduce the conversation between P and V ^ {\\displaystyle {\\hat {V}}} on any given input. The auxiliary string z in the definition plays the role of \"prior knowledge\" (including the random coins of V ^ {\\displaystyle {\\hat {V}}} ). The definition implies that V ^ {\\displaystyle {\\hat {V}}} cannot use any prior knowledge string z to mine information out of its conversation with P, because if S is also given this prior knowledge then it can reproduce the conversation between V ^ {\\displaystyle {\\hat {V}}} and P just as before. The definition given is that of perfect zero-knowledge. Computational zero-knowledge is obtained by requiring that the views of the verifier V ^ {\\displaystyle {\\hat {V}}} and the simulator are only computationally indistinguishable, given the auxiliary string. == Practical examples == === Discrete log of a given value === These ideas can be applied to a more realistic cryptography application. Peggy wants to prove to Victor that she knows the discrete logarithm of a given value in a given group. For example, given a value y, a large prime p, and a generator g {\\displaystyle g} , she wants to prove that she knows a value x such that gx ≡ y (mod p), without revealing x. Indeed, knowledge of x could be used as a proof of identity, in that Peggy could have such knowledge because she chose a random value x that she did not reveal to anyone, computed y = gx mod p, and distributed the value of y to all potential verifiers, such that at a later time, proving knowledge of x is equivalent to proving identity as Peggy. The protocol proceeds as follows: in each round, Peggy generates a random number r, computes C = gr mod p and discloses this to Victor. After receiving C, Victor randomly issues one of the following two requests: he either requests that Peggy discloses the value of r, or the value of (x + r) mod (p − 1). Victor can verify either answer; if he requested r, he can then compute gr mod p and verify that it matches C. If he requested (x + r) mod (p − 1), then he can verify that C is consistent with this, by computing g(x + r) mod (p − 1) mod p and verifying that it matches (C · y) mod p. If Peggy indeed knows the value of x, then she can respond to either one of Victor's possible challenges. If Peggy knew or could guess which challenge Victor is going to issue, then she could easily cheat and convince Victor that she knows x when she does not: if she knows that Victor is going to request r, then she proceeds normally: she picks r, computes C = gr mod p, and discloses C to Victor; she will be able to respond to Victor's challenge. On the other hand, if she knows that Victor will request (x + r) mod (p − 1), then she picks a random value r′, computes C′ ≡ gr′ · (gx)−1 mod p, and discloses C′ to Victor as the value of C that he is expecting. When Victor challenges her to reveal (x + r) mod (p − 1), she reveals r′, for which Victor will verify consistency, since he will in turn compute gr′ mod p, which matches C′ · y, since Peggy multiplied by the modular multiplicative inverse of y. However, if in either one of the above scenarios Victor issues a challenge other than the one she was expecting and for which she manufactured the result, then she will be unable to respond to the challenge under the assumption of infeasibility of solving the discrete log for this group. If she picked r and disclosed C = gr mod p, then she will be unable to produce a valid (x + r) mod (p − 1) that would pass Victor's verification, given that she does not know x. And if she picked a value r′ that poses as (x + r) mod (p − 1), then she would have to respond with the discrete log of the value that she disclosed – but Peggy does not know this discrete log, since the value C she disclosed was obtained through arithmetic with known values, and not by computing a power with a known exponent. Thus, a cheating prover has a 0.5 probability of successfully cheating in one round. By executing a large-enough number of rounds, the probability of a cheating prover succeeding can be made arbitrarily low. To show that the above interactive proof gives zero knowledge other than the fact that Peggy knows x, one can use similar arguments as used in the above proof of completeness and soundness. Specifically, a simulator, say Simon, who does not know x, can simulate the exchange between Peggy and Victor by the following procedure. Firstly, Simon randomly flips a fair coin. If the result is \"heads\", then he picks a random value r, computes C = gr mod p, and discloses C as if it is a message from Peggy to Victor. Then Simon also outputs a message \"request the value of r\" as if it is sent from Victor to Peggy, and immediately outputs the value of r as if it is sent from Peggy to Victor. A single round is complete. On the other hand, if the coin flipping result is \"tails\", then Simon picks a random number r′, computes C′ = gr′ · y−1 mod p, and discloses C′ as if it is a message from Peggy to Victor. Then Simon outputs \"request the value of (x + r) mod (p − 1)\" as if it is a message from Victor to Peggy. Finally, Simon outputs the value of r′ as if it is the response from Peggy back to Victor. A single round is complete. By the previous arguments when proving the completeness and soundness, the interactive communication simulated by Simon is indistinguishable from the true correspondence between Peggy and Victor. The zero-knowledge property is thus guaranteed. === Hamiltonian cycle for a large graph === The following scheme is due to Manuel Blum. In this scenario, Peggy knows a Hamiltonian cycle for a large graph G. Victor knows G but not the cycle (e.g., Peggy has generated G and revealed it to him.) Finding a Hamiltonian cycle given a large graph is believed to be computationally infeasible, since its corresponding decision version is known to be NP-complete. Peggy will prove that she knows the cycle without simply revealing it (perhaps Victor is interested in buying it but wants verification first, or maybe Peggy is the only one who knows this information and is proving her identity to Victor). To show that Peggy knows this Hamiltonian cycle, she and Victor play several rounds of a game: At the beginning of each round, Peggy creates H, a graph which is isomorphic to G (that is, H is just like G except that all the vertices have different names). Since it is trivial to translate a Hamiltonian cycle between isomorphic graphs with known isomorphism, if Peggy knows a Hamiltonian cycle for G then she also must know one for H. Peggy commits to H. She could do so by using a cryptographic commitment scheme. Alternatively, she could number the vertices of H. Next, for each edge of H, on a small piece of paper, she writes down the two vertices that the edge joins. Then she puts all these pieces of paper face down on a table. The purpose of this commitment is that Peggy is not able to change H while, at the same time, Victor has no information about H. Victor then randomly chooses one of two questions to ask Peggy. He can either ask her to show the isomorphism between H and G (see graph isomorphism problem), or he can ask her to show a Hamiltonian cycle in H. If Peggy is asked to show that the two graphs are isomorphic, then she first uncovers all of H (e.g. by turning over all pieces of papers that she put on the table) and then provides the vertex translations that map G to H. Victor can verify that they are indeed isomorphic. If Peggy is asked to prove that she knows a Hamiltonian cycle in H, then she translates her Hamiltonian cycle in G onto H and only uncovers the edges on the Hamiltonian cycle. That is, Peggy only turns over exactly |V(G)| of the pieces of paper that correspond to the edges of the Hamiltonian cycle, while leaving the rest still face-down. This is enough for Victor to check that H does indeed contain a Hamiltonian cycle. It is important that the commitment to the graph be such that Victor can verify, in the second case, that the cycle is really made of edges from H. This can be done by, for example, committing to every edge (or lack thereof) separately. ==== Completeness ==== If Peggy does know a Hamiltonian cycle in G, then she can easily satisfy Victor's demand for either the graph isomorphism producing H from G (which she had committed to in the first step) or a Hamiltonian cycle in H (which she can construct by applying the isomorphism to the cycle in G). ==== Zero-knowledge ==== Peggy's answers do not reveal the original Hamiltonian cycle in G. In each round, Victor will learn only H's isomorphism to G or a Hamiltonian cycle in H. He would need both answers for a single H to discover the cycle in G, so the information remains unknown as long as Peggy can generate a distinct H every round. If Peggy does not know of a Hamiltonian cycle in G, but somehow knew in advance what Victor would ask to see each round, then she could cheat. For example, if Peggy knew ahead of time that Victor would ask to see the Hamiltonian cycle in H, then she could generate a Hamiltonian cycle for an unrelated graph. Similarly, if Peggy knew in advance that Victor would ask to see the isomorphism then she could simply generate an isomorphic graph H (in which she also does not know a Hamiltonian cycle). Victor could simulate the protocol by himself (without Peggy) because he knows what he will ask to see. Therefore, Victor gains no information about the Hamiltonian cycle in G from the information revealed in each round. ==== Soundness ==== If Peggy does not know the information, then she can guess which question Victor will ask and generate either a graph isomorphic to G or a Hamiltonian cycle for an unrelated graph, but since she does not know a Hamiltonian cycle for G, she cannot do both. With this guesswork, her chance of fooling Victor is 2−n, where n is the number of rounds. For all realistic purposes, it is infeasibly difficult to defeat a zero-knowledge proof with a reasonable number of rounds in this way. == Variants of zero-knowledge == Different variants of zero-knowledge can be defined by formalizing the intuitive concept of what is meant by the output of the simulator \"looking like\" the execution of the real proof protocol in the following ways: We speak of perfect zero-knowledge if the distributions produced by the simulator and the proof protocol are distributed exactly the same. This is for instance the case in the first example above. Statistical zero-knowledge means that the distributions are not necessarily exactly the same, but they are statistically close, meaning that their statistical difference is a negligible function. We speak of computational zero-knowledge if no efficient algorithm can distinguish the two distributions. == Zero knowledge types == There are various types of zero-knowledge proofs: Proof of knowledge: the knowledge is hidden in the exponent like in the example shown above. Witness-indistinguishable proof: verifiers cannot know which witness is used for producing the proof. Zero-knowledge proof schemes can be constructed from various cryptographic primitives, such as hash-based cryptography, pairing-based cryptography, multi-party computation, or lattice-based cryptography. == Applications == === Authentication systems === Research in zero-knowledge proofs has been motivated by authentication systems where one party wants to prove its identity to a second party via some secret information (such as a password) but does not want the second party to learn anything about this secret. This is called a \"zero-knowledge proof of knowledge\". However, a password is typically too small or insufficiently random to be used in many schemes for zero-knowledge proofs of knowledge. A zero-knowledge password proof is a special kind of zero-knowledge proof of knowledge that addresses the limited size of passwords. In April 2015, the one-out-of-many proofs protocol (a Sigma protocol) was introduced. In August 2021, Cloudflare, an American web infrastructure and security company, decided to use the one-out-of-many proofs mechanism for private web verification using vendor hardware. === Ethical behavior === One of the uses of zero-knowledge proofs within cryptographic protocols is to enforce honest behavior while maintaining privacy. Roughly, the idea is to force a user to prove, using a zero-knowledge proof, that its behavior is correct according to the protocol. Because of soundness, we know that the user must really act honestly in order to be able to provide a valid proof. Because of zero knowledge, we know that the user does not compromise the privacy of its secrets in the process of providing the proof. === Nuclear disarmament === In 2016, the Princeton Plasma Physics Laboratory and Princeton University demonstrated a technique that may have applicability to future nuclear disarmament talks. It would allow inspectors to confirm whether or not an object is indeed a nuclear weapon without recording, sharing, or revealing the internal workings, which might be secret. === Blockchains === Zero-knowledge proofs were applied in the Zerocoin and Zerocash protocols, which culminated in the birth of Zcoin (later rebranded as Firo in 2020) and Zcash cryptocurrencies in 2016. Zerocoin has a built-in mixing model that does not trust any peers or centralised mixing providers to ensure anonymity. Users can transact in a base currency and can cycle the currency into and out of Zerocoins. The Zerocash protocol uses a similar model (a variant known as a non-interactive zero-knowledge proof) except that it can obscure the transaction amount, while Zerocoin cannot. Given significant restrictions of transaction data on the Zerocash network, Zerocash is less prone to privacy timing attacks when compared to Zerocoin. However, this additional layer of privacy can cause potentially undetected hyperinflation of Zerocash supply because fraudulent coins cannot be tracked. In 2018, Bulletproofs were introduced. Bulletproofs are an improvement from non-interactive zero-knowledge proofs where a trusted setup is not needed. It was later implemented into the Mimblewimble protocol (which the Grin and Beam cryptocurrencies are based upon) and Monero cryptocurrency. In 2019, Firo implemented the Sigma protocol, which is an improvement on the Zerocoin protocol without trusted setup. In the same year, Firo introduced the Lelantus protocol, an improvement on the Sigma protocol, where the former hides the origin and amount of a transaction. === Decentralized Identifiers === Zero-knowledge proofs by their nature can enhance privacy in identity-sharing systems, which are vulnerable to data breaches and identity theft. When integrated to a decentralized identifier system, ZKPs add an extra layer of encryption on DID documents. == History == Zero-knowledge proofs were first conceived in 1985 by Shafi Goldwasser, Silvio Micali, and Charles Rackoff in their paper \"The Knowledge Complexity of Interactive Proof-Systems\". This paper introduced the IP hierarchy of interactive proof systems (see interactive proof system) and conceived the concept of knowledge complexity, a measurement of the amount of knowledge about the proof transferred from the prover to the verifier. They also gave the first zero-knowledge proof for a concrete problem, that of deciding quadratic nonresidues mod m. Together with a paper by László Babai and Shlomo Moran, this landmark paper invented interactive proof systems, for which all five authors won the first Gödel Prize in 1993. In their own words, Goldwasser, Micali, and Rackoff say: Of particular interest is the case where this additional knowledge is essentially 0 and we show that [it] is possible to interactively prove that a number is quadratic non residue mod m releasing 0 additional knowledge. This is surprising as no efficient algorithm for deciding quadratic residuosity mod m is known when m’s factorization is not given. Moreover, all known NP proofs for this problem exhibit the prime factorization of m. This indicates that adding interaction to the proving process, may decrease the amount of knowledge that must be communicated in order to prove a theorem. The quadratic nonresidue problem has both an NP and a co-NP algorithm, and so lies in the intersection of NP and co-NP. This was also true of several other problems for which zero-knowledge proofs were subsequently discovered, such as an unpublished proof system by Oded Goldreich verifying that a two-prime modulus is not a Blum integer. Oded Goldreich, Silvio Micali, and Avi Wigderson took this one step further, showing that, assuming the existence of unbreakable encryption, one can create a zero-knowledge proof system for the NP-complete graph coloring problem with three colors. Since every problem in NP can be efficiently reduced to this problem, this means that, under this assumption, all problems in NP have zero-knowledge proofs. The reason for the assumption is that, as in the above example, their protocols require encryption. A commonly cited sufficient condition for the existence of unbreakable encryption is the existence of one-way functions, but it is conceivable that some physical means might also achieve it. On top of this, they also showed that the graph nonisomorphism problem, the complement of the graph isomorphism problem, has a zero-knowledge proof. This problem is in co-NP, but is not currently known to be in either NP or any practical class. More generally, Russell Impagliazzo and Moti Yung as well as Ben-Or et al. would go on to show that, also assuming one-way functions or unbreakable encryption, there are zero-knowledge proofs for all problems in IP = PSPACE, or in other words, anything that can be proved by an interactive proof system can be proved with zero knowledge. Not liking to make unnecessary assumptions, many theorists sought a way to eliminate the necessity of one way functions. One way this was done was with multi-prover interactive proof systems (see interactive proof system), which have multiple independent provers instead of only one, allowing the verifier to \"cross-examine\" the provers in isolation to avoid being misled. It can be shown that, without any intractability assumptions, all languages in NP have zero-knowledge proofs in such a system. It turns out that, in an Internet-like setting, where multiple protocols may be executed concurrently, building zero-knowledge proofs is more challenging. The line of research investigating concurrent zero-knowledge proofs was initiated by the work of Dwork, Naor, and Sahai. One particular development along these lines has been the development of witness-indistinguishable proof protocols. The property of witness-indistinguishability is related to that of zero-knowledge, yet witness-indistinguishable protocols do not suffer from the same problems of concurrent execution. Another variant of zero-knowledge proofs are non-interactive zero-knowledge proofs. Blum, Feldman, and Micali showed that a common random string shared between the prover and the verifier is enough to achieve computational zero-knowledge without requiring interaction. == Zero-Knowledge Proof protocols == The most popular interactive or non-interactive zero-knowledge proof (e.g., zk-SNARK) protocols can be broadly categorized in the following four categories: Succinct Non-Interactive ARguments of Knowledge (SNARK), Scalable Transparent ARgument of Knowledge (STARK), Verifiable Polynomial Delegation (VPD), and Succinct Non-interactive ARGuments (SNARG). A list of zero-knowledge proof protocols and libraries is provided below along with comparisons based on transparency, universality, plausible post-quantum security, and programming paradigm. A transparent protocol is one that does not require any trusted setup and uses public randomness. A universal protocol is one that does not require a separate trusted setup for each circuit. Finally, a plausibly post-quantum protocol is one that is not susceptible to known attacks involving quantum algorithms. == Security vulnerabilities of zero-knowledge systems == While zero-knowledge proofs offer a secure way to verify information, the arithmetic circuits that implement them must be carefully designed. If these circuits lack sufficient constraints, they may introduce subtle yet critical security vulnerabilities. One of the most common classes of vulnerabilities in these systems is under-constrained logic, where insufficient constraints allow a malicious prover to produce a proof for an incorrect statement that still passes verification. A 2024 systematization of known attacks found that approximately 96% of documented circuit-layer bugs in SNARK-based systems were due to under-constrained circuits. These vulnerabilities often arise during the translation of high-level logic into low-level constraint systems, particularly when using domain-specific languages such as Circom or Gnark. Recent research has demonstrated that formally proving determinism – ensuring that a circuit's outputs are uniquely determined by its inputs – can eliminate entire classes of these vulnerabilities. == See also == == External links == Computer scientist Amit Sahai explains the Zero-knowledge proof in 5 Levels of Difficulty on YouTube == References =="
  },
  "chunks": [
    {
      "id": "zeroknowledgeproof_1c1efb23_c0000",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 869,
      "content": "In cryptography, a zero-knowledge proof (also known as a ZK proof or ZKP) is a protocol in which one party (the prover) can convince another party (the verifier) that some given statement is true, without conveying to the verifier any information beyond the mere fact of that statement's truth. The intuition underlying zero-knowledge proofs is that it is trivial to prove possession of the relevant information simply by revealing it; the hard part is to prove this possession without revealing this information (or any aspect of it whatsoever). In light of the fact that one should be able to generate a proof of some statement only when in possession of certain secret information connected to the statement, the verifier, even after having become convinced of the statement's truth, should nonetheless remain unable to prove the statement to further third parties.",
      "char_count": 868,
      "token_estimate": 217,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0001",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 869,
      "end_char": 1425,
      "content": "Zero-knowledge proofs can be interactive, meaning that the prover and verifier exchange messages according to some protocol, or noninteractive, meaning that the verifier is convinced by a single prover message and no other communication is needed. In the standard model, interaction is required, except for trivial proofs of BPP problems. In the common random string and random oracle models, non-interactive zero-knowledge proofs exist. The Fiat–Shamir heuristic can be used to transform certain interactive zero-knowledge proofs into noninteractive ones.",
      "char_count": 556,
      "token_estimate": 139,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0002",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Abstract examples ==",
      "heading_path": "== Abstract examples ==",
      "start_char": 1449,
      "end_char": 1450,
      "content": "== Abstract examples ==",
      "char_count": 23,
      "token_estimate": 5,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0003",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = The red card proof ==",
      "heading_path": "== = The red card proof ==",
      "start_char": 1476,
      "end_char": 2286,
      "content": "== = The red card proof === One example of a math-free zero knowledge proof is if Peggy wants to prove to Victor that she has drawn a red card from a standard deck of 52 playing cards, without revealing which specific red card she holds. Victor observes Peggy draw a card at random from the shuffled deck, but she keeps the card face-down so he cannot see it. To prove her card is red without revealing its identity, Peggy takes the remaining 51 cards from the deck and systematically shows Victor all 26 black cards (the 13 spades and 13 clubs) one by one, placing them face-up on the table. Since a standard deck contains exactly 26 red cards and 26 black cards, and Peggy has demonstrated that all the black cards remain in the deck, Victor can conclude with certainty that Peggy's hidden card must be red.",
      "char_count": 809,
      "token_estimate": 202,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0004",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = The red card proof ==",
      "heading_path": "== = The red card proof ==",
      "start_char": 2286,
      "end_char": 3160,
      "content": "This proof is zero-knowledge because Victor learns only that Peggy's card is red, but gains no information about whether it is a heart or diamond, or which specific red card she holds. The proof would be equally convincing whether Peggy held the Ace of Hearts or the Two of Diamonds. Furthermore, even if the interaction were recorded, the recording would not reveal Peggy's specific card to future observers, maintaining the zero-knowledge property. If Peggy was lying and actually held a black card, she would be unable to produce all 26 black cards from the remaining deck, making deception impossible. This demonstrates the soundness of the proof system. This type of physical zero-knowledge proof using standard playing cards belongs to a broader class of card-based cryptographic protocols that allow participants to perform secure computations using everyday objects.",
      "char_count": 874,
      "token_estimate": 218,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0005",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Where's Wally ==",
      "heading_path": "== = Where's Wally ==",
      "start_char": 3156,
      "end_char": 4129,
      "content": "== = Where's Wally === Another well-known example of a zero-knowledge proof is the \"Where's Wally\" example. In this example, the prover wants to prove to the verifier that they know where Wally is on a page in a Where's Wally? book, without revealing his location to the verifier. The prover starts by taking a large black board with a small hole in it, the size of Wally. The board is twice the size of the book in both directions, so the verifier cannot see where on the page the prover is placing it. The prover then places the board over the page so that Wally is in the hole. The verifier can now look through the hole and see Wally, but cannot see any other part of the page. Therefore, the prover has proven to the verifier that they know where Wally is, without revealing any other information about his location. This example is not a perfect zero-knowledge proof, because the prover does reveal some information about Wally's location, such as his body position.",
      "char_count": 972,
      "token_estimate": 243,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0006",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Where's Wally ==",
      "heading_path": "== = Where's Wally ==",
      "start_char": 4129,
      "end_char": 4213,
      "content": "However, it is a decent illustration of the basic concept of a zero-knowledge proof.",
      "char_count": 84,
      "token_estimate": 21,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0007",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = The Ali Baba cave ==",
      "heading_path": "== = The Ali Baba cave ==",
      "start_char": 4218,
      "end_char": 5147,
      "content": "== = The Ali Baba cave === There is a well-known story presenting the fundamental ideas of zero-knowledge proofs, first published in 1990 by Jean-Jacques Quisquater and others in their paper \"How to Explain Zero-Knowledge Protocols to Your Children\". The two parties in the zero-knowledge proof story are Peggy as the prover of the statement, and Victor, the verifier of the statement. In this story, Peggy has uncovered the secret word used to open a magic door in a cave. The cave is shaped like a ring, with the entrance on one side and the magic door blocking the opposite side. Victor wants to know whether Peggy knows the secret word; but Peggy, being a very private person, does not want to reveal her knowledge (the secret word) to Victor or to reveal the fact of her knowledge to the world in general. They label the left and right paths from the entrance A and B. First, Victor waits outside the cave as Peggy goes in.",
      "char_count": 928,
      "token_estimate": 232,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0008",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = The Ali Baba cave ==",
      "heading_path": "== = The Ali Baba cave ==",
      "start_char": 5147,
      "end_char": 6095,
      "content": "Peggy takes either path A or B; Victor is not allowed to see which path she takes. Then, Victor enters the cave and shouts the name of the path he wants her to use to return, either A or B, chosen at random. Providing she really does know the magic word, this is easy: she opens the door, if necessary, and returns along the desired path. However, suppose she did not know the word. Then, she would only be able to return by the named path if Victor were to give the name of the same path by which she had entered. Since Victor would choose A or B at random, she would have a 50% chance of guessing correctly. If they were to repeat this trick many times, say 20 times in a row, her chance of successfully anticipating all of Victor's requests would be reduced to 1 in 220, or 9.54 × 10−7. Thus, if Peggy repeatedly appears at the exit Victor names, then he can conclude that it is extremely probable that Peggy does, in fact, know the secret word.",
      "char_count": 948,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0009",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = The Ali Baba cave ==",
      "heading_path": "== = The Ali Baba cave ==",
      "start_char": 6096,
      "end_char": 7077,
      "content": "One side note with respect to third-party observers: even if Victor is wearing a hidden camera that records the whole transaction, the only thing the camera will record is in one case Victor shouting \"A!\" and Peggy appearing at A or in the other case Victor shouting \"B!\" and Peggy appearing at B. A recording of this type would be trivial for any two people to fake (requiring only that Peggy and Victor agree beforehand on the sequence of As and Bs that Victor will shout). Such a recording will certainly never be convincing to anyone but the original participants. In fact, even a person who was present as an observer at the original experiment should be unconvinced, since Victor and Peggy could have orchestrated the whole \"experiment\" from start to finish. Further, if Victor chooses his As and Bs by flipping a coin on-camera, this protocol loses its zero-knowledge property; the on-camera coin flip would probably be convincing to any person watching the recording later.",
      "char_count": 981,
      "token_estimate": 245,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0010",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = The Ali Baba cave ==",
      "heading_path": "== = The Ali Baba cave ==",
      "start_char": 7078,
      "end_char": 8070,
      "content": "Thus, although this does not reveal the secret word to Victor, it does make it possible for Victor to convince the world in general that Peggy has that knowledge—counter to Peggy's stated wishes. However, digital cryptography generally \"flips coins\" by relying on a pseudo-random number generator, which is akin to a coin with a fixed pattern of heads and tails known only to the coin's owner. If Victor's coin behaved this way, then again it would be possible for Victor and Peggy to have faked the experiment, so using a pseudo-random number generator would not reveal Peggy's knowledge to the world in the same way that using a flipped coin would. Peggy could prove to Victor that she knows the magic word, without revealing it to him, in a single trial. If both Victor and Peggy go together to the mouth of the cave, Victor can watch Peggy go in through A and come out through B. This would prove with certainty that Peggy knows the magic word, without revealing the magic word to Victor.",
      "char_count": 992,
      "token_estimate": 248,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0011",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = The Ali Baba cave ==",
      "heading_path": "== = The Ali Baba cave ==",
      "start_char": 8071,
      "end_char": 8363,
      "content": "However, such a proof could be observed by a third party, or recorded by Victor and such a proof would be convincing to anybody. In other words, Peggy could not refute such proof by claiming she colluded with Victor, and she is therefore no longer in control of who is aware of her knowledge.",
      "char_count": 292,
      "token_estimate": 73,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0012",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Two balls and the colour-blind friend ==",
      "heading_path": "== = Two balls and the colour-blind friend ==",
      "start_char": 8384,
      "end_char": 9312,
      "content": "== = Two balls and the colour-blind friend === Imagine Victor is red-green colour-blind (while Peggy is not) and Peggy has two balls: one red and one green, but otherwise identical. To Victor, the balls seem completely identical. Victor is skeptical that the balls are actually distinguishable. Peggy wants to prove to Victor that the balls are in fact differently coloured, but nothing else. In particular, Peggy does not want to reveal which ball is the red one and which is the green. Here is the proof system: Peggy gives the two balls to Victor and he puts them behind his back. Next, he takes one of the balls and brings it out from behind his back and displays it. He then places it behind his back again and then chooses to reveal just one of the two balls, picking one of the two at random with equal probability. He will ask Peggy, \"Did I switch the ball?\" This whole procedure is then repeated as often as necessary.",
      "char_count": 927,
      "token_estimate": 231,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0013",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Two balls and the colour-blind friend ==",
      "heading_path": "== = Two balls and the colour-blind friend ==",
      "start_char": 9312,
      "end_char": 10264,
      "content": "By looking at the balls' colours, Peggy can, of course, say with certainty whether or not he switched them. On the other hand, if the balls were the same colour and hence indistinguishable, Peggy's ability to determine whether a switch occurred would be no better than random guessing. Since the probability that Peggy would have randomly succeeded at identifying each switch/non-switch is 50%, the probability of having randomly succeeded at all switch/non-switches approaches zero. Over multiple trials, the success rate would statistically converge to 50%, and Peggy could not achieve a performance significantly better than chance. If Peggy and Victor repeat this \"proof\" multiple times (e.g. 20 times), Victor should become convinced that the balls are indeed differently coloured. The above proof is zero-knowledge because Victor never learns which ball is green and which is red; indeed, he gains no knowledge about how to distinguish the balls.",
      "char_count": 952,
      "token_estimate": 238,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0014",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Definition ==",
      "heading_path": "== Definition ==",
      "start_char": 10236,
      "end_char": 11153,
      "content": "== Definition == A zero-knowledge proof of some statement must satisfy three properties: Completeness: if the statement is true, then an honest verifier (that is, one following the protocol properly) will be convinced of this fact by an honest prover. Soundness: if the statement is false, then no cheating prover can convince an honest verifier that it is true, except with some small probability. Zero-knowledge: if the statement is true, then no verifier learns anything other than the fact that the statement is true. In other words, just knowing the statement (not the secret) is sufficient to imagine a scenario showing that the prover knows the secret. This is formalized by showing that every verifier has some simulator that, given only the statement to be proved (and no access to the prover), can produce a transcript that \"looks like\" an interaction between an honest prover and the verifier in question.",
      "char_count": 916,
      "token_estimate": 229,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0015",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Definition ==",
      "heading_path": "== Definition ==",
      "start_char": 11153,
      "end_char": 12059,
      "content": "The first two of these are properties of more general interactive proof systems. The third is what makes the proof zero-knowledge. Zero-knowledge proofs are not proofs in the mathematical sense of the term because there is some small probability, the soundness error, that a cheating prover will be able to convince the verifier of a false statement. In other words, zero-knowledge proofs are probabilistic \"proofs\" rather than deterministic proofs. However, there are techniques to decrease the soundness error to negligibly small values (for example, guessing correctly on a hundred or thousand binary decisions has a 1/2100 or 1/21000 soundness error, respectively. As the number of bits increases, the soundness error decreases toward zero). A formal definition of zero-knowledge must use some computational model, the most common one being that of a Turing machine. Let P, V, and S be Turing machines.",
      "char_count": 906,
      "token_estimate": 226,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0016",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Definition ==",
      "heading_path": "== Definition ==",
      "start_char": 12060,
      "end_char": 12748,
      "content": "An interactive proof system with (P,V) for a language L is zero-knowledge if for any probabilistic polynomial time (PPT) verifier V ^ {\\displaystyle {\\hat {V}}} there exists a PPT simulator S such that: ∀ x ∈ L , z ∈ { 0 , 1 } ∗ , View V ^ ⁡ [ P ( x ) ↔ V ^ ( x , z ) ] = S ( x , z ) , {\\displaystyle \\forall x\\in L,z\\in \\{0,1\\}^{*},\\operatorname {View} _{\\hat {V}}\\left[P(x)\\leftrightarrow {\\hat {V}}(x,z)\\right]=S(x,z),} where View V ^ {\\displaystyle {\\hat {V}}} [P(x)↔ V ^ {\\displaystyle {\\hat {V}}} (x,z)] is a record of the interactions between P(x) and V(x,z). The prover P is modeled as having unlimited computation power (in practice, P usually is a probabilistic Turing machine).",
      "char_count": 688,
      "token_estimate": 172,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0017",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Definition ==",
      "heading_path": "== Definition ==",
      "start_char": 12749,
      "end_char": 13574,
      "content": "Intuitively, the definition states that an interactive proof system (P,V) is zero-knowledge if for any verifier V ^ {\\displaystyle {\\hat {V}}} there exists an efficient simulator S (depending on V ^ {\\displaystyle {\\hat {V}}} ) that can reproduce the conversation between P and V ^ {\\displaystyle {\\hat {V}}} on any given input. The auxiliary string z in the definition plays the role of \"prior knowledge\" (including the random coins of V ^ {\\displaystyle {\\hat {V}}} ). The definition implies that V ^ {\\displaystyle {\\hat {V}}} cannot use any prior knowledge string z to mine information out of its conversation with P, because if S is also given this prior knowledge then it can reproduce the conversation between V ^ {\\displaystyle {\\hat {V}}} and P just as before. The definition given is that of perfect zero-knowledge.",
      "char_count": 825,
      "token_estimate": 206,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0018",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Definition ==",
      "heading_path": "== Definition ==",
      "start_char": 13575,
      "end_char": 13780,
      "content": "Computational zero-knowledge is obtained by requiring that the views of the verifier V ^ {\\displaystyle {\\hat {V}}} and the simulator are only computationally indistinguishable, given the auxiliary string.",
      "char_count": 205,
      "token_estimate": 51,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0019",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Practical examples ==",
      "heading_path": "== Practical examples ==",
      "start_char": 13789,
      "end_char": 13790,
      "content": "== Practical examples ==",
      "char_count": 24,
      "token_estimate": 6,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0020",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Discrete log of a given value ==",
      "heading_path": "== = Discrete log of a given value ==",
      "start_char": 13827,
      "end_char": 14702,
      "content": "== = Discrete log of a given value === These ideas can be applied to a more realistic cryptography application. Peggy wants to prove to Victor that she knows the discrete logarithm of a given value in a given group. For example, given a value y, a large prime p, and a generator g {\\displaystyle g} , she wants to prove that she knows a value x such that gx ≡ y (mod p), without revealing x. Indeed, knowledge of x could be used as a proof of identity, in that Peggy could have such knowledge because she chose a random value x that she did not reveal to anyone, computed y = gx mod p, and distributed the value of y to all potential verifiers, such that at a later time, proving knowledge of x is equivalent to proving identity as Peggy. The protocol proceeds as follows: in each round, Peggy generates a random number r, computes C = gr mod p and discloses this to Victor.",
      "char_count": 874,
      "token_estimate": 218,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0021",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Discrete log of a given value ==",
      "heading_path": "== = Discrete log of a given value ==",
      "start_char": 14702,
      "end_char": 15606,
      "content": "After receiving C, Victor randomly issues one of the following two requests: he either requests that Peggy discloses the value of r, or the value of (x + r) mod (p − 1). Victor can verify either answer; if he requested r, he can then compute gr mod p and verify that it matches C. If he requested (x + r) mod (p − 1), then he can verify that C is consistent with this, by computing g(x + r) mod (p − 1) mod p and verifying that it matches (C · y) mod p. If Peggy indeed knows the value of x, then she can respond to either one of Victor's possible challenges. If Peggy knew or could guess which challenge Victor is going to issue, then she could easily cheat and convince Victor that she knows x when she does not: if she knows that Victor is going to request r, then she proceeds normally: she picks r, computes C = gr mod p, and discloses C to Victor; she will be able to respond to Victor's challenge.",
      "char_count": 904,
      "token_estimate": 226,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0022",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Discrete log of a given value ==",
      "heading_path": "== = Discrete log of a given value ==",
      "start_char": 15607,
      "end_char": 16532,
      "content": "On the other hand, if she knows that Victor will request (x + r) mod (p − 1), then she picks a random value r′, computes C′ ≡ gr′ · (gx)−1 mod p, and discloses C′ to Victor as the value of C that he is expecting. When Victor challenges her to reveal (x + r) mod (p − 1), she reveals r′, for which Victor will verify consistency, since he will in turn compute gr′ mod p, which matches C′ · y, since Peggy multiplied by the modular multiplicative inverse of y. However, if in either one of the above scenarios Victor issues a challenge other than the one she was expecting and for which she manufactured the result, then she will be unable to respond to the challenge under the assumption of infeasibility of solving the discrete log for this group. If she picked r and disclosed C = gr mod p, then she will be unable to produce a valid (x + r) mod (p − 1) that would pass Victor's verification, given that she does not know x.",
      "char_count": 925,
      "token_estimate": 231,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0023",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Discrete log of a given value ==",
      "heading_path": "== = Discrete log of a given value ==",
      "start_char": 16533,
      "end_char": 17440,
      "content": "And if she picked a value r′ that poses as (x + r) mod (p − 1), then she would have to respond with the discrete log of the value that she disclosed – but Peggy does not know this discrete log, since the value C she disclosed was obtained through arithmetic with known values, and not by computing a power with a known exponent. Thus, a cheating prover has a 0.5 probability of successfully cheating in one round. By executing a large-enough number of rounds, the probability of a cheating prover succeeding can be made arbitrarily low. To show that the above interactive proof gives zero knowledge other than the fact that Peggy knows x, one can use similar arguments as used in the above proof of completeness and soundness. Specifically, a simulator, say Simon, who does not know x, can simulate the exchange between Peggy and Victor by the following procedure. Firstly, Simon randomly flips a fair coin.",
      "char_count": 907,
      "token_estimate": 226,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0024",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Discrete log of a given value ==",
      "heading_path": "== = Discrete log of a given value ==",
      "start_char": 17441,
      "end_char": 18394,
      "content": "If the result is \"heads\", then he picks a random value r, computes C = gr mod p, and discloses C as if it is a message from Peggy to Victor. Then Simon also outputs a message \"request the value of r\" as if it is sent from Victor to Peggy, and immediately outputs the value of r as if it is sent from Peggy to Victor. A single round is complete. On the other hand, if the coin flipping result is \"tails\", then Simon picks a random number r′, computes C′ = gr′ · y−1 mod p, and discloses C′ as if it is a message from Peggy to Victor. Then Simon outputs \"request the value of (x + r) mod (p − 1)\" as if it is a message from Victor to Peggy. Finally, Simon outputs the value of r′ as if it is the response from Peggy back to Victor. A single round is complete. By the previous arguments when proving the completeness and soundness, the interactive communication simulated by Simon is indistinguishable from the true correspondence between Peggy and Victor.",
      "char_count": 953,
      "token_estimate": 238,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0025",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Discrete log of a given value ==",
      "heading_path": "== = Discrete log of a given value ==",
      "start_char": 18395,
      "end_char": 18442,
      "content": "The zero-knowledge property is thus guaranteed.",
      "char_count": 47,
      "token_estimate": 11,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0026",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Hamiltonian cycle for a large graph ==",
      "heading_path": "== = Hamiltonian cycle for a large graph ==",
      "start_char": 18449,
      "end_char": 19356,
      "content": "== = Hamiltonian cycle for a large graph === The following scheme is due to Manuel Blum. In this scenario, Peggy knows a Hamiltonian cycle for a large graph G. Victor knows G but not the cycle (e.g., Peggy has generated G and revealed it to him.) Finding a Hamiltonian cycle given a large graph is believed to be computationally infeasible, since its corresponding decision version is known to be NP-complete. Peggy will prove that she knows the cycle without simply revealing it (perhaps Victor is interested in buying it but wants verification first, or maybe Peggy is the only one who knows this information and is proving her identity to Victor). To show that Peggy knows this Hamiltonian cycle, she and Victor play several rounds of a game: At the beginning of each round, Peggy creates H, a graph which is isomorphic to G (that is, H is just like G except that all the vertices have different names).",
      "char_count": 906,
      "token_estimate": 226,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0027",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Hamiltonian cycle for a large graph ==",
      "heading_path": "== = Hamiltonian cycle for a large graph ==",
      "start_char": 19356,
      "end_char": 20275,
      "content": "Since it is trivial to translate a Hamiltonian cycle between isomorphic graphs with known isomorphism, if Peggy knows a Hamiltonian cycle for G then she also must know one for H. Peggy commits to H. She could do so by using a cryptographic commitment scheme. Alternatively, she could number the vertices of H. Next, for each edge of H, on a small piece of paper, she writes down the two vertices that the edge joins. Then she puts all these pieces of paper face down on a table. The purpose of this commitment is that Peggy is not able to change H while, at the same time, Victor has no information about H. Victor then randomly chooses one of two questions to ask Peggy. He can either ask her to show the isomorphism between H and G (see graph isomorphism problem), or he can ask her to show a Hamiltonian cycle in H. If Peggy is asked to show that the two graphs are isomorphic, then she first uncovers all of H (e.g.",
      "char_count": 919,
      "token_estimate": 229,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0028",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Hamiltonian cycle for a large graph ==",
      "heading_path": "== = Hamiltonian cycle for a large graph ==",
      "start_char": 20276,
      "end_char": 21109,
      "content": "by turning over all pieces of papers that she put on the table) and then provides the vertex translations that map G to H. Victor can verify that they are indeed isomorphic. If Peggy is asked to prove that she knows a Hamiltonian cycle in H, then she translates her Hamiltonian cycle in G onto H and only uncovers the edges on the Hamiltonian cycle. That is, Peggy only turns over exactly |V(G)| of the pieces of paper that correspond to the edges of the Hamiltonian cycle, while leaving the rest still face-down. This is enough for Victor to check that H does indeed contain a Hamiltonian cycle. It is important that the commitment to the graph be such that Victor can verify, in the second case, that the cycle is really made of edges from H. This can be done by, for example, committing to every edge (or lack thereof) separately.",
      "char_count": 833,
      "token_estimate": 208,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0029",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Variants of zero-knowledge ==",
      "heading_path": "== Variants of zero-knowledge ==",
      "start_char": 21099,
      "end_char": 21815,
      "content": "== Variants of zero-knowledge == Different variants of zero-knowledge can be defined by formalizing the intuitive concept of what is meant by the output of the simulator \"looking like\" the execution of the real proof protocol in the following ways: We speak of perfect zero-knowledge if the distributions produced by the simulator and the proof protocol are distributed exactly the same. This is for instance the case in the first example above. Statistical zero-knowledge means that the distributions are not necessarily exactly the same, but they are statistically close, meaning that their statistical difference is a negligible function. We speak of computational zero-knowledge if no efficient algorithm can distinguish the two distributions.",
      "char_count": 747,
      "token_estimate": 186,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0030",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Zero knowledge types ==",
      "heading_path": "== Zero knowledge types ==",
      "start_char": 21841,
      "end_char": 22291,
      "content": "== Zero knowledge types == There are various types of zero-knowledge proofs: Proof of knowledge: the knowledge is hidden in the exponent like in the example shown above. Witness-indistinguishable proof: verifiers cannot know which witness is used for producing the proof. Zero-knowledge proof schemes can be constructed from various cryptographic primitives, such as hash-based cryptography, pairing-based cryptography, multi-party computation, or lattice-based cryptography.",
      "char_count": 475,
      "token_estimate": 118,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0031",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Applications ==",
      "heading_path": "== Applications ==",
      "start_char": 22309,
      "end_char": 22310,
      "content": "== Applications ==",
      "char_count": 18,
      "token_estimate": 4,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0032",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Authentication systems ==",
      "heading_path": "== = Authentication systems ==",
      "start_char": 22340,
      "end_char": 23197,
      "content": "== = Authentication systems === Research in zero-knowledge proofs has been motivated by authentication systems where one party wants to prove its identity to a second party via some secret information (such as a password) but does not want the second party to learn anything about this secret. This is called a \"zero-knowledge proof of knowledge\". However, a password is typically too small or insufficiently random to be used in many schemes for zero-knowledge proofs of knowledge. A zero-knowledge password proof is a special kind of zero-knowledge proof of knowledge that addresses the limited size of passwords. In April 2015, the one-out-of-many proofs protocol (a Sigma protocol) was introduced. In August 2021, Cloudflare, an American web infrastructure and security company, decided to use the one-out-of-many proofs mechanism for private web verification using vendor hardware.",
      "char_count": 886,
      "token_estimate": 221,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0033",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Ethical behavior ==",
      "heading_path": "== = Ethical behavior ==",
      "start_char": 23221,
      "end_char": 23735,
      "content": "== = Ethical behavior === One of the uses of zero-knowledge proofs within cryptographic protocols is to enforce honest behavior while maintaining privacy. Roughly, the idea is to force a user to prove, using a zero-knowledge proof, that its behavior is correct according to the protocol. Because of soundness, we know that the user must really act honestly in order to be able to provide a valid proof. Because of zero knowledge, we know that the user does not compromise the privacy of its secrets in the process of providing the proof.",
      "char_count": 537,
      "token_estimate": 134,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0034",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Nuclear disarmament ==",
      "heading_path": "== = Nuclear disarmament ==",
      "start_char": 23762,
      "end_char": 24104,
      "content": "== = Nuclear disarmament === In 2016, the Princeton Plasma Physics Laboratory and Princeton University demonstrated a technique that may have applicability to future nuclear disarmament talks. It would allow inspectors to confirm whether or not an object is indeed a nuclear weapon without recording, sharing, or revealing the internal workings, which might be secret.",
      "char_count": 368,
      "token_estimate": 92,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0035",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Blockchains ==",
      "heading_path": "== = Blockchains ==",
      "start_char": 24123,
      "end_char": 25061,
      "content": "== = Blockchains === Zero-knowledge proofs were applied in the Zerocoin and Zerocash protocols, which culminated in the birth of Zcoin (later rebranded as Firo in 2020) and Zcash cryptocurrencies in 2016. Zerocoin has a built-in mixing model that does not trust any peers or centralised mixing providers to ensure anonymity. Users can transact in a base currency and can cycle the currency into and out of Zerocoins. The Zerocash protocol uses a similar model (a variant known as a non-interactive zero-knowledge proof) except that it can obscure the transaction amount, while Zerocoin cannot. Given significant restrictions of transaction data on the Zerocash network, Zerocash is less prone to privacy timing attacks when compared to Zerocoin. However, this additional layer of privacy can cause potentially undetected hyperinflation of Zerocash supply because fraudulent coins cannot be tracked. In 2018, Bulletproofs were introduced.",
      "char_count": 937,
      "token_estimate": 234,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0036",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Blockchains ==",
      "heading_path": "== = Blockchains ==",
      "start_char": 25061,
      "end_char": 25589,
      "content": "Bulletproofs are an improvement from non-interactive zero-knowledge proofs where a trusted setup is not needed. It was later implemented into the Mimblewimble protocol (which the Grin and Beam cryptocurrencies are based upon) and Monero cryptocurrency. In 2019, Firo implemented the Sigma protocol, which is an improvement on the Zerocoin protocol without trusted setup. In the same year, Firo introduced the Lelantus protocol, an improvement on the Sigma protocol, where the former hides the origin and amount of a transaction.",
      "char_count": 528,
      "token_estimate": 132,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0037",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== = Decentralized Identifiers ==",
      "heading_path": "== = Decentralized Identifiers ==",
      "start_char": 25604,
      "end_char": 25861,
      "content": "== = Decentralized Identifiers === Zero-knowledge proofs by their nature can enhance privacy in identity-sharing systems, which are vulnerable to data breaches and identity theft. When integrated to a decentralized identifier system, ZKPs add an extra layer of encryption on DID documents.",
      "char_count": 289,
      "token_estimate": 72,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0038",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 25874,
      "end_char": 26609,
      "content": "== History == Zero-knowledge proofs were first conceived in 1985 by Shafi Goldwasser, Silvio Micali, and Charles Rackoff in their paper \"The Knowledge Complexity of Interactive Proof-Systems\". This paper introduced the IP hierarchy of interactive proof systems (see interactive proof system) and conceived the concept of knowledge complexity, a measurement of the amount of knowledge about the proof transferred from the prover to the verifier. They also gave the first zero-knowledge proof for a concrete problem, that of deciding quadratic nonresidues mod m. Together with a paper by László Babai and Shlomo Moran, this landmark paper invented interactive proof systems, for which all five authors won the first Gödel Prize in 1993.",
      "char_count": 734,
      "token_estimate": 183,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0039",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 26609,
      "end_char": 27596,
      "content": "In their own words, Goldwasser, Micali, and Rackoff say: Of particular interest is the case where this additional knowledge is essentially 0 and we show that [it] is possible to interactively prove that a number is quadratic non residue mod m releasing 0 additional knowledge. This is surprising as no efficient algorithm for deciding quadratic residuosity mod m is known when m’s factorization is not given. Moreover, all known NP proofs for this problem exhibit the prime factorization of m. This indicates that adding interaction to the proving process, may decrease the amount of knowledge that must be communicated in order to prove a theorem. The quadratic nonresidue problem has both an NP and a co-NP algorithm, and so lies in the intersection of NP and co-NP. This was also true of several other problems for which zero-knowledge proofs were subsequently discovered, such as an unpublished proof system by Oded Goldreich verifying that a two-prime modulus is not a Blum integer.",
      "char_count": 987,
      "token_estimate": 246,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0040",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 27597,
      "end_char": 28537,
      "content": "Oded Goldreich, Silvio Micali, and Avi Wigderson took this one step further, showing that, assuming the existence of unbreakable encryption, one can create a zero-knowledge proof system for the NP-complete graph coloring problem with three colors. Since every problem in NP can be efficiently reduced to this problem, this means that, under this assumption, all problems in NP have zero-knowledge proofs. The reason for the assumption is that, as in the above example, their protocols require encryption. A commonly cited sufficient condition for the existence of unbreakable encryption is the existence of one-way functions, but it is conceivable that some physical means might also achieve it. On top of this, they also showed that the graph nonisomorphism problem, the complement of the graph isomorphism problem, has a zero-knowledge proof. This problem is in co-NP, but is not currently known to be in either NP or any practical class.",
      "char_count": 940,
      "token_estimate": 235,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0041",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 28538,
      "end_char": 29530,
      "content": "More generally, Russell Impagliazzo and Moti Yung as well as Ben-Or et al. would go on to show that, also assuming one-way functions or unbreakable encryption, there are zero-knowledge proofs for all problems in IP = PSPACE, or in other words, anything that can be proved by an interactive proof system can be proved with zero knowledge. Not liking to make unnecessary assumptions, many theorists sought a way to eliminate the necessity of one way functions. One way this was done was with multi-prover interactive proof systems (see interactive proof system), which have multiple independent provers instead of only one, allowing the verifier to \"cross-examine\" the provers in isolation to avoid being misled. It can be shown that, without any intractability assumptions, all languages in NP have zero-knowledge proofs in such a system. It turns out that, in an Internet-like setting, where multiple protocols may be executed concurrently, building zero-knowledge proofs is more challenging.",
      "char_count": 992,
      "token_estimate": 248,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0042",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 29531,
      "end_char": 30221,
      "content": "The line of research investigating concurrent zero-knowledge proofs was initiated by the work of Dwork, Naor, and Sahai. One particular development along these lines has been the development of witness-indistinguishable proof protocols. The property of witness-indistinguishability is related to that of zero-knowledge, yet witness-indistinguishable protocols do not suffer from the same problems of concurrent execution. Another variant of zero-knowledge proofs are non-interactive zero-knowledge proofs. Blum, Feldman, and Micali showed that a common random string shared between the prover and the verifier is enough to achieve computational zero-knowledge without requiring interaction.",
      "char_count": 690,
      "token_estimate": 172,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0043",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Zero-Knowledge Proof protocols ==",
      "heading_path": "== Zero-Knowledge Proof protocols ==",
      "start_char": 30245,
      "end_char": 31104,
      "content": "== Zero-Knowledge Proof protocols == The most popular interactive or non-interactive zero-knowledge proof (e.g., zk-SNARK) protocols can be broadly categorized in the following four categories: Succinct Non-Interactive ARguments of Knowledge (SNARK), Scalable Transparent ARgument of Knowledge (STARK), Verifiable Polynomial Delegation (VPD), and Succinct Non-interactive ARGuments (SNARG). A list of zero-knowledge proof protocols and libraries is provided below along with comparisons based on transparency, universality, plausible post-quantum security, and programming paradigm. A transparent protocol is one that does not require any trusted setup and uses public randomness. A universal protocol is one that does not require a separate trusted setup for each circuit. Finally, a plausibly post-quantum protocol is one that is not susceptible to known attacks involving quantum algorithms.",
      "char_count": 894,
      "token_estimate": 223,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0044",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Security vulnerabilities of zero-knowledge systems ==",
      "heading_path": "== Security vulnerabilities of zero-knowledge systems ==",
      "start_char": 31160,
      "end_char": 32052,
      "content": "== Security vulnerabilities of zero-knowledge systems == While zero-knowledge proofs offer a secure way to verify information, the arithmetic circuits that implement them must be carefully designed. If these circuits lack sufficient constraints, they may introduce subtle yet critical security vulnerabilities. One of the most common classes of vulnerabilities in these systems is under-constrained logic, where insufficient constraints allow a malicious prover to produce a proof for an incorrect statement that still passes verification. A 2024 systematization of known attacks found that approximately 96% of documented circuit-layer bugs in SNARK-based systems were due to under-constrained circuits. These vulnerabilities often arise during the translation of high-level logic into low-level constraint systems, particularly when using domain-specific languages such as Circom or Gnark.",
      "char_count": 891,
      "token_estimate": 222,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0045",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== Security vulnerabilities of zero-knowledge systems ==",
      "heading_path": "== Security vulnerabilities of zero-knowledge systems ==",
      "start_char": 32052,
      "end_char": 32249,
      "content": "Recent research has demonstrated that formally proving determinism – ensuring that a circuit's outputs are uniquely determined by its inputs – can eliminate entire classes of these vulnerabilities.",
      "char_count": 197,
      "token_estimate": 49,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0046",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== See also ==",
      "heading_path": "== See also ==",
      "start_char": 32208,
      "end_char": 32209,
      "content": "== See also ==",
      "char_count": 14,
      "token_estimate": 3,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0047",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== External links ==",
      "heading_path": "== External links ==",
      "start_char": 32229,
      "end_char": 32331,
      "content": "== External links == Computer scientist Amit Sahai explains the Zero-knowledge proof in 5 Levels of Difficulty on YouTube",
      "char_count": 121,
      "token_estimate": 30,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "zeroknowledgeproof_1c1efb23_c0048",
      "article_id": "zeroknowledgeproof_1c1efb23",
      "section": "== References ==",
      "heading_path": "== References ==",
      "start_char": 32347,
      "end_char": 32347,
      "content": "== References ==",
      "char_count": 16,
      "token_estimate": 4,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 10,
    "items": [
      {
        "question": "How can Peggy prove to Victor that she knows the magic word without revealing it to him in a single trial?",
        "answer": "If both Victor and Peggy go together to the mouth of the cave, Victor can watch Peggy go in through A and come out through B, which would prove with certainty that Peggy knows the magic word without revealing it to Victor.",
        "related_chunk_ids": [
          "zeroknowledgeproof_1c1efb23_c0010"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "Who showed that, assuming one-way functions or unbreakable encryption, there are zero-knowledge proofs for all problems in IP = PSPACE?",
        "answer": "Russell Impagliazzo and Moti Yung as well as Ben-Or et al.",
        "related_chunk_ids": [
          "zeroknowledgeproof_1c1efb23_c0041"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "Who are the researchers that showed it is possible to interactively prove that a number is a quadratic nonresidue mod m while releasing zero additional knowledge?",
        "answer": "Goldwasser, Micali, and Rackoff.",
        "related_chunk_ids": [
          "zeroknowledgeproof_1c1efb23_c0039"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What object does the prover use to hide the location of Wally in the 'Where's Wally' zero-knowledge proof example?",
        "answer": "A large black board with a small hole in it, the size of Wally.",
        "related_chunk_ids": [
          "zeroknowledgeproof_1c1efb23_c0005"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What value does Simon disclose if the coin flipping result is 'heads'?",
        "answer": "Simon picks a random value r, computes C = gr mod p, and discloses C as if it is a message from Peggy to Victor.",
        "related_chunk_ids": [
          "zeroknowledgeproof_1c1efb23_c0024"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What is the probability that Peggy would randomly succeed at identifying each switch or non-switch if the balls were the same colour?",
        "answer": "50%",
        "related_chunk_ids": [
          "zeroknowledgeproof_1c1efb23_c0013"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "How do zero-knowledge proofs ensure that a verifier is convinced of a statement's truth without learning any additional information, and what are the differences between interactive and noninteractive zero-knowledge proofs?",
        "answer": "Zero-knowledge proofs allow a prover to convince a verifier that a statement is true without revealing any information beyond the truth of the statement itself, ensuring that the verifier cannot use the proof to convince third parties or learn the underlying secret. These proofs can be interactive, requiring message exchanges between prover and verifier, or noninteractive, where a single message suffices. While interaction is generally required in the standard model, noninteractive zero-knowledge proofs are possible in the common random string and random oracle models, and certain interactive proofs can be transformed into noninteractive ones using the Fiat–Shamir heuristic.",
        "related_chunk_ids": [
          "zeroknowledgeproof_1c1efb23_c0000",
          "zeroknowledgeproof_1c1efb23_c0001"
        ],
        "category": "LONG_ANSWER"
      },
      {
        "question": "How does the red card proof serve as an example of a zero-knowledge proof, and what features ensure both the zero-knowledge property and soundness in this protocol?",
        "answer": "The red card proof is an example of a math-free, physical zero-knowledge proof where Peggy proves to Victor that she holds a red card without revealing which specific card it is. Peggy does this by showing Victor all 26 black cards from the remaining deck, so Victor knows her hidden card must be red. The zero-knowledge property is ensured because Victor learns only that the card is red, not its suit or rank, and even a recording of the interaction would not reveal the card's identity. Soundness is guaranteed because if Peggy were lying and held a black card, she would not be able to produce all 26 black cards from the rest of the deck, making deception impossible. This protocol is part of a broader class of card-based cryptographic protocols that use everyday objects for secure computations.",
        "related_chunk_ids": [
          "zeroknowledgeproof_1c1efb23_c0002",
          "zeroknowledgeproof_1c1efb23_c0003",
          "zeroknowledgeproof_1c1efb23_c0004"
        ],
        "category": "LONG_ANSWER"
      },
      {
        "question": "How do interactive and noninteractive zero-knowledge proofs differ, and what is the underlying challenge that zero-knowledge proofs address?",
        "answer": "Interactive zero-knowledge proofs require the prover and verifier to exchange messages according to a protocol, while noninteractive zero-knowledge proofs allow the verifier to be convinced by a single message from the prover without further communication. The underlying challenge that zero-knowledge proofs address is enabling the prover to convince the verifier of the truth of a statement without revealing any information beyond the fact that the statement is true, ensuring that the verifier cannot use the proof to convince third parties.",
        "related_chunk_ids": [
          "zeroknowledgeproof_1c1efb23_c0000",
          "zeroknowledgeproof_1c1efb23_c0001"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "How does the red card proof using playing cards demonstrate both the zero-knowledge and soundness properties of a proof system?",
        "answer": "The red card proof demonstrates the zero-knowledge property because Victor learns only that Peggy's card is red, without gaining any information about which specific red card it is, and even a recording of the interaction would not reveal the card's identity. It also demonstrates soundness because if Peggy were lying and actually held a black card, she would not be able to produce all 26 black cards from the remaining deck, making it impossible for her to deceive Victor. Thus, the proof ensures that only truthful claims can be successfully demonstrated while revealing no extra information.",
        "related_chunk_ids": [
          "zeroknowledgeproof_1c1efb23_c0003",
          "zeroknowledgeproof_1c1efb23_c0004"
        ],
        "category": "INTERPRETATION"
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-28T12:09:33.282Z",
    "content_format": "markdown",
    "total_chunks": 49,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}