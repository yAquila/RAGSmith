{
  "article": {
    "id": "continuationpassings_2631a065",
    "title": "Continuation-passing style",
    "url": "https://en.wikipedia.org/wiki/Continuation-passing_style",
    "lang": "en",
    "created_at": "2025-07-28T12:12:21.502491",
    "content": "---\nid: continuationpassings_2631a065\nurl: https://en.wikipedia.org/wiki/Continuation-passing_style\ntitle: Continuation-passing style\nlang: en\ncreated_at: '2025-07-28T12:09:45.702002'\nchecksum: 512f14954bee386f30608f59bec92a0359e0c282b561508ff111c8edd0f11c48\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gpt-4.1\nstats:\n  word_count: 1807\n  char_count: 11558\n  num_chunks: 16\n  num_sections: 0\n---\nIn functional programming, continuation-passing style (CPS) is a style of programming in which control is passed explicitly in the form of a continuation. This is contrasted with direct style, which is the usual style of programming. Gerald Jay Sussman and Guy L. Steele, Jr. coined the phrase in AI Memo 349 (1975), which sets out the first version of the programming language Scheme. John C. Reynolds gives a detailed account of the many discoveries of continuations. A function written in continuation-passing style takes an extra argument: an explicit continuation; i.e., a function of one argument. When the CPS function has computed its result value, it \"returns\" it by calling the continuation function with this value as the argument. That means that when invoking a CPS function, the calling function is required to supply a procedure to be invoked with the subroutine's \"return\" value. Expressing code in this form makes a number of things explicit which are implicit in direct style. These include: procedure returns, which become apparent as calls to a continuation; intermediate values, which are all given names; order of argument evaluation, which is made explicit; and tail calls, which simply call a procedure with the same continuation, unmodified, that was passed to the caller. Programs can be automatically transformed from direct style to CPS. Functional and logic compilers often use CPS as an intermediate representation where a compiler for an imperative or procedural programming language would use static single assignment form (SSA). SSA is formally equivalent to a subset of CPS (excluding non-local control flow, which does not occur when CPS is used as intermediate representation). Functional compilers can also use A-normal form (ANF) (but only for languages requiring eager evaluation), rather than with thunks (described in the examples below) in CPS. CPS is used more frequently by compilers than by programmers as a local or global style. == Examples == In CPS, each procedure takes an extra argument representing what should be done with the result the function is calculating. This, along with a restrictive style prohibiting a variety of constructs usually available, is used to expose the semantics of programs, making them easier to analyze. This style also makes it easy to express unusual control structures, like catch/throw or other non-local transfers of control. The key to CPS is to remember that (a) every function takes an extra argument known as its continuation, and (b) every argument in a function call must be either a variable or a lambda expression (not a more complex expression). This has the effect of turning expressions \"inside-out\" because the innermost parts of the expression must be evaluated first, thus CPS makes explicit the order of evaluation as well as the control flow. Some examples of code in direct style and the corresponding CPS appear below. These examples are written in the programming language Scheme; by convention the continuation function is represented as a parameter named \"k\": In the CPS versions, the primitives used, like +& and *& are themselves CPS, not direct style, so to make the above examples work in a Scheme system requires writing these CPS versions of primitives, with for instance *& defined by: To do this in general, we might write a conversion routine: To call a procedure written in CPS from a procedure written in direct style, it is necessary to provide a continuation that will receive the result computed by the CPS procedure. In the example above (assuming that CPS primitives have been provided), we might call (factorial& 10 (lambda (x) (display x) (newline))). There is some variety between compilers in the way primitive functions are provided in CPS. Above is used the simplest convention, however sometimes Boolean primitives are provided that take two thunks to be called in the two possible cases, so the (=& n 0 (lambda (b) (if b ...))) call inside f-aux& definition above would be written instead as (=& n 0 (lambda () (k a)) (lambda () (-& n 1 ...))). Similarly, sometimes the if primitive is not included in CPS, and instead a function if& is provided which takes three arguments: a Boolean condition and the two thunks corresponding to the two arms of the conditional. The translations shown above show that CPS is a global transformation. The direct-style factorial takes, as might be expected, a single argument; the CPS factorial& takes two: the argument and a continuation. Any function calling a CPS-ed function must either provide a new continuation or pass its own; any calls from a CPS-ed function to a non-CPS function will use implicit continuations. Thus, to ensure the total absence of a function stack, the entire program must be in CPS. === CPS in Haskell === A function pyth to calculate a hypotenuse using the Pythagorean theorem can be written in Haskell. A traditional implementation of the pyth function looks like this: To transform the traditional function to CPS, its signature must be changed. The function will get another argument of function type, and its return type depends on that function: First we calculate the square of a in pyth' function and pass a lambda function as a continuation which will accept a square of a as a first argument. And so on until the result of the calculations are reached. To get the result of this function we can pass id function as a final argument which returns the value that was passed to it unchanged: pyth' 3 4 id == 5.0. The mtl library, which is shipped with Glasgow Haskell Compiler (GHC), has the module Control.Monad.Cont. This module provides the Cont type, which implements Monad and some other useful functions. The following snippet shows the pyth' function using Cont: Not only has the syntax become cleaner, but this type allows us to use a function callCC with type MonadCont m => ((a -> m b) -> m a) -> m a. This function has one argument of a function type; that function argument accepts the function too, which discards all computations going after its call. For example, let's break the execution of the pyth function if at least one of its arguments is negative returning zero: === Continuations as objects === Programming with continuations can also be useful when a caller does not want to wait until the callee completes. For example, in user interface (UI) programming, a routine can set up dialog box fields and pass these, along with a continuation function, to the UI framework. This call returns right away, allowing the application code to continue while the user interacts with the dialog box. Once the user presses the \"OK\" button, the framework calls the continuation function with the updated fields. Although this style of coding uses continuations, it is not full CPS. A similar idea can be used when the function must run in a different thread or on a different processor. The framework can execute the called function in a worker thread, then call the continuation function in the original thread with the worker's results. This is in Java 8 using the Swing UI framework: == Tail calls == Every call in CPS is a tail call, and the continuation is explicitly passed. Using CPS without tail call optimization (TCO) will cause both the constructed continuation to potentially grow during recursion, and the call stack. This is usually undesirable, but has been used in interesting ways; see the Chicken Scheme compiler. As CPS and TCO eliminate the concept of an implicit function return, their combined use can eliminate the need for a run-time stack. Several compilers and interpreters for functional programming languages use this ability in novel ways. == Use and implementation == Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. == Use in other fields == Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example. Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). == See also == Tail recursion through trampolining == Notes == == References == Continuation Passing C (CPC) - programming language for writing concurrent systems, designed and developed by Juliusz Chroboczek and Gabriel Kerneis. github repository The construction of a CPS-based compiler for ML is described in: Appel, Andrew W. (1992). Compiling with Continuations. Cambridge University Press. ISBN 978-0-521-41695-5. Danvy, Olivier; Filinski, Andrzej (1992). \"Representing Control, A Study of the CPS Transformation\". Mathematical Structures in Computer Science. 2 (4): 361–391. CiteSeerX 10.1.1.46.84. doi:10.1017/S0960129500001535. S2CID 8790522. Chicken Scheme compiler, a Scheme to C compiler that uses continuation-passing style for translating Scheme procedures into C functions while using the C-stack as the nursery for the generational garbage collector Kelsey, Richard A. (March 1995). \"A Correspondence between Continuation Passing Style and Static Single Assignment Form\". ACM SIGPLAN Notices. 30 (3): 13–22. CiteSeerX 10.1.1.3.6773. doi:10.1145/202530.202532. Appel, Andrew W. (April 1998). \"SSA is Functional Programming\". ACM SIGPLAN Notices. 33 (4): 17–20. CiteSeerX 10.1.1.34.3282. doi:10.1145/278283.278285. S2CID 207227209. Danvy, Olivier; Millikin, Kevin; Nielsen, Lasse R. (2007). \"On One-Pass CPS Transformations\". BRICS Report Series: 24. ISSN 0909-0878. RS-07-6. Retrieved 26 October 2007. Dybvig, R. Kent (2003). The Scheme Programming Language. Prentice Hall. p. 64. Direct link: \"Section 3.4. Continuation Passing Style\"."
  },
  "chunks": [
    {
      "id": "continuationpassings_2631a065_c0000",
      "article_id": "continuationpassings_2631a065",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 896,
      "content": "In functional programming, continuation-passing style (CPS) is a style of programming in which control is passed explicitly in the form of a continuation. This is contrasted with direct style, which is the usual style of programming. Gerald Jay Sussman and Guy L. Steele, Jr. coined the phrase in AI Memo 349 (1975), which sets out the first version of the programming language Scheme. John C. Reynolds gives a detailed account of the many discoveries of continuations. A function written in continuation-passing style takes an extra argument: an explicit continuation; i.e., a function of one argument. When the CPS function has computed its result value, it \"returns\" it by calling the continuation function with this value as the argument. That means that when invoking a CPS function, the calling function is required to supply a procedure to be invoked with the subroutine's \"return\" value.",
      "char_count": 895,
      "token_estimate": 223,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0001",
      "article_id": "continuationpassings_2631a065",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 896,
      "end_char": 1886,
      "content": "Expressing code in this form makes a number of things explicit which are implicit in direct style. These include: procedure returns, which become apparent as calls to a continuation; intermediate values, which are all given names; order of argument evaluation, which is made explicit; and tail calls, which simply call a procedure with the same continuation, unmodified, that was passed to the caller. Programs can be automatically transformed from direct style to CPS. Functional and logic compilers often use CPS as an intermediate representation where a compiler for an imperative or procedural programming language would use static single assignment form (SSA). SSA is formally equivalent to a subset of CPS (excluding non-local control flow, which does not occur when CPS is used as intermediate representation). Functional compilers can also use A-normal form (ANF) (but only for languages requiring eager evaluation), rather than with thunks (described in the examples below) in CPS.",
      "char_count": 990,
      "token_estimate": 247,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0002",
      "article_id": "continuationpassings_2631a065",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 1887,
      "end_char": 1975,
      "content": "CPS is used more frequently by compilers than by programmers as a local or global style.",
      "char_count": 88,
      "token_estimate": 22,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0003",
      "article_id": "continuationpassings_2631a065",
      "section": "== Examples ==",
      "heading_path": "== Examples ==",
      "start_char": 1990,
      "end_char": 2936,
      "content": "== Examples == In CPS, each procedure takes an extra argument representing what should be done with the result the function is calculating. This, along with a restrictive style prohibiting a variety of constructs usually available, is used to expose the semantics of programs, making them easier to analyze. This style also makes it easy to express unusual control structures, like catch/throw or other non-local transfers of control. The key to CPS is to remember that (a) every function takes an extra argument known as its continuation, and (b) every argument in a function call must be either a variable or a lambda expression (not a more complex expression). This has the effect of turning expressions \"inside-out\" because the innermost parts of the expression must be evaluated first, thus CPS makes explicit the order of evaluation as well as the control flow. Some examples of code in direct style and the corresponding CPS appear below.",
      "char_count": 945,
      "token_estimate": 236,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0004",
      "article_id": "continuationpassings_2631a065",
      "section": "== Examples ==",
      "heading_path": "== Examples ==",
      "start_char": 2936,
      "end_char": 3781,
      "content": "These examples are written in the programming language Scheme; by convention the continuation function is represented as a parameter named \"k\": In the CPS versions, the primitives used, like +& and *& are themselves CPS, not direct style, so to make the above examples work in a Scheme system requires writing these CPS versions of primitives, with for instance *& defined by: To do this in general, we might write a conversion routine: To call a procedure written in CPS from a procedure written in direct style, it is necessary to provide a continuation that will receive the result computed by the CPS procedure. In the example above (assuming that CPS primitives have been provided), we might call (factorial& 10 (lambda (x) (display x) (newline))). There is some variety between compilers in the way primitive functions are provided in CPS.",
      "char_count": 845,
      "token_estimate": 211,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0005",
      "article_id": "continuationpassings_2631a065",
      "section": "== Examples ==",
      "heading_path": "== Examples ==",
      "start_char": 3782,
      "end_char": 4699,
      "content": "Above is used the simplest convention, however sometimes Boolean primitives are provided that take two thunks to be called in the two possible cases, so the (=& n 0 (lambda (b) (if b ...))) call inside f-aux& definition above would be written instead as (=& n 0 (lambda () (k a)) (lambda () (-& n 1 ...))). Similarly, sometimes the if primitive is not included in CPS, and instead a function if& is provided which takes three arguments: a Boolean condition and the two thunks corresponding to the two arms of the conditional. The translations shown above show that CPS is a global transformation. The direct-style factorial takes, as might be expected, a single argument; the CPS factorial& takes two: the argument and a continuation. Any function calling a CPS-ed function must either provide a new continuation or pass its own; any calls from a CPS-ed function to a non-CPS function will use implicit continuations.",
      "char_count": 917,
      "token_estimate": 229,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0006",
      "article_id": "continuationpassings_2631a065",
      "section": "== Examples ==",
      "heading_path": "== Examples ==",
      "start_char": 4700,
      "end_char": 4789,
      "content": "Thus, to ensure the total absence of a function stack, the entire program must be in CPS.",
      "char_count": 89,
      "token_estimate": 22,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0007",
      "article_id": "continuationpassings_2631a065",
      "section": "== = CPS in Haskell ==",
      "heading_path": "== = CPS in Haskell ==",
      "start_char": 4798,
      "end_char": 5506,
      "content": "== = CPS in Haskell === A function pyth to calculate a hypotenuse using the Pythagorean theorem can be written in Haskell. A traditional implementation of the pyth function looks like this: To transform the traditional function to CPS, its signature must be changed. The function will get another argument of function type, and its return type depends on that function: First we calculate the square of a in pyth' function and pass a lambda function as a continuation which will accept a square of a as a first argument. And so on until the result of the calculations are reached. To get the result of this function we can pass id function as a final argument which returns the value that was passed to it unchanged: pyth' 3 4 id",
      "char_count": 729,
      "token_estimate": 182,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0008",
      "article_id": "continuationpassings_2631a065",
      "section": "== 5.0. The mtl library, which is shipped with Glasgow Haskell Compiler (GHC), has the module Control.Monad.Cont. This module provides the Cont type, which implements Monad and some other useful functions. The following snippet shows the pyth' function using Cont: Not only has the syntax become cleaner, but this type allows us to use a function callCC with type MonadCont m => ((a -> m b) -> m a) -> m a. This function has one argument of a function type; that function argument accepts the function too, which discards all computations going after its call. For example, let's break the execution of the pyth function if at least one of its arguments is negative returning zero: ==",
      "heading_path": "== 5.0. The mtl library, which is shipped with Glasgow Haskell Compiler (GHC), has the module Control.Monad.Cont. This module provides the Cont type, which implements Monad and some other useful functions. The following snippet shows the pyth' function using Cont: Not only has the syntax become cleaner, but this type allows us to use a function callCC with type MonadCont m => ((a -> m b) -> m a) -> m a. This function has one argument of a function type; that function argument accepts the function too, which discards all computations going after its call. For example, let's break the execution of the pyth function if at least one of its arguments is negative returning zero: ==",
      "start_char": 6190,
      "end_char": 6217,
      "content": "== 5.0. The mtl library, which is shipped with Glasgow Haskell Compiler (GHC), has the module Control.Monad.Cont. This module provides the Cont type, which implements Monad and some other useful functions. The following snippet shows the pyth' function using Cont: Not only has the syntax become cleaner, but this type allows us to use a function callCC with type MonadCont m => ((a -> m b) -> m a) -> m a. This function has one argument of a function type; that function argument accepts the function too, which discards all computations going after its call. For example, let's break the execution of the pyth function if at least one of its arguments is negative returning zero: === Continuations as objects",
      "char_count": 710,
      "token_estimate": 177,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0009",
      "article_id": "continuationpassings_2631a065",
      "section": "== = Programming with continuations can also be useful when a caller does not want to wait until the callee completes. For example, in user interface (UI) programming, a routine can set up dialog box fields and pass these, along with a continuation function, to the UI framework. This call returns right away, allowing the application code to continue while the user interacts with the dialog box. Once the user presses the \"OK\" button, the framework calls the continuation function with the updated fields. Although this style of coding uses continuations, it is not full CPS. A similar idea can be used when the function must run in a different thread or on a different processor. The framework can execute the called function in a worker thread, then call the continuation function in the original thread with the worker's results. This is in Java 8 using the Swing UI framework: ==",
      "heading_path": "== = Programming with continuations can also be useful when a caller does not want to wait until the callee completes. For example, in user interface (UI) programming, a routine can set up dialog box fields and pass these, along with a continuation function, to the UI framework. This call returns right away, allowing the application code to continue while the user interacts with the dialog box. Once the user presses the \"OK\" button, the framework calls the continuation function with the updated fields. Although this style of coding uses continuations, it is not full CPS. A similar idea can be used when the function must run in a different thread or on a different processor. The framework can execute the called function in a worker thread, then call the continuation function in the original thread with the worker's results. This is in Java 8 using the Swing UI framework: ==",
      "start_char": 7102,
      "end_char": 7114,
      "content": "== = Programming with continuations can also be useful when a caller does not want to wait until the callee completes. For example, in user interface (UI) programming, a routine can set up dialog box fields and pass these, along with a continuation function, to the UI framework. This call returns right away, allowing the application code to continue while the user interacts with the dialog box. Once the user presses the \"OK\" button, the framework calls the continuation function with the updated fields. Although this style of coding uses continuations, it is not full CPS. A similar idea can be used when the function must run in a different thread or on a different processor. The framework can execute the called function in a worker thread, then call the continuation function in the original thread with the worker's results. This is in Java 8 using the Swing UI framework: == Tail calls",
      "char_count": 896,
      "token_estimate": 224,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0010",
      "article_id": "continuationpassings_2631a065",
      "section": "== Every call in CPS is a tail call, and the continuation is explicitly passed. Using CPS without tail call optimization (TCO) will cause both the constructed continuation to potentially grow during recursion, and the call stack. This is usually undesirable, but has been used in interesting ways; see the Chicken Scheme compiler. As CPS and TCO eliminate the concept of an implicit function return, their combined use can eliminate the need for a run-time stack. Several compilers and interpreters for functional programming languages use this ability in novel ways. ==",
      "heading_path": "== Every call in CPS is a tail call, and the continuation is explicitly passed. Using CPS without tail call optimization (TCO) will cause both the constructed continuation to potentially grow during recursion, and the call stack. This is usually undesirable, but has been used in interesting ways; see the Chicken Scheme compiler. As CPS and TCO eliminate the concept of an implicit function return, their combined use can eliminate the need for a run-time stack. Several compilers and interpreters for functional programming languages use this ability in novel ways. ==",
      "start_char": 7684,
      "end_char": 7708,
      "content": "== Every call in CPS is a tail call, and the continuation is explicitly passed. Using CPS without tail call optimization (TCO) will cause both the constructed continuation to potentially grow during recursion, and the call stack. This is usually undesirable, but has been used in interesting ways; see the Chicken Scheme compiler. As CPS and TCO eliminate the concept of an implicit function return, their combined use can eliminate the need for a run-time stack. Several compilers and interpreters for functional programming languages use this ability in novel ways. == Use and implementation",
      "char_count": 593,
      "token_estimate": 148,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0011",
      "article_id": "continuationpassings_2631a065",
      "section": "== Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. ==",
      "heading_path": "== Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. ==",
      "start_char": 8828,
      "end_char": 9698,
      "content": "== Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation.",
      "char_count": 869,
      "token_estimate": 217,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0012",
      "article_id": "continuationpassings_2631a065",
      "section": "== Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. ==",
      "heading_path": "== Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. ==",
      "start_char": 9698,
      "end_char": 9968,
      "content": "Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. == Use in other fields",
      "char_count": 270,
      "token_estimate": 67,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0013",
      "article_id": "continuationpassings_2631a065",
      "section": "== Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example. Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). ==",
      "heading_path": "== Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example. Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). ==",
      "start_char": 10011,
      "end_char": 10939,
      "content": "== Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example.",
      "char_count": 927,
      "token_estimate": 231,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0014",
      "article_id": "continuationpassings_2631a065",
      "section": "== Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example. Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). ==",
      "heading_path": "== Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example. Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). ==",
      "start_char": 10939,
      "end_char": 11182,
      "content": "Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). == See also",
      "char_count": 243,
      "token_estimate": 60,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_2631a065_c0015",
      "article_id": "continuationpassings_2631a065",
      "section": "== Tail recursion through trampolining ==",
      "heading_path": "== Tail recursion through trampolining ==",
      "start_char": 10062,
      "end_char": 10069,
      "content": "== Tail recursion through trampolining == Notes",
      "char_count": 47,
      "token_estimate": 11,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 10,
    "items": [
      {
        "question": "What are some things that become explicit when code is expressed in continuation-passing style (CPS) rather than direct style?",
        "answer": "When code is expressed in continuation-passing style (CPS), procedure returns become apparent as calls to a continuation, intermediate values are all given names, the order of argument evaluation is made explicit, and tail calls simply call a procedure with the same continuation, unmodified, that was passed to the caller.",
        "related_chunk_ids": [
          "continuationpassings_2631a065_c0001"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What is the extra argument that each procedure takes in Continuation-Passing Style (CPS)?",
        "answer": "Each procedure in CPS takes an extra argument known as its continuation.",
        "related_chunk_ids": [
          "continuationpassings_2631a065_c0003"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "Who suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language?",
        "answer": "Chris Barker and his collaborators.",
        "related_chunk_ids": [
          "continuationpassings_2631a065_c0013"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "In user interface programming, what happens after the user presses the 'OK' button in a dialog box when using continuations?",
        "answer": "The framework calls the continuation function with the updated fields.",
        "related_chunk_ids": [
          "continuationpassings_2631a065_c0009"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What information is provided about == Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. ==?",
        "answer": "The text provides information about == Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. == as described in the relevant chunks.",
        "related_chunk_ids": [
          "continuationpassings_2631a065_c0011"
        ],
        "category": "LONG_ANSWER"
      },
      {
        "question": "What function can be passed as the final argument to the CPS-transformed pyth' function in Haskell to obtain the result unchanged?",
        "answer": "The id function can be passed as the final argument to the CPS-transformed pyth' function to obtain the result unchanged.",
        "related_chunk_ids": [
          "continuationpassings_2631a065_c0007"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "How does continuation-passing style (CPS) make certain aspects of program execution more explicit compared to direct style, and what role does CPS play in the compilation process of functional languages?",
        "answer": "Continuation-passing style (CPS) makes aspects such as procedure returns, intermediate values, order of argument evaluation, and tail calls more explicit compared to direct style by representing them directly in the code structure. In CPS, procedure returns are explicit calls to a continuation, intermediate values are named, argument evaluation order is clear, and tail calls are represented as calls with the same continuation. Additionally, CPS is used as an intermediate representation in functional and logic compilers, similar to how static single assignment form (SSA) is used in imperative language compilers, making control flow and data dependencies explicit for optimization and code generation.",
        "related_chunk_ids": [
          "continuationpassings_2631a065_c0000",
          "continuationpassings_2631a065_c0001"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "How does the use of continuation-passing style (CPS) by compilers relate to its features and the way it is implemented in programming languages like Scheme?",
        "answer": "Continuation-passing style (CPS) is used more frequently by compilers than by programmers because its features—such as making control flow and order of evaluation explicit—facilitate program analysis and optimization. In CPS, each function takes an extra argument (the continuation) that represents what should be done with the result, and this style prohibits certain constructs to expose program semantics. In languages like Scheme, implementing CPS requires rewriting primitives and providing continuations explicitly, which can be complex for programmers but is manageable and beneficial for compilers aiming to analyze or transform code.",
        "related_chunk_ids": [
          "continuationpassings_2631a065_c0002",
          "continuationpassings_2631a065_c0003",
          "continuationpassings_2631a065_c0004"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "How is continuation-passing style (CPS) used differently by compilers compared to programmers, and what advantages does expressing code in CPS provide for compiler implementation?",
        "answer": "Continuation-passing style (CPS) is used more frequently by compilers than by programmers, either as a local or global style. Expressing code in CPS makes several aspects explicit that are implicit in direct style, such as procedure returns, intermediate values, order of argument evaluation, and tail calls. These explicit representations are advantageous for compilers, as CPS can serve as an intermediate representation, making program transformations and optimizations easier. Functional and logic compilers often use CPS in this way, whereas programmers typically use direct style.",
        "related_chunk_ids": [
          "continuationpassings_2631a065_c0000",
          "continuationpassings_2631a065_c0001",
          "continuationpassings_2631a065_c0002"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "How does the use of continuations in CPS affect the structure and execution of programs, and what are the implications for calling conventions and the function stack?",
        "answer": "In CPS (Continuation-Passing Style), every function takes an extra argument called a continuation, which represents what should be done with the result. This approach turns expressions 'inside-out,' making the order of evaluation and control flow explicit. To call a CPS function from direct style, a continuation must be provided to receive the result. Additionally, all primitives and control structures must be adapted to CPS, sometimes requiring special handling for conditionals and Boolean operations. Because any function calling a CPS-ed function must provide or pass a continuation, and to ensure the total absence of a function stack, the entire program must be written in CPS. This fundamentally changes calling conventions and eliminates the traditional function stack by making control flow explicit through continuations.",
        "related_chunk_ids": [
          "continuationpassings_2631a065_c0003",
          "continuationpassings_2631a065_c0004",
          "continuationpassings_2631a065_c0005",
          "continuationpassings_2631a065_c0006"
        ],
        "category": "INTERPRETATION"
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-28T12:09:33.530Z",
    "content_format": "markdown",
    "total_chunks": 16,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}