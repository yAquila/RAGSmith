{
  "article": {
    "id": "modulararithmetic_9689c945",
    "title": "Modular arithmetic",
    "url": "https://en.wikipedia.org/wiki/Modular_arithmetic",
    "lang": "en",
    "created_at": "2025-07-31T06:32:40.803530",
    "content": "---\nid: modulararithmetic_9689c945\nurl: https://en.wikipedia.org/wiki/Modular_arithmetic\ntitle: Modular arithmetic\nlang: en\ncreated_at: '2025-07-31T06:26:24.347576'\nchecksum: 643a25ff326e9800aee4626ac4c3b051846f3323efbd00d1d8fe283b04a4d065\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 3568\n  char_count: 19498\n  num_chunks: 25\n  original_chunks: 31\n  filtered_out: 6\n  num_sections: 0\n---\nIn mathematics, modular arithmetic is a system of arithmetic operations for integers, other than the usual ones from elementary arithmetic, where numbers \"wrap around\" when reaching a certain value, called the modulus. The modern approach to modular arithmetic was developed by Carl Friedrich Gauss in his book Disquisitiones Arithmeticae, published in 1801. A familiar example of modular arithmetic is the hour hand on a 12-hour clock. If the hour hand points to 7 now, then 8 hours later it will point to 3. Ordinary addition would result in 7 + 8 = 15, but 15 reads as 3 on the clock face. This is because the hour hand makes one rotation every 12 hours and the hour number starts over when the hour hand passes 12. We say that 15 is congruent to 3 modulo 12, written 15 ≡ 3 (mod 12), so that 7 + 8 ≡ 3 (mod 12). Similarly, if one starts at 12 and waits 8 hours, the hour hand will be at 8. If one instead waited twice as long, 16 hours, the hour hand would be on 4. This can be written as 2 × 8 ≡ 4 (mod 12). Note that after a wait of exactly 12 hours, the hour hand will always be right where it was before, so 12 acts the same as zero, thus 12 ≡ 0 (mod 12). == Congruence == Given an integer m ≥ 1, called a modulus, two integers a and b are said to be congruent modulo m, if m is a divisor of their difference; that is, if there is an integer k such that a − b = k m. Congruence modulo m is a congruence relation, meaning that it is an equivalence relation that is compatible with addition, subtraction, and multiplication. Congruence modulo m is denoted by a ≡ b (mod m). The parentheses mean that (mod m) applies to the entire equation, not just to the right-hand side (here, b). This notation is not to be confused with the notation b mod m (without parentheses), which refers to the remainder of b when divided by m, known as the modulo operation: that is, b mod m denotes the unique integer r such that 0 ≤ r < m and r ≡ b (mod m). The congruence relation may be rewritten as a = k m + b, explicitly showing its relationship with Euclidean division. However, the b here need not be the remainder in the division of a by m. Rather, a ≡ b (mod m) asserts that a and b have the same remainder when divided by m. That is, a = p m + r, b = q m + r, where 0 ≤ r < m is the common remainder. We recover the previous relation (a − b = k m) by subtracting these two expressions and setting k = p − q. Because the congruence modulo m is defined by the divisibility by m and because −1 is a unit in the ring of integers, a number is divisible by −m exactly if it is divisible by m. This means that every non-zero integer m may be taken as modulus. === Examples === In modulus 12, one can assert that: 38 ≡ 14 (mod 12) because the difference is 38 − 14 = 24 = 2 × 12, a multiple of 12. Equivalently, 38 and 14 have the same remainder 2 when divided by 12. The definition of congruence also applies to negative values. For example: 2 ≡ − 3 ( mod 5 ) − 8 ≡ + 7 ( mod 5 ) − 3 ≡ − 8 ( mod 5 ) . {\\displaystyle {\\begin{aligned}2&\\equiv -3{\\pmod {5}}\\\\-8&\\equiv {\\phantom {+}}7{\\pmod {5}}\\\\-3&\\equiv -8{\\pmod {5}}.\\end{aligned}}} == Basic properties == The congruence relation satisfies all the conditions of an equivalence relation: Reflexivity: a ≡ a (mod m) Symmetry: a ≡ b (mod m) if b ≡ a (mod m). Transitivity: If a ≡ b (mod m) and b ≡ c (mod m), then a ≡ c (mod m) If a1 ≡ b1 (mod m) and a2 ≡ b2 (mod m), or if a ≡ b (mod m), then: a + k ≡ b + k (mod m) for any integer k (compatibility with translation) k a ≡ k b (mod m) for any integer k (compatibility with scaling) k a ≡ k b (mod k m) for any integer k a1 + a2 ≡ b1 + b2 (mod m) (compatibility with addition) a1 − a2 ≡ b1 − b2 (mod m) (compatibility with subtraction) a1 a2 ≡ b1 b2 (mod m) (compatibility with multiplication) ak ≡ bk (mod m) for any non-negative integer k (compatibility with exponentiation) p(a) ≡ p(b) (mod m), for any polynomial p(x) with integer coefficients (compatibility with polynomial evaluation) If a ≡ b (mod m), then it is generally false that ka ≡ kb (mod m). However, the following is true: If c ≡ d (mod φ(m)), where φ is Euler's totient function, then ac ≡ ad (mod m)—provided that a is coprime with m. For cancellation of common terms, we have the following rules: If a + k ≡ b + k (mod m), where k is any integer, then a ≡ b (mod m). If k a ≡ k b (mod m) and k is coprime with m, then a ≡ b (mod m). If k a ≡ k b (mod k m) and k ≠ 0, then a ≡ b (mod m). The last rule can be used to move modular arithmetic into division. If b divides a, then (a/b) mod m = (a mod b m) / b. The modular multiplicative inverse is defined by the following rules: Existence: There exists an integer denoted a−1 such that aa−1 ≡ 1 (mod m) if and only if a is coprime with m. This integer a−1 is called a modular multiplicative inverse of a modulo m. If a ≡ b (mod m) and a−1 exists, then a−1 ≡ b−1 (mod m) (compatibility with multiplicative inverse, and, if a = b, uniqueness modulo m). If ax ≡ b (mod m) and a is coprime to m, then the solution to this linear congruence is given by x ≡ a−1b (mod m). The multiplicative inverse x ≡ a−1 (mod m) may be efficiently computed by solving Bézout's equation a x + m y = 1 for x, y, by using the Extended Euclidean algorithm. In particular, if p is a prime number, then a is coprime with p for every a such that 0 < a < p; thus a multiplicative inverse exists for all a that is not congruent to zero modulo p. == Advanced properties == Some of the more advanced properties of congruence relations are the following: Fermat's little theorem: If p is prime and does not divide a, then ap−1 ≡ 1 (mod p). Euler's theorem: If a and m are coprime, then aφ(m) ≡ 1 (mod m), where φ is Euler's totient function. A simple consequence of Fermat's little theorem is that if p is prime, then a−1 ≡ ap−2 (mod p) is the multiplicative inverse of 0 < a < p. More generally, from Euler's theorem, if a and m are coprime, then a−1 ≡ aφ(m)−1 (mod m). Hence, if ax ≡ 1 (mod m), then x ≡ aφ(m)−1 (mod m). Another simple consequence is that if a ≡ b (mod φ(m)), where φ is Euler's totient function, then ka ≡ kb (mod m) provided k is coprime with m. Wilson's theorem: p is prime if and only if (p − 1)! ≡ −1 (mod p). Chinese remainder theorem: For any a, b and coprime m, n, there exists a unique x (mod mn) such that x ≡ a (mod m) and x ≡ b (mod n). In fact, x ≡ b mn−1 m + a nm−1 n (mod mn) where mn−1 is the inverse of m modulo n and nm−1 is the inverse of n modulo m. Lagrange's theorem: If p is prime and f (x) = a0 xd + ... + ad is a polynomial with integer coefficients such that p is not a divisor of a0, then the congruence f (x) ≡ 0 (mod p) has at most d non-congruent solutions. Primitive root modulo m: A number g is a primitive root modulo m if, for every integer a coprime to m, there is an integer k such that gk ≡ a (mod m). A primitive root modulo m exists if and only if m is equal to 2, 4, pk or 2pk, where p is an odd prime number and k is a positive integer. If a primitive root modulo m exists, then there are exactly φ(φ(m)) such primitive roots, where φ is the Euler's totient function. Quadratic residue: An integer a is a quadratic residue modulo m, if there exists an integer x such that x2 ≡ a (mod m). Euler's criterion asserts that, if p is an odd prime, and a is not a multiple of p, then a is a quadratic residue modulo p if and only if a(p−1)/2 ≡ 1 (mod p). == Congruence classes == The congruence relation is an equivalence relation. The equivalence class modulo m of an integer a is the set of all integers of the form a + k m, where k is any integer. It is called the congruence class or residue class of a modulo m, and may be denoted (a mod m), or as a or [a] when the modulus m is known from the context. Each residue class modulo m contains exactly one integer in the range 0 , . . . , | m | − 1 {\\displaystyle 0,...,|m|-1} . Thus, these | m | {\\displaystyle |m|} integers are representatives of their respective residue classes. It is generally easier to work with integers than sets of integers; that is, the representatives most often considered, rather than their residue classes. Consequently, (a mod m) denotes generally the unique integer r such that 0 ≤ r < m and r ≡ a (mod m); it is called the residue of a modulo m. In particular, (a mod m) = (b mod m) is equivalent to a ≡ b (mod m), and this explains why \"=\" is often used instead of \"≡\" in this context. == Residue systems == Each residue class modulo m may be represented by any one of its members, although we usually represent each residue class by the smallest nonnegative integer which belongs to that class (since this is the proper remainder which results from division). Any two members of different residue classes modulo m are incongruent modulo m. Furthermore, every integer belongs to one and only one residue class modulo m. The set of integers {0, 1, 2, ..., m − 1} is called the least residue system modulo m. Any set of m integers, no two of which are congruent modulo m, is called a complete residue system modulo m. The least residue system is a complete residue system, and a complete residue system is simply a set containing precisely one representative of each residue class modulo m. For example, the least residue system modulo 4 is {0, 1, 2, 3}. Some other complete residue systems modulo 4 include: {1, 2, 3, 4} {13, 14, 15, 16} {−2, −1, 0, 1} {−13, 4, 17, 18} {−5, 0, 6, 21} {27, 32, 37, 42} Some sets that are not complete residue systems modulo 4 are: {−5, 0, 6, 22}, since 6 is congruent to 22 modulo 4. {5, 15}, since a complete residue system modulo 4 must have exactly 4 incongruent residue classes. === Reduced residue systems === Given the Euler's totient function φ(m), any set of φ(m) integers that are relatively prime to m and mutually incongruent under modulus m is called a reduced residue system modulo m. The set {5, 15} from above, for example, is an instance of a reduced residue system modulo 4. === Covering systems === Covering systems represent yet another type of residue system that may contain residues with varying moduli. == Integers modulo m == In the context of this paragraph, the modulus m is almost always taken as positive. The set of all congruence classes modulo m is a ring called the ring of integers modulo m, and is denoted Z / m Z {\\textstyle \\mathbb {Z} /m\\mathbb {Z} } , Z / m {\\displaystyle \\mathbb {Z} /m} , or Z m {\\displaystyle \\mathbb {Z} _{m}} . The ring Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is fundamental to various branches of mathematics (see § Applications below). (In some parts of number theory the notation Z m {\\displaystyle \\mathbb {Z} _{m}} is avoided because it can be confused with the set of m-adic integers.) For m > 0 one has Z / m Z = { a ¯ m ∣ a ∈ Z } = { 0 ¯ m , 1 ¯ m , 2 ¯ m , … , m − 1 ¯ m } . {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} =\\left\\{{\\overline {a}}_{m}\\mid a\\in \\mathbb {Z} \\right\\}=\\left\\{{\\overline {0}}_{m},{\\overline {1}}_{m},{\\overline {2}}_{m},\\ldots ,{\\overline {m{-}1}}_{m}\\right\\}.} When m = 1, Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is the zero ring; when m = 0, Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is not an empty set; rather, it is isomorphic to Z {\\displaystyle \\mathbb {Z} } , since a0 = {a}. Addition, subtraction, and multiplication are defined on Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } by the following rules: a ¯ m + b ¯ m = ( a + b ) ¯ m {\\displaystyle {\\overline {a}}_{m}+{\\overline {b}}_{m}={\\overline {(a+b)}}_{m}} a ¯ m − b ¯ m = ( a − b ) ¯ m {\\displaystyle {\\overline {a}}_{m}-{\\overline {b}}_{m}={\\overline {(a-b)}}_{m}} a ¯ m b ¯ m = ( a b ) ¯ m . {\\displaystyle {\\overline {a}}_{m}{\\overline {b}}_{m}={\\overline {(ab)}}_{m}.} The properties given before imply that, with these operations, Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is a commutative ring. For example, in the ring Z / 24 Z {\\displaystyle \\mathbb {Z} /24\\mathbb {Z} } , one has 12 ¯ 24 + 21 ¯ 24 = 33 ¯ 24 = 9 ¯ 24 {\\displaystyle {\\overline {12}}_{24}+{\\overline {21}}_{24}={\\overline {33}}_{24}={\\overline {9}}_{24}} as in the arithmetic for the 24-hour clock. The notation Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is used because this ring is the quotient ring of Z {\\displaystyle \\mathbb {Z} } by the ideal m Z {\\displaystyle m\\mathbb {Z} } , the set formed by all multiples of m, i.e., all numbers k m with k ∈ Z . {\\displaystyle k\\in \\mathbb {Z} .} Under addition, Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is a cyclic group. All finite cyclic groups are isomorphic with Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } for some m. The ring of integers modulo m is a field, i.e., every nonzero element has a multiplicative inverse, if and only if m is prime. If m = pk is a prime power with k > 1, there exists a unique (up to isomorphism) finite field G F ( m ) = F m {\\displaystyle \\mathrm {GF} (m)=\\mathbb {F} _{m}} with m elements, which is not isomorphic to Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } , which fails to be a field because it has zero-divisors. If m > 1, ( Z / m Z ) × {\\displaystyle (\\mathbb {Z} /m\\mathbb {Z} )^{\\times }} denotes the multiplicative group of the integers modulo m that are invertible. It consists of the congruence classes am, where a is coprime to m; these are precisely the classes possessing a multiplicative inverse. They form an abelian group under multiplication; its order is φ(m), where φ is Euler's totient function. == Applications == In pure mathematics, modular arithmetic is one of the foundations of number theory, touching on almost every aspect of its study, and it is also used extensively in group theory, ring theory, knot theory, and abstract algebra. In applied mathematics, it is used in computer algebra, cryptography, computer science, chemistry and the visual and musical arts. A very practical application is to calculate checksums within serial number identifiers. For example, International Standard Book Number (ISBN) uses modulo 11 (for 10-digit ISBN) or modulo 10 (for 13-digit ISBN) arithmetic for error detection. Likewise, International Bank Account Numbers (IBANs) use modulo 97 arithmetic to spot user input errors in bank account numbers. In chemistry, the last digit of the CAS registry number (a unique identifying number for each chemical compound) is a check digit, which is calculated by taking the last digit of the first two parts of the CAS registry number times 1, the previous digit times 2, the previous digit times 3 etc., adding all these up and computing the sum modulo 10. In cryptography, modular arithmetic directly underpins public key systems such as RSA and Diffie–Hellman, and provides finite fields which underlie elliptic curves, and is used in a variety of symmetric key algorithms including Advanced Encryption Standard (AES), International Data Encryption Algorithm (IDEA), and RC4. RSA and Diffie–Hellman use modular exponentiation. In computer algebra, modular arithmetic is commonly used to limit the size of integer coefficients in intermediate calculations and data. It is used in polynomial factorization, a problem for which all known efficient algorithms use modular arithmetic. It is used by the most efficient implementations of polynomial greatest common divisor, exact linear algebra and Gröbner basis algorithms over the integers and the rational numbers. As posted on Fidonet in the 1980s and archived at Rosetta Code, modular arithmetic was used to disprove Euler's sum of powers conjecture on a Sinclair QL microcomputer using just one-fourth of the integer precision used by a CDC 6600 supercomputer to disprove it two decades earlier via a brute force search. In computer science, modular arithmetic is often applied in bitwise operations and other operations involving fixed-width, cyclic data structures. The modulo operation, as implemented in many programming languages and calculators, is an application of modular arithmetic that is often used in this context. The logical operator XOR sums 2 bits, modulo 2. The use of long division to turn a fraction into a repeating decimal in any base b is equivalent to modular multiplication of b modulo the denominator. For example, for decimal, b = 10. In music, arithmetic modulo 12 is used in the consideration of the system of twelve-tone equal temperament, where octave and enharmonic equivalency occurs (that is, pitches in a 1:2 or 2:1 ratio are equivalent, and C-sharp is considered the same as D-flat). The method of casting out nines offers a quick check of decimal arithmetic computations performed by hand. It is based on modular arithmetic modulo 9, and specifically on the crucial property that 10 ≡ 1 (mod 9). Arithmetic modulo 7 is used in algorithms that determine the day of the week for a given date. In particular, Zeller's congruence and the Doomsday algorithm make heavy use of modulo-7 arithmetic. More generally, modular arithmetic also has application in disciplines such as law (e.g., apportionment), economics (e.g., game theory) and other areas of the social sciences, where proportional division and allocation of resources plays a central part of the analysis. == Computational complexity == Since modular arithmetic has such a wide range of applications, it is important to know how hard it is to solve a system of congruences. A linear system of congruences can be solved in polynomial time with a form of Gaussian elimination, for details see linear congruence theorem. Algorithms, such as Montgomery reduction, also exist to allow simple arithmetic operations, such as multiplication and exponentiation modulo m, to be performed efficiently on large numbers. Some operations, like finding a discrete logarithm or a quadratic congruence appear to be as hard as integer factorization and thus are a starting point for cryptographic algorithms and encryption. These problems might be NP-intermediate. Solving a system of non-linear modular arithmetic equations is NP-complete. == See also == == Notes == == References == John L. Berggren. \"modular arithmetic\". Encyclopædia Britannica. Apostol, Tom M. (1976), Introduction to analytic number theory, Undergraduate Texts in Mathematics, New York-Heidelberg: Springer-Verlag, ISBN 978-0-387-90163-3, MR 0434929, Zbl 0335.10001. See in particular chapters 5 and 6 for a review of basic modular arithmetic. Maarten Bullynck \"Modular Arithmetic before C.F. Gauss. Systematisations and discussions on remainder problems in 18th-century Germany\" Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press and McGraw-Hill, 2001. ISBN 0-262-03293-7. Section 31.3: Modular arithmetic, pp. 862–868. Anthony Gioia, Number Theory, an Introduction Reprint (2001) Dover. ISBN 0-486-41449-3. Long, Calvin T. (1972). Elementary Introduction to Number Theory (2nd ed.). Lexington: D. C. Heath and Company. LCCN 77171950. Pettofrezzo, Anthony J.; Byrkit, Donald R. (1970). Elements of Number Theory. Englewood Cliffs: Prentice Hall. ISBN 9780132683005. LCCN 71081766. Sengadir, T. (2009). Discrete Mathematics and Combinatorics. Chennai, India: Pearson Education India. ISBN 978-81-317-1405-8. OCLC 778356123. == External links == \"Congruence\", Encyclopedia of Mathematics, EMS Press, 2001  In this modular art article, one can learn more about applications of modular arithmetic in art. An article on modular arithmetic on the GIMPS wiki Modular Arithmetic and patterns in addition and multiplication tables"
  },
  "chunks": [
    {
      "id": "modulararithmetic_9689c945_c0000",
      "article_id": "modulararithmetic_9689c945",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 970,
      "content": "In mathematics, modular arithmetic is a system of arithmetic operations for integers, other than the usual ones from elementary arithmetic, where numbers \"wrap around\" when reaching a certain value, called the modulus. The modern approach to modular arithmetic was developed by Carl Friedrich Gauss in his book Disquisitiones Arithmeticae, published in 1801. A familiar example of modular arithmetic is the hour hand on a 12-hour clock. If the hour hand points to 7 now, then 8 hours later it will point to 3. Ordinary addition would result in 7 + 8 = 15, but 15 reads as 3 on the clock face. This is because the hour hand makes one rotation every 12 hours and the hour number starts over when the hour hand passes 12. We say that 15 is congruent to 3 modulo 12, written 15 ≡ 3 (mod 12), so that 7 + 8 ≡ 3 (mod 12). Similarly, if one starts at 12 and waits 8 hours, the hour hand will be at 8. If one instead waited twice as long, 16 hours, the hour hand would be on 4.",
      "char_count": 969,
      "token_estimate": 242,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0001",
      "article_id": "modulararithmetic_9689c945",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 970,
      "end_char": 1163,
      "content": "This can be written as 2 × 8 ≡ 4 (mod 12). Note that after a wait of exactly 12 hours, the hour hand will always be right where it was before, so 12 acts the same as zero, thus 12 ≡ 0 (mod 12).",
      "char_count": 193,
      "token_estimate": 48,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0002",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Congruence ==",
      "heading_path": "== Congruence ==",
      "start_char": 1180,
      "end_char": 2151,
      "content": "== Congruence == Given an integer m ≥ 1, called a modulus, two integers a and b are said to be congruent modulo m, if m is a divisor of their difference; that is, if there is an integer k such that a − b = k m. Congruence modulo m is a congruence relation, meaning that it is an equivalence relation that is compatible with addition, subtraction, and multiplication. Congruence modulo m is denoted by a ≡ b (mod m). The parentheses mean that (mod m) applies to the entire equation, not just to the right-hand side (here, b). This notation is not to be confused with the notation b mod m (without parentheses), which refers to the remainder of b when divided by m, known as the modulo operation: that is, b mod m denotes the unique integer r such that 0 ≤ r < m and r ≡ b (mod m). The congruence relation may be rewritten as a = k m + b, explicitly showing its relationship with Euclidean division. However, the b here need not be the remainder in the division of a by m.",
      "char_count": 970,
      "token_estimate": 242,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0003",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Congruence ==",
      "heading_path": "== Congruence ==",
      "start_char": 2151,
      "end_char": 2664,
      "content": "Rather, a ≡ b (mod m) asserts that a and b have the same remainder when divided by m. That is, a = p m + r, b = q m + r, where 0 ≤ r < m is the common remainder. We recover the previous relation (a − b = k m) by subtracting these two expressions and setting k = p − q. Because the congruence modulo m is defined by the divisibility by m and because −1 is a unit in the ring of integers, a number is divisible by −m exactly if it is divisible by m. This means that every non-zero integer m may be taken as modulus.",
      "char_count": 513,
      "token_estimate": 128,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0004",
      "article_id": "modulararithmetic_9689c945",
      "section": "== = Examples ==",
      "heading_path": "== = Examples ==",
      "start_char": 2665,
      "end_char": 3125,
      "content": "== = Examples === In modulus 12, one can assert that: 38 ≡ 14 (mod 12) because the difference is 38 − 14 = 24 = 2 × 12, a multiple of 12. Equivalently, 38 and 14 have the same remainder 2 when divided by 12. The definition of congruence also applies to negative values. For example: 2 ≡ − 3 ( mod 5 ) − 8 ≡ + 7 ( mod 5 ) − 3 ≡ − 8 ( mod 5 ) . {\\displaystyle {\\begin{aligned}2&\\equiv -3{\\pmod {5}}\\\\-8&\\equiv {\\phantom {+}}7{\\pmod {5}}\\\\-3&\\equiv -8{\\pmod {5}}.\\end{aligned}}}",
      "char_count": 475,
      "token_estimate": 118,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0005",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Basic properties ==",
      "heading_path": "== Basic properties ==",
      "start_char": 3147,
      "end_char": 4069,
      "content": "== Basic properties == The congruence relation satisfies all the conditions of an equivalence relation: Reflexivity: a ≡ a (mod m) Symmetry: a ≡ b (mod m) if b ≡ a (mod m). Transitivity: If a ≡ b (mod m) and b ≡ c (mod m), then a ≡ c (mod m) If a1 ≡ b1 (mod m) and a2 ≡ b2 (mod m), or if a ≡ b (mod m), then: a + k ≡ b + k (mod m) for any integer k (compatibility with translation) k a ≡ k b (mod m) for any integer k (compatibility with scaling) k a ≡ k b (mod k m) for any integer k a1 + a2 ≡ b1 + b2 (mod m) (compatibility with addition) a1 − a2 ≡ b1 − b2 (mod m) (compatibility with subtraction) a1 a2 ≡ b1 b2 (mod m) (compatibility with multiplication) ak ≡ bk (mod m) for any non-negative integer k (compatibility with exponentiation) p(a) ≡ p(b) (mod m), for any polynomial p(x) with integer coefficients (compatibility with polynomial evaluation) If a ≡ b (mod m), then it is generally false that ka ≡ kb (mod m).",
      "char_count": 921,
      "token_estimate": 230,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0006",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Basic properties ==",
      "heading_path": "== Basic properties ==",
      "start_char": 4069,
      "end_char": 4979,
      "content": "However, the following is true: If c ≡ d (mod φ(m)), where φ is Euler's totient function, then ac ≡ ad (mod m)—provided that a is coprime with m. For cancellation of common terms, we have the following rules: If a + k ≡ b + k (mod m), where k is any integer, then a ≡ b (mod m). If k a ≡ k b (mod m) and k is coprime with m, then a ≡ b (mod m). If k a ≡ k b (mod k m) and k ≠ 0, then a ≡ b (mod m). The last rule can be used to move modular arithmetic into division. If b divides a, then (a/b) mod m = (a mod b m) / b. The modular multiplicative inverse is defined by the following rules: Existence: There exists an integer denoted a−1 such that aa−1 ≡ 1 (mod m) if and only if a is coprime with m. This integer a−1 is called a modular multiplicative inverse of a modulo m. If a ≡ b (mod m) and a−1 exists, then a−1 ≡ b−1 (mod m) (compatibility with multiplicative inverse, and, if a = b, uniqueness modulo m).",
      "char_count": 910,
      "token_estimate": 227,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0007",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Basic properties ==",
      "heading_path": "== Basic properties ==",
      "start_char": 4980,
      "end_char": 5445,
      "content": "If ax ≡ b (mod m) and a is coprime to m, then the solution to this linear congruence is given by x ≡ a−1b (mod m). The multiplicative inverse x ≡ a−1 (mod m) may be efficiently computed by solving Bézout's equation a x + m y = 1 for x, y, by using the Extended Euclidean algorithm. In particular, if p is a prime number, then a is coprime with p for every a such that 0 < a < p; thus a multiplicative inverse exists for all a that is not congruent to zero modulo p.",
      "char_count": 465,
      "token_estimate": 116,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0008",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Advanced properties ==",
      "heading_path": "== Advanced properties ==",
      "start_char": 5449,
      "end_char": 6368,
      "content": "== Advanced properties == Some of the more advanced properties of congruence relations are the following: Fermat's little theorem: If p is prime and does not divide a, then ap−1 ≡ 1 (mod p). Euler's theorem: If a and m are coprime, then aφ(m) ≡ 1 (mod m), where φ is Euler's totient function. A simple consequence of Fermat's little theorem is that if p is prime, then a−1 ≡ ap−2 (mod p) is the multiplicative inverse of 0 < a < p. More generally, from Euler's theorem, if a and m are coprime, then a−1 ≡ aφ(m)−1 (mod m). Hence, if ax ≡ 1 (mod m), then x ≡ aφ(m)−1 (mod m). Another simple consequence is that if a ≡ b (mod φ(m)), where φ is Euler's totient function, then ka ≡ kb (mod m) provided k is coprime with m. Wilson's theorem: p is prime if and only if (p − 1)! ≡ −1 (mod p). Chinese remainder theorem: For any a, b and coprime m, n, there exists a unique x (mod mn) such that x ≡ a (mod m) and x ≡ b (mod n).",
      "char_count": 918,
      "token_estimate": 229,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0009",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Advanced properties ==",
      "heading_path": "== Advanced properties ==",
      "start_char": 6368,
      "end_char": 7247,
      "content": "In fact, x ≡ b mn−1 m + a nm−1 n (mod mn) where mn−1 is the inverse of m modulo n and nm−1 is the inverse of n modulo m. Lagrange's theorem: If p is prime and f (x) = a0 xd + ... + ad is a polynomial with integer coefficients such that p is not a divisor of a0, then the congruence f (x) ≡ 0 (mod p) has at most d non-congruent solutions. Primitive root modulo m: A number g is a primitive root modulo m if, for every integer a coprime to m, there is an integer k such that gk ≡ a (mod m). A primitive root modulo m exists if and only if m is equal to 2, 4, pk or 2pk, where p is an odd prime number and k is a positive integer. If a primitive root modulo m exists, then there are exactly φ(φ(m)) such primitive roots, where φ is the Euler's totient function. Quadratic residue: An integer a is a quadratic residue modulo m, if there exists an integer x such that x2 ≡ a (mod m).",
      "char_count": 879,
      "token_estimate": 219,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0010",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Advanced properties ==",
      "heading_path": "== Advanced properties ==",
      "start_char": 7248,
      "end_char": 7407,
      "content": "Euler's criterion asserts that, if p is an odd prime, and a is not a multiple of p, then a is a quadratic residue modulo p if and only if a(p−1)/2 ≡ 1 (mod p).",
      "char_count": 159,
      "token_estimate": 39,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0011",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Congruence classes ==",
      "heading_path": "== Congruence classes ==",
      "start_char": 7407,
      "end_char": 8283,
      "content": "== Congruence classes == The congruence relation is an equivalence relation. The equivalence class modulo m of an integer a is the set of all integers of the form a + k m, where k is any integer. It is called the congruence class or residue class of a modulo m, and may be denoted (a mod m), or as a or [a] when the modulus m is known from the context. Each residue class modulo m contains exactly one integer in the range 0 , . . . , | m | − 1 {\\displaystyle 0,...,|m|-1} . Thus, these | m | {\\displaystyle |m|} integers are representatives of their respective residue classes. It is generally easier to work with integers than sets of integers; that is, the representatives most often considered, rather than their residue classes. Consequently, (a mod m) denotes generally the unique integer r such that 0 ≤ r < m and r ≡ a (mod m); it is called the residue of a modulo m.",
      "char_count": 875,
      "token_estimate": 218,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0012",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Congruence classes ==",
      "heading_path": "== Congruence classes ==",
      "start_char": 8283,
      "end_char": 8423,
      "content": "In particular, (a mod m) = (b mod m) is equivalent to a ≡ b (mod m), and this explains why \"=\" is often used instead of \"≡\" in this context.",
      "char_count": 140,
      "token_estimate": 35,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0013",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Residue systems ==",
      "heading_path": "== Residue systems ==",
      "start_char": 8421,
      "end_char": 9288,
      "content": "== Residue systems == Each residue class modulo m may be represented by any one of its members, although we usually represent each residue class by the smallest nonnegative integer which belongs to that class (since this is the proper remainder which results from division). Any two members of different residue classes modulo m are incongruent modulo m. Furthermore, every integer belongs to one and only one residue class modulo m. The set of integers {0, 1, 2, ..., m − 1} is called the least residue system modulo m. Any set of m integers, no two of which are congruent modulo m, is called a complete residue system modulo m. The least residue system is a complete residue system, and a complete residue system is simply a set containing precisely one representative of each residue class modulo m. For example, the least residue system modulo 4 is {0, 1, 2, 3}.",
      "char_count": 866,
      "token_estimate": 216,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0014",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Residue systems ==",
      "heading_path": "== Residue systems ==",
      "start_char": 9288,
      "end_char": 9649,
      "content": "Some other complete residue systems modulo 4 include: {1, 2, 3, 4} {13, 14, 15, 16} {−2, −1, 0, 1} {−13, 4, 17, 18} {−5, 0, 6, 21} {27, 32, 37, 42} Some sets that are not complete residue systems modulo 4 are: {−5, 0, 6, 22}, since 6 is congruent to 22 modulo 4. {5, 15}, since a complete residue system modulo 4 must have exactly 4 incongruent residue classes.",
      "char_count": 361,
      "token_estimate": 90,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0015",
      "article_id": "modulararithmetic_9689c945",
      "section": "== = Reduced residue systems ==",
      "heading_path": "== = Reduced residue systems ==",
      "start_char": 9660,
      "end_char": 9939,
      "content": "== = Reduced residue systems === Given the Euler's totient function φ(m), any set of φ(m) integers that are relatively prime to m and mutually incongruent under modulus m is called a reduced residue system modulo m. The set {5, 15} from above, for example, is an instance of a reduced residue system modulo 4.",
      "char_count": 309,
      "token_estimate": 77,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0016",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Integers modulo m ==",
      "heading_path": "== Integers modulo m ==",
      "start_char": 10097,
      "end_char": 10826,
      "content": "== Integers modulo m == In the context of this paragraph, the modulus m is almost always taken as positive. The set of all congruence classes modulo m is a ring called the ring of integers modulo m, and is denoted Z / m Z {\\textstyle \\mathbb {Z} /m\\mathbb {Z} } , Z / m {\\displaystyle \\mathbb {Z} /m} , or Z m {\\displaystyle \\mathbb {Z} _{m}} . The ring Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is fundamental to various branches of mathematics (see § Applications below). (In some parts of number theory the notation Z m {\\displaystyle \\mathbb {Z} _{m}} is avoided because it can be confused with the set of m-adic integers.) For m > 0 one has Z / m Z = { a ¯ m ∣ a ∈ Z } = { 0 ¯ m , 1 ¯ m , 2 ¯ m , … , m − 1 ¯ m } .",
      "char_count": 728,
      "token_estimate": 182,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0017",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Integers modulo m ==",
      "heading_path": "== Integers modulo m ==",
      "start_char": 10826,
      "end_char": 11655,
      "content": "{\\displaystyle \\mathbb {Z} /m\\mathbb {Z} =\\left\\{{\\overline {a}}_{m}\\mid a\\in \\mathbb {Z} \\right\\}=\\left\\{{\\overline {0}}_{m},{\\overline {1}}_{m},{\\overline {2}}_{m},\\ldots ,{\\overline {m{-}1}}_{m}\\right\\}.} When m = 1, Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is the zero ring; when m = 0, Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is not an empty set; rather, it is isomorphic to Z {\\displaystyle \\mathbb {Z} } , since a0 = {a}. Addition, subtraction, and multiplication are defined on Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } by the following rules: a ¯ m + b ¯ m = ( a + b ) ¯ m {\\displaystyle {\\overline {a}}_{m}+{\\overline {b}}_{m}={\\overline {(a+b)}}_{m}} a ¯ m − b ¯ m = ( a − b ) ¯ m {\\displaystyle {\\overline {a}}_{m}-{\\overline {b}}_{m}={\\overline {(a-b)}}_{m}} a ¯ m b ¯ m = ( a b ) ¯ m .",
      "char_count": 829,
      "token_estimate": 207,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0018",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Integers modulo m ==",
      "heading_path": "== Integers modulo m ==",
      "start_char": 11656,
      "end_char": 12639,
      "content": "{\\displaystyle {\\overline {a}}_{m}{\\overline {b}}_{m}={\\overline {(ab)}}_{m}.} The properties given before imply that, with these operations, Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is a commutative ring. For example, in the ring Z / 24 Z {\\displaystyle \\mathbb {Z} /24\\mathbb {Z} } , one has 12 ¯ 24 + 21 ¯ 24 = 33 ¯ 24 = 9 ¯ 24 {\\displaystyle {\\overline {12}}_{24}+{\\overline {21}}_{24}={\\overline {33}}_{24}={\\overline {9}}_{24}} as in the arithmetic for the 24-hour clock. The notation Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is used because this ring is the quotient ring of Z {\\displaystyle \\mathbb {Z} } by the ideal m Z {\\displaystyle m\\mathbb {Z} } , the set formed by all multiples of m, i.e., all numbers k m with k ∈ Z . {\\displaystyle k\\in \\mathbb {Z} .} Under addition, Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } is a cyclic group. All finite cyclic groups are isomorphic with Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } for some m.",
      "char_count": 983,
      "token_estimate": 245,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0019",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Integers modulo m ==",
      "heading_path": "== Integers modulo m ==",
      "start_char": 12640,
      "end_char": 13478,
      "content": "The ring of integers modulo m is a field, i.e., every nonzero element has a multiplicative inverse, if and only if m is prime. If m = pk is a prime power with k > 1, there exists a unique (up to isomorphism) finite field G F ( m ) = F m {\\displaystyle \\mathrm {GF} (m)=\\mathbb {F} _{m}} with m elements, which is not isomorphic to Z / m Z {\\displaystyle \\mathbb {Z} /m\\mathbb {Z} } , which fails to be a field because it has zero-divisors. If m > 1, ( Z / m Z ) × {\\displaystyle (\\mathbb {Z} /m\\mathbb {Z} )^{\\times }} denotes the multiplicative group of the integers modulo m that are invertible. It consists of the congruence classes am, where a is coprime to m; these are precisely the classes possessing a multiplicative inverse. They form an abelian group under multiplication; its order is φ(m), where φ is Euler's totient function.",
      "char_count": 838,
      "token_estimate": 209,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0020",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Applications ==",
      "heading_path": "== Applications ==",
      "start_char": 13474,
      "end_char": 14224,
      "content": "== Applications == In pure mathematics, modular arithmetic is one of the foundations of number theory, touching on almost every aspect of its study, and it is also used extensively in group theory, ring theory, knot theory, and abstract algebra. In applied mathematics, it is used in computer algebra, cryptography, computer science, chemistry and the visual and musical arts. A very practical application is to calculate checksums within serial number identifiers. For example, International Standard Book Number (ISBN) uses modulo 11 (for 10-digit ISBN) or modulo 10 (for 13-digit ISBN) arithmetic for error detection. Likewise, International Bank Account Numbers (IBANs) use modulo 97 arithmetic to spot user input errors in bank account numbers.",
      "char_count": 749,
      "token_estimate": 187,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0021",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Applications ==",
      "heading_path": "== Applications ==",
      "start_char": 14224,
      "end_char": 15197,
      "content": "In chemistry, the last digit of the CAS registry number (a unique identifying number for each chemical compound) is a check digit, which is calculated by taking the last digit of the first two parts of the CAS registry number times 1, the previous digit times 2, the previous digit times 3 etc., adding all these up and computing the sum modulo 10. In cryptography, modular arithmetic directly underpins public key systems such as RSA and Diffie–Hellman, and provides finite fields which underlie elliptic curves, and is used in a variety of symmetric key algorithms including Advanced Encryption Standard (AES), International Data Encryption Algorithm (IDEA), and RC4. RSA and Diffie–Hellman use modular exponentiation. In computer algebra, modular arithmetic is commonly used to limit the size of integer coefficients in intermediate calculations and data. It is used in polynomial factorization, a problem for which all known efficient algorithms use modular arithmetic.",
      "char_count": 973,
      "token_estimate": 243,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0022",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Applications ==",
      "heading_path": "== Applications ==",
      "start_char": 15198,
      "end_char": 16195,
      "content": "It is used by the most efficient implementations of polynomial greatest common divisor, exact linear algebra and Gröbner basis algorithms over the integers and the rational numbers. As posted on Fidonet in the 1980s and archived at Rosetta Code, modular arithmetic was used to disprove Euler's sum of powers conjecture on a Sinclair QL microcomputer using just one-fourth of the integer precision used by a CDC 6600 supercomputer to disprove it two decades earlier via a brute force search. In computer science, modular arithmetic is often applied in bitwise operations and other operations involving fixed-width, cyclic data structures. The modulo operation, as implemented in many programming languages and calculators, is an application of modular arithmetic that is often used in this context. The logical operator XOR sums 2 bits, modulo 2. The use of long division to turn a fraction into a repeating decimal in any base b is equivalent to modular multiplication of b modulo the denominator.",
      "char_count": 997,
      "token_estimate": 249,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0023",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Applications ==",
      "heading_path": "== Applications ==",
      "start_char": 16196,
      "end_char": 17166,
      "content": "For example, for decimal, b = 10. In music, arithmetic modulo 12 is used in the consideration of the system of twelve-tone equal temperament, where octave and enharmonic equivalency occurs (that is, pitches in a 1:2 or 2:1 ratio are equivalent, and C-sharp is considered the same as D-flat). The method of casting out nines offers a quick check of decimal arithmetic computations performed by hand. It is based on modular arithmetic modulo 9, and specifically on the crucial property that 10 ≡ 1 (mod 9). Arithmetic modulo 7 is used in algorithms that determine the day of the week for a given date. In particular, Zeller's congruence and the Doomsday algorithm make heavy use of modulo-7 arithmetic. More generally, modular arithmetic also has application in disciplines such as law (e.g., apportionment), economics (e.g., game theory) and other areas of the social sciences, where proportional division and allocation of resources plays a central part of the analysis.",
      "char_count": 970,
      "token_estimate": 242,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "modulararithmetic_9689c945_c0024",
      "article_id": "modulararithmetic_9689c945",
      "section": "== Computational complexity ==",
      "heading_path": "== Computational complexity ==",
      "start_char": 17179,
      "end_char": 17966,
      "content": "== Computational complexity == Since modular arithmetic has such a wide range of applications, it is important to know how hard it is to solve a system of congruences. A linear system of congruences can be solved in polynomial time with a form of Gaussian elimination, for details see linear congruence theorem. Algorithms, such as Montgomery reduction, also exist to allow simple arithmetic operations, such as multiplication and exponentiation modulo m, to be performed efficiently on large numbers. Some operations, like finding a discrete logarithm or a quadratic congruence appear to be as hard as integer factorization and thus are a starting point for cryptographic algorithms and encryption. These problems might be NP-intermediate. Solving a system of non-linear modular arithmetic equations is NP-complete.",
      "char_count": 816,
      "token_estimate": 204,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 10,
    "items": [
      {
        "question": "What specific algorithms utilize modular arithmetic for their most efficient implementations?",
        "answer": "The most efficient implementations of polynomial greatest common divisor, exact linear algebra, and Gröbner basis algorithms over the integers and the rational numbers use modular arithmetic.",
        "related_chunk_ids": [
          "modulararithmetic_9689c945_c0022"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What type of algebraic structure is Z/mZ under the operation of addition?",
        "answer": "Under addition, Z/mZ is a cyclic group.",
        "related_chunk_ids": [
          "modulararithmetic_9689c945_c0018"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What is the definition of two integers, 'a' and 'b', being congruent modulo 'm'?",
        "answer": "Given an integer m ≥ 1, called a modulus, two integers 'a' and 'b' are said to be congruent modulo m if m is a divisor of their difference; that is, if there is an integer k such that a − b = k * m.",
        "related_chunk_ids": [
          "modulararithmetic_9689c945_c0002"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "Using the formal definition of congruence, explain why the clock example `15 ≡ 3 (mod 12)` is a valid statement.",
        "answer": "According to the formal definition, two integers `a` and `b` are congruent modulo `m` if `m` is a divisor of their difference (`a - b`). In the example `15 ≡ 3 (mod 12)`, `a=15`, `b=3`, and the modulus `m=12`. The difference is `15 - 3 = 12`. Since 12 is a divisor of the modulus 12 (because `12 = 1 * 12`), the statement is valid.",
        "related_chunk_ids": [
          "modulararithmetic_9689c945_c0000",
          "modulararithmetic_9689c945_c0002"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "Provide a comprehensive explanation of the congruence relation `a ≡ b (mod m)`, including its definition, its properties as an equivalence relation, and an example with both positive and negative numbers.",
        "answer": "The congruence relation `a ≡ b (mod m)` asserts that two integers, `a` and `b`, have the same remainder when divided by a non-zero integer modulus `m`. This is equivalent to stating that their difference, `a - b`, is an integer multiple of `m`. The congruence relation satisfies the conditions of an equivalence relation: it is reflexive (`a ≡ a (mod m)`), symmetric (`if a ≡ b (mod m) then b ≡ a (mod m)`), and transitive (`if a ≡ b (mod m) and b ≡ c (mod m), then a ≡ c (mod m)`). For example, `38 ≡ 14 (mod 12)` because `38 - 14 = 24`, a multiple of 12. The definition also applies to negative numbers, as in `2 ≡ -3 (mod 5)`, where the difference `2 - (-3) = 5` is a multiple of 5.",
        "related_chunk_ids": [
          "modulararithmetic_9689c945_c0003",
          "modulararithmetic_9689c945_c0004",
          "modulararithmetic_9689c945_c0005"
        ],
        "category": "LONG_ANSWER"
      },
      {
        "question": "What are the different methods described for computing the modular multiplicative inverse of an integer 'a' modulo 'm'?",
        "answer": "The modular multiplicative inverse, denoted a⁻¹, exists if and only if 'a' is coprime with 'm'. One method to compute it is by using the Extended Euclidean algorithm to solve Bézout's equation, ax + my = 1, for x. A second method, derived from Euler's theorem, allows for direct computation using the formula a⁻¹ ≡ a^(φ(m)−1) (mod m), where φ is Euler's totient function.",
        "related_chunk_ids": [
          "modulararithmetic_9689c945_c0006",
          "modulararithmetic_9689c945_c0007",
          "modulararithmetic_9689c945_c0008"
        ],
        "category": "LONG_ANSWER"
      },
      {
        "question": "What two arithmetic operations are illustrated using the 12-hour clock example, and what are their specific congruent results modulo 12?",
        "answer": "The two arithmetic operations illustrated are addition and multiplication. The addition example is 7 + 8, which is congruent to 3 (mod 12). The multiplication example, representing waiting for 8 hours twice, is 2 × 8, which is congruent to 4 (mod 12).",
        "related_chunk_ids": [
          "modulararithmetic_9689c945_c0000",
          "modulararithmetic_9689c945_c0001"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "What are the two equivalent ways to define that two integers, a and b, are congruent modulo m, and how are these definitions related?",
        "answer": "Two integers, a and b, are congruent modulo m if their difference is a multiple of the modulus m, which can be expressed as a − b = km for some integer k. An equivalent definition is that a and b have the same remainder when divided by m. The relationship is demonstrated by writing a = pm + r and b = qm + r, where r is the common remainder. Subtracting these expressions gives a − b = (p − q)m, which is the first definition with k = p − q.",
        "related_chunk_ids": [
          "modulararithmetic_9689c945_c0002",
          "modulararithmetic_9689c945_c0003"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "What condition must be met for an integer 'a' to have a modular multiplicative inverse modulo 'm', and how does this condition relate to solving the linear congruence 'ax ≡ b (mod m)'?",
        "answer": "For an integer 'a' to have a modular multiplicative inverse modulo 'm', 'a' must be coprime with 'm'. This same condition is required to solve the linear congruence 'ax ≡ b (mod m)', as the solution is found by using that inverse: x ≡ a⁻¹b (mod m).",
        "related_chunk_ids": [
          "modulararithmetic_9689c945_c0006",
          "modulararithmetic_9689c945_c0007"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "What is a quadratic residue, and what is the test provided by Euler's criterion to determine if an integer is one modulo an odd prime?",
        "answer": "A quadratic residue is an integer 'a' modulo 'm' for which there exists an integer 'x' such that x² ≡ a (mod m). Euler's criterion provides a test for this, asserting that if 'p' is an odd prime and 'a' is not a multiple of 'p', then 'a' is a quadratic residue modulo 'p' if and only if a(p−1)/2 ≡ 1 (mod p).",
        "related_chunk_ids": [
          "modulararithmetic_9689c945_c0009",
          "modulararithmetic_9689c945_c0010"
        ],
        "category": "INTERPRETATION"
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-31T06:36:49.826Z",
    "content_format": "markdown",
    "total_chunks": 25,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}