{
  "article": {
    "id": "computabilitytheory_f9e944f3",
    "title": "Computability theory",
    "url": "https://en.wikipedia.org/wiki/Computability_theory",
    "lang": "en",
    "created_at": "2025-07-31T06:32:09.826110",
    "content": "---\nid: computabilitytheory_f9e944f3\nurl: https://en.wikipedia.org/wiki/Computability_theory\ntitle: Computability theory\nlang: en\ncreated_at: '2025-07-31T06:26:19.390124'\nchecksum: 42d6d8e74e6bd91b07b695d2ccbb2f517e88cbb0e4a223653cef4ba5f6c1ffc4\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 5259\n  char_count: 33803\n  num_chunks: 40\n  original_chunks: 50\n  filtered_out: 10\n  num_sections: 0\n---\nComputability theory, also known as recursion theory, is a branch of mathematical logic, computer science, and the theory of computation that originated in the 1930s with the study of computable functions and Turing degrees. The field has since expanded to include the study of generalized computability and definability. In these areas, computability theory overlaps with proof theory and effective descriptive set theory. Basic questions addressed by computability theory include: What does it mean for a function on the natural numbers to be computable? How can noncomputable functions be classified into a hierarchy based on their level of noncomputability? Although there is considerable overlap in terms of knowledge and methods, mathematical computability theorists study the theory of relative computability, reducibility notions, and degree structures; those in the computer science field focus on the theory of subrecursive hierarchies, formal methods, and formal languages. The study of which mathematical constructions can be effectively performed is sometimes called recursive mathematics. == Introduction == Computability theory originated in the 1930s, with the work of Kurt Gödel, Alonzo Church, Rózsa Péter, Alan Turing, Stephen Kleene, and Emil Post. The fundamental results the researchers obtained established Turing computability as the correct formalization of the informal idea of effective calculation. In 1952, these results led Kleene to coin the two names \"Church's thesis\" and \"Turing's thesis\". Nowadays these are often considered as a single hypothesis, the Church–Turing thesis, which states that any function that is computable by an algorithm is a computable function. Although initially skeptical, by 1946 Gödel argued in favor of this thesis: \"Tarski has stressed in his lecture (and I think justly) the great importance of the concept of general recursiveness (or Turing's computability). It seems to me that this importance is largely due to the fact that with this concept one has for the first time succeeded in giving an absolute notion to an interesting epistemological notion, i.e., one not depending on the formalism chosen.\" With a definition of effective calculation came the first proofs that there are problems in mathematics that cannot be effectively decided. In 1936, Church and Turing were inspired by techniques used by Gödel to prove his incompleteness theorems - in 1931, Gödel independently demonstrated that the Entscheidungsproblem is not effectively decidable. This result showed that there is no algorithmic procedure that can correctly decide whether arbitrary mathematical propositions are true or false. Many problems in mathematics have been shown to be undecidable after these initial examples were established. In 1947, Markov and Post published independent papers showing that the word problem for semigroups cannot be effectively decided. Extending this result, Pyotr Novikov and William Boone showed independently in the 1950s that the word problem for groups is not effectively solvable: there is no effective procedure that, given a word in a finitely presented group, will decide whether the element represented by the word is the identity element of the group. In 1970, Yuri Matiyasevich proved (using results of Julia Robinson) Matiyasevich's theorem, which implies that Hilbert's tenth problem has no effective solution; this problem asked whether there is an effective procedure to decide whether a Diophantine equation over the integers has a solution in the integers. == Turing computability == The main form of computability studied in the field was introduced by Turing in 1936. A set of natural numbers is said to be a computable set (also called a decidable, recursive, or Turing computable set) if there is a Turing machine that, given a number n, halts with output 1 if n is in the set and halts with output 0 if n is not in the set. A function f from natural numbers to natural numbers is a (Turing) computable, or recursive function if there is a Turing machine that, on input n, halts and returns output f(n). The use of Turing machines here is not necessary; there are many other models of computation that have the same computing power as Turing machines; for example the μ-recursive functions obtained from primitive recursion and the μ operator. The terminology for computable functions and sets is not completely standardized. The definition in terms of μ-recursive functions as well as a different definition of rekursiv functions by Gödel led to the traditional name recursive for sets and functions computable by a Turing machine. The word decidable stems from the German word Entscheidungsproblem which was used in the original papers of Turing and others. In contemporary use, the term \"computable function\" has various definitions: according to Nigel J. Cutland, it is a partial recursive function (which can be undefined for some inputs), while according to Robert I. Soare it is a total recursive (equivalently, general recursive) function. This article follows the second of these conventions. In 1996, Soare gave additional comments about the terminology. Not every set of natural numbers is computable. The halting problem, which is the set of (descriptions of) Turing machines that halt on input 0, is a well-known example of a noncomputable set. The existence of many noncomputable sets follows from the facts that there are only countably many Turing machines, and thus only countably many computable sets, but according to the Cantor's theorem, there are uncountably many sets of natural numbers. Although the halting problem is not computable, it is possible to simulate program execution and produce an infinite list of the programs that do halt. Thus the halting problem is an example of a computably enumerable (c.e.) set, which is a set that can be enumerated by a Turing machine (other terms for computably enumerable include recursively enumerable and semidecidable). Equivalently, a set is c.e. if and only if it is the range of some computable function. The c.e. sets, although not decidable in general, have been studied in detail in computability theory. == Areas of research == Beginning with the theory of computable sets and functions described above, the field of computability theory has grown to include the study of many closely related topics. These are not independent areas of research: each of these areas draws ideas and results from the others, and most computability theorists are familiar with the majority of them. === Relative computability and the Turing degrees === Computability theory in mathematical logic has traditionally focused on relative computability, a generalization of Turing computability defined using oracle Turing machines, introduced by Turing in 1939. An oracle Turing machine is a hypothetical device which, in addition to performing the actions of a regular Turing machine, is able to ask questions of an oracle, which is a particular set of natural numbers. The oracle machine may only ask questions of the form \"Is n in the oracle set?\". Each question will be immediately answered correctly, even if the oracle set is not computable. Thus an oracle machine with a noncomputable oracle will be able to compute sets that a Turing machine without an oracle cannot. Informally, a set of natural numbers A is Turing reducible to a set B if there is an oracle machine that correctly tells whether numbers are in A when run with B as the oracle set (in this case, the set A is also said to be (relatively) computable from B and recursive in B). If a set A is Turing reducible to a set B and B is Turing reducible to A then the sets are said to have the same Turing degree (also called degree of unsolvability). The Turing degree of a set gives a precise measure of how uncomputable the set is. The natural examples of sets that are not computable, including many different sets that encode variants of the halting problem, have two properties in common: They are computably enumerable, and Each can be translated into any other via a many-one reduction. That is, given such sets A and B, there is a total computable function f such that A = {x : f(x) ∈ B}. These sets are said to be many-one equivalent (or m-equivalent). Many-one reductions are \"stronger\" than Turing reductions: if a set A is many-one reducible to a set B, then A is Turing reducible to B, but the converse does not always hold. Although the natural examples of noncomputable sets are all many-one equivalent, it is possible to construct computably enumerable sets A and B such that A is Turing reducible to B but not many-one reducible to B. It can be shown that every computably enumerable set is many-one reducible to the halting problem, and thus the halting problem is the most complicated computably enumerable set with respect to many-one reducibility and with respect to Turing reducibility. In 1944, Post asked whether every computably enumerable set is either computable or Turing equivalent to the halting problem, that is, whether there is no computably enumerable set with a Turing degree intermediate between those two. As intermediate results, Post defined natural types of computably enumerable sets like the simple, hypersimple and hyperhypersimple sets. Post showed that these sets are strictly between the computable sets and the halting problem with respect to many-one reducibility. Post also showed that some of them are strictly intermediate under other reducibility notions stronger than Turing reducibility. But Post left open the main problem of the existence of computably enumerable sets of intermediate Turing degree; this problem became known as Post's problem. After ten years, Kleene and Post showed in 1954 that there are intermediate Turing degrees between those of the computable sets and the halting problem, but they failed to show that any of these degrees contains a computably enumerable set. Very soon after this, Friedberg and Muchnik independently solved Post's problem by establishing the existence of computably enumerable sets of intermediate degree. This groundbreaking result opened a wide study of the Turing degrees of the computably enumerable sets which turned out to possess a very complicated and non-trivial structure. There are uncountably many sets that are not computably enumerable, and the investigation of the Turing degrees of all sets is as central in computability theory as the investigation of the computably enumerable Turing degrees. Many degrees with special properties were constructed: hyperimmune-free degrees where every function computable relative to that degree is majorized by a (unrelativized) computable function; high degrees relative to which one can compute a function f which dominates every computable function g in the sense that there is a constant c depending on g such that g(x) < f(x) for all x > c; random degrees containing algorithmically random sets; 1-generic degrees of 1-generic sets; and the degrees below the halting problem of limit-computable sets. The study of arbitrary (not necessarily computably enumerable) Turing degrees involves the study of the Turing jump. Given a set A, the Turing jump of A is a set of natural numbers encoding a solution to the halting problem for oracle Turing machines running with oracle A. The Turing jump of any set is always of higher Turing degree than the original set, and a theorem of Friedburg shows that any set that computes the Halting problem can be obtained as the Turing jump of another set. Post's theorem establishes a close relationship between the Turing jump operation and the arithmetical hierarchy, which is a classification of certain subsets of the natural numbers based on their definability in arithmetic. Much recent research on Turing degrees has focused on the overall structure of the set of Turing degrees and the set of Turing degrees containing computably enumerable sets. A deep theorem of Shore and Slaman states that the function mapping a degree x to the degree of its Turing jump is definable in the partial order of the Turing degrees. A survey by Ambos-Spies and Fejer gives an overview of this research and its historical progression. === Other reducibilities === An ongoing area of research in computability theory studies reducibility relations other than Turing reducibility. Post introduced several strong reducibilities, so named because they imply truth-table reducibility. A Turing machine implementing a strong reducibility will compute a total function regardless of which oracle it is presented with. Weak reducibilities are those where a reduction process may not terminate for all oracles; Turing reducibility is one example. The strong reducibilities include: One-one reducibility: A is one-one reducible (or 1-reducible) to B if there is a total computable injective function f such that each n is in A if and only if f(n) is in B. Many-one reducibility: This is essentially one-one reducibility without the constraint that f be injective. A is many-one reducible (or m-reducible) to B if there is a total computable function f such that each n is in A if and only if f(n) is in B. Truth-table reducibility: A is truth-table reducible to B if A is Turing reducible to B via an oracle Turing machine that computes a total function regardless of the oracle it is given. Because of compactness of Cantor space, this is equivalent to saying that the reduction presents a single list of questions (depending only on the input) to the oracle simultaneously, and then having seen their answers is able to produce an output without asking additional questions regardless of the oracle's answer to the initial queries. Many variants of truth-table reducibility have also been studied. Further reducibilities (positive, disjunctive, conjunctive, linear and their weak and bounded versions) are discussed in the article Reduction (computability theory). The major research on strong reducibilities has been to compare their theories, both for the class of all computably enumerable sets as well as for the class of all subsets of the natural numbers. Furthermore, the relations between the reducibilities has been studied. For example, it is known that every Turing degree is either a truth-table degree or is the union of infinitely many truth-table degrees. Reducibilities weaker than Turing reducibility (that is, reducibilities that are implied by Turing reducibility) have also been studied. The most well known are arithmetical reducibility and hyperarithmetical reducibility. These reducibilities are closely connected to definability over the standard model of arithmetic. === Rice's theorem and the arithmetical hierarchy === Rice showed that for every nontrivial class C (which contains some but not all c.e. sets) the index set E = {e: the eth c.e. set We is in C} has the property that either the halting problem or its complement is many-one reducible to E, that is, can be mapped using a many-one reduction to E (see Rice's theorem for more detail). But, many of these index sets are even more complicated than the halting problem. These type of sets can be classified using the arithmetical hierarchy. For example, the index set FIN of the class of all finite sets is on the level Σ2, the index set REC of the class of all recursive sets is on the level Σ3, the index set COFIN of all cofinite sets is also on the level Σ3 and the index set COMP of the class of all Turing-complete sets Σ4. These hierarchy levels are defined inductively, Σn+1 contains just all sets which are computably enumerable relative to Σn; Σ1 contains the computably enumerable sets. The index sets given here are even complete for their levels, that is, all the sets in these levels can be many-one reduced to the given index sets. === Reverse mathematics === The program of reverse mathematics asks which set-existence axioms are necessary to prove particular theorems of mathematics in subsystems of second-order arithmetic. This study was initiated by Harvey Friedman and was studied in detail by Stephen Simpson and others; in 1999, Simpson gave a detailed discussion of the program. The set-existence axioms in question correspond informally to axioms saying that the powerset of the natural numbers is closed under various reducibility notions. The weakest such axiom studied in reverse mathematics is recursive comprehension, which states that the powerset of the naturals is closed under Turing reducibility. === Numberings === A numbering is an enumeration of functions; it has two parameters, e and x and outputs the value of the e-th function in the numbering on the input x. Numberings can be partial-computable although some of its members are total computable functions. Admissible numberings are those into which all others can be translated. A Friedberg numbering (named after its discoverer) is a one-one numbering of all partial-computable functions; it is necessarily not an admissible numbering. Later research dealt also with numberings of other classes like classes of computably enumerable sets. Goncharov discovered for example a class of computably enumerable sets for which the numberings fall into exactly two classes with respect to computable isomorphisms. === The priority method === Post's problem was solved with a method called the priority method; a proof using this method is called a priority argument. This method is primarily used to construct computably enumerable sets with particular properties. To use this method, the desired properties of the set to be constructed are broken up into an infinite list of goals, known as requirements, so that satisfying all the requirements will cause the set constructed to have the desired properties. Each requirement is assigned to a natural number representing the priority of the requirement; so 0 is assigned to the most important priority, 1 to the second most important, and so on. The set is then constructed in stages, each stage attempting to satisfy one of more of the requirements by either adding numbers to the set or banning numbers from the set so that the final set will satisfy the requirement. It may happen that satisfying one requirement will cause another to become unsatisfied; the priority order is used to decide what to do in such an event. Priority arguments have been employed to solve many problems in computability theory, and have been classified into a hierarchy based on their complexity. Because complex priority arguments can be technical and difficult to follow, it has traditionally been considered desirable to prove results without priority arguments, or to see if results proved with priority arguments can also be proved without them. For example, Kummer published a paper on a proof for the existence of Friedberg numberings without using the priority method. === The lattice of computably enumerable sets === When Post defined the notion of a simple set as a c.e. set with an infinite complement not containing any infinite c.e. set, he started to study the structure of the computably enumerable sets under inclusion. This lattice became a well-studied structure. Computable sets can be defined in this structure by the basic result that a set is computable if and only if the set and its complement are both computably enumerable. Infinite c.e. sets have always infinite computable subsets; but on the other hand, simple sets exist but do not always have a coinfinite computable superset. Post introduced already hypersimple and hyperhypersimple sets; later maximal sets were constructed which are c.e. sets such that every c.e. superset is either a finite variant of the given maximal set or is co-finite. Post's original motivation in the study of this lattice was to find a structural notion such that every set which satisfies this property is neither in the Turing degree of the computable sets nor in the Turing degree of the halting problem. Post did not find such a property and the solution to his problem applied priority methods instead; in 1991, Harrington and Soare found eventually such a property. === Automorphism problems === Another important question is the existence of automorphisms in computability-theoretic structures. One of these structures is that one of computably enumerable sets under inclusion modulo finite difference; in this structure, A is below B if and only if the set difference B − A is finite. Maximal sets (as defined in the previous paragraph) have the property that they cannot be automorphic to non-maximal sets, that is, if there is an automorphism of the computably enumerable sets under the structure just mentioned, then every maximal set is mapped to another maximal set. In 1974, Soare showed that also the converse holds, that is, every two maximal sets are automorphic. So the maximal sets form an orbit, that is, every automorphism preserves maximality and any two maximal sets are transformed into each other by some automorphism. Harrington gave a further example of an automorphic property: that of the creative sets, the sets which are many-one equivalent to the halting problem. Besides the lattice of computably enumerable sets, automorphisms are also studied for the structure of the Turing degrees of all sets as well as for the structure of the Turing degrees of c.e. sets. In both cases, Cooper claims to have constructed nontrivial automorphisms which map some degrees to other degrees; this construction has, however, not been verified and some colleagues believe that the construction contains errors and that the question of whether there is a nontrivial automorphism of the Turing degrees is still one of the main unsolved questions in this area. === Kolmogorov complexity === The field of Kolmogorov complexity and algorithmic randomness was developed during the 1960s and 1970s by Chaitin, Kolmogorov, Levin, Martin-Löf and Solomonoff (the names are given here in alphabetical order; much of the research was independent, and the unity of the concept of randomness was not understood at the time). The main idea is to consider a universal Turing machine U and to measure the complexity of a number (or string) x as the length of the shortest input p such that U(p) outputs x. This approach revolutionized earlier ways to determine when an infinite sequence (equivalently, characteristic function of a subset of the natural numbers) is random or not by invoking a notion of randomness for finite objects. Kolmogorov complexity became not only a subject of independent study but is also applied to other subjects as a tool for obtaining proofs. There are still many open problems in this area. === Frequency computation === This branch of computability theory analyzed the following question: For fixed m and n with 0 < m < n, for which functions A is it possible to compute for any different n inputs x1, x2, ..., xn a tuple of n numbers y1, y2, ..., yn such that at least m of the equations A(xk) = yk are true. Such sets are known as (m, n)-recursive sets. The first major result in this branch of computability theory is Trakhtenbrot's result that a set is computable if it is (m, n)-recursive for some m, n with 2m > n. On the other hand, Jockusch's semirecursive sets (which were already known informally before Jockusch introduced them 1968) are examples of a set which is (m, n)-recursive if and only if 2m < n + 1. There are uncountably many of these sets and also some computably enumerable but noncomputable sets of this type. Later, Degtev established a hierarchy of computably enumerable sets that are (1, n + 1)-recursive but not (1, n)-recursive. After a long phase of research by Russian scientists, this subject became repopularized in the west by Beigel's thesis on bounded queries, which linked frequency computation to the above-mentioned bounded reducibilities and other related notions. One of the major results was Kummer's Cardinality Theory which states that a set A is computable if and only if there is an n such that some algorithm enumerates for each tuple of n different numbers up to n many possible choices of the cardinality of this set of n numbers intersected with A; these choices must contain the true cardinality but leave out at least one false one. === Inductive inference === This is the computability-theoretic branch of learning theory. It is based on E. Mark Gold's model of learning in the limit from 1967 and has developed since then more and more models of learning. The general scenario is the following: Given a class S of computable functions, is there a learner (that is, computable functional) which outputs for any input of the form (f(0), f(1), ..., f(n)) a hypothesis. A learner M learns a function f if almost all hypotheses are the same index e of f with respect to a previously agreed on acceptable numbering of all computable functions; M learns S if M learns every f in S. Basic results are that all computably enumerable classes of functions are learnable while the class REC of all computable functions is not learnable. Many related models have been considered and also the learning of classes of computably enumerable sets from positive data is a topic studied from Gold's pioneering paper in 1967 onwards. === Generalizations of Turing computability === Computability theory includes the study of generalized notions of this field such as arithmetic reducibility, hyperarithmetical reducibility and α-recursion theory, as described by Sacks in 1990. These generalized notions include reducibilities that cannot be executed by Turing machines but are nevertheless natural generalizations of Turing reducibility. These studies include approaches to investigate the analytical hierarchy which differs from the arithmetical hierarchy by permitting quantification over sets of natural numbers in addition to quantification over individual numbers. These areas are linked to the theories of well-orderings and trees; for example the set of all indices of computable (nonbinary) trees without infinite branches is complete for level Π 1 1 {\\displaystyle \\Pi _{1}^{1}} of the analytical hierarchy. Both Turing reducibility and hyperarithmetical reducibility are important in the field of effective descriptive set theory. The even more general notion of degrees of constructibility is studied in set theory. === Continuous computability theory === Computability theory for digital computation is well developed. Computability theory is less well developed for analog computation that occurs in analog computers, analog signal processing, analog electronics, artificial neural networks and continuous-time control theory, modelled by differential equations and continuous dynamical systems. For example, models of computation such as the Blum–Shub–Smale machine model have formalized computation on the reals. == Relationships between definability, proof and computability == There are close relationships between the Turing degree of a set of natural numbers and the difficulty (in terms of the arithmetical hierarchy) of defining that set using a first-order formula. One such relationship is made precise by Post's theorem. A weaker relationship was demonstrated by Kurt Gödel in the proofs of his completeness theorem and incompleteness theorems. Gödel's proofs show that the set of logical consequences of an effective first-order theory is a computably enumerable set, and that if the theory is strong enough this set will be uncomputable. Similarly, Tarski's indefinability theorem can be interpreted both in terms of definability and in terms of computability. Computability theory is also linked to second-order arithmetic, a formal theory of natural numbers and sets of natural numbers. The fact that certain sets are computable or relatively computable often implies that these sets can be defined in weak subsystems of second-order arithmetic. The program of reverse mathematics uses these subsystems to measure the non-computability inherent in well known mathematical theorems. In 1999, Simpson discussed many aspects of second-order arithmetic and reverse mathematics. The field of proof theory includes the study of second-order arithmetic and Peano arithmetic, as well as formal theories of the natural numbers weaker than Peano arithmetic. One method of classifying the strength of these weak systems is by characterizing which computable functions the system can prove to be total. For example, in primitive recursive arithmetic any computable function that is provably total is actually primitive recursive, while Peano arithmetic proves that functions like the Ackermann function, which are not primitive recursive, are total. Not every total computable function is provably total in Peano arithmetic, however; an example of such a function is provided by Goodstein's theorem. == Name == The field of mathematical logic dealing with computability and its generalizations has been called \"recursion theory\" since its early days. Robert I. Soare, a prominent researcher in the field, has proposed that the field should be called \"computability theory\" instead. He argues that Turing's terminology using the word \"computable\" is more natural and more widely understood than the terminology using the word \"recursive\" introduced by Kleene. Many contemporary researchers have begun to use this alternate terminology. These researchers also use terminology such as partial computable function and computably enumerable (c.e.) set instead of partial recursive function and recursively enumerable (r.e.) set. Not all researchers have been convinced, however, as explained by Fortnow and Simpson. Some commentators argue that both the names recursion theory and computability theory fail to convey the fact that most of the objects studied in computability theory are not computable. In 1967, Rogers has suggested that a key property of computability theory is that its results and structures should be invariant under computable bijections on the natural numbers (this suggestion draws on the ideas of the Erlangen program in geometry). The idea is that a computable bijection merely renames numbers in a set, rather than indicating any structure in the set, much as a rotation of the Euclidean plane does not change any geometric aspect of lines drawn on it. Since any two infinite computable sets are linked by a computable bijection, this proposal identifies all the infinite computable sets (the finite computable sets are viewed as trivial). According to Rogers, the sets of interest in computability theory are the noncomputable sets, partitioned into equivalence classes by computable bijections of the natural numbers. == Professional organizations == The main professional organization for computability theory is the Association for Symbolic Logic, which holds several research conferences each year. The interdisciplinary research Association Computability in Europe (CiE) also organizes a series of annual conferences. == See also == Recursion (computer science) Computability logic Transcomputational problem == Notes == == References == == Further reading == Undergraduate level texts Cooper, S. Barry (2004). Computability Theory. Chapman & Hall/CRC. ISBN 1-58488-237-9. Matiyasevich, Yuri Vladimirovich (1993). Hilbert's Tenth Problem. MIT Press. ISBN 0-262-13295-8. Advanced texts Jain, Sanjay; Osherson, Daniel Nathan; Royer, James S.; Sharma, Arun (1999). Systems that learn: an introduction to learning theory (2nd ed.). Bradford Book / MIT Press. ISBN 0-262-10077-0. LCCN 98-34861. Lerman, Manuel (1983). Degrees of unsolvability. Perspectives in Mathematical Logic. Springer-Verlag. ISBN 3-540-12155-2. Nies, André (2009). Computability and Randomness. Oxford University Press. ISBN 978-0-19-923076-1. Odifreddi, Piergiorgio (1989). Classical Recursion Theory. North-Holland. ISBN 0-444-87295-7. Odifreddi, Piergiorgio (1999). Classical Recursion Theory. Vol. II. Elsevier. ISBN 0-444-50205-X. Survey papers and collections Enderton, Herbert Bruce (1977). \"Elements of Recursion Theory\". In Barwise, Jon (ed.). Handbook of Mathematical Logic. North-Holland. pp. 527–566. ISBN 0-7204-2285-X. Research papers and collections Burgin, Mark; Klinger, Allen (2004). \"Experience, Generations, and Limits in Machine Learning\". Theoretical Computer Science. 317 (1–3): 71–91. doi:10.1016/j.tcs.2003.12.005. Friedberg, Richard M. (1958). \"Three theorems on recursive enumeration: I. Decomposition, II. Maximal Set, III. Enumeration without repetition\". The Journal of Symbolic Logic. 23 (3): 309–316. doi:10.2307/2964290. JSTOR 2964290. S2CID 25834814. Gold, E. Mark (1967). \"Language Identification in the Limit\" (PDF). Information and Control. 10 (5): 447–474. doi:10.1016/s0019-9958(67)91165-5.  Jockusch, Carl Groos Jr. (1968). \"Semirecursive sets and positive reducibility\". Transactions of the American Mathematical Society. 137 (2): 420–436. doi:10.1090/S0002-9947-1968-0220595-7. JSTOR 1994957. Kleene, Stephen Cole; Post, Emil Leon (1954). \"The upper semi-lattice of degrees of recursive unsolvability\". Annals of Mathematics. Series 2. 59 (3): 379–407. doi:10.2307/1969708. JSTOR 1969708. Myhill, John R. Sr. (1956). \"The lattice of recursively enumerable sets\". The Journal of Symbolic Logic. 21: 215–220. doi:10.1017/S002248120008525X. S2CID 123260425. Post, Emil Leon (1947). \"Recursive unsolvability of a problem of Thue\". Journal of Symbolic Logic. 12 (1): 1–11. doi:10.2307/2267170. JSTOR 2267170. S2CID 30320278. Reprinted in Davis 1965. == External links == Association for Symbolic Logic homepage Computability in Europe homepage Archived 2011-02-17 at the Wayback Machine Webpage on Recursion Theory Course at Graduate Level with approximately 100 pages of lecture notes German language lecture notes on inductive inference"
  },
  "chunks": [
    {
      "id": "computabilitytheory_f9e944f3_c0000",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 985,
      "content": "Computability theory, also known as recursion theory, is a branch of mathematical logic, computer science, and the theory of computation that originated in the 1930s with the study of computable functions and Turing degrees. The field has since expanded to include the study of generalized computability and definability. In these areas, computability theory overlaps with proof theory and effective descriptive set theory. Basic questions addressed by computability theory include: What does it mean for a function on the natural numbers to be computable? How can noncomputable functions be classified into a hierarchy based on their level of noncomputability? Although there is considerable overlap in terms of knowledge and methods, mathematical computability theorists study the theory of relative computability, reducibility notions, and degree structures; those in the computer science field focus on the theory of subrecursive hierarchies, formal methods, and formal languages.",
      "char_count": 984,
      "token_estimate": 246,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0001",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Introduction ==",
      "heading_path": "== Introduction ==",
      "start_char": 1121,
      "end_char": 1943,
      "content": "== Introduction == Computability theory originated in the 1930s, with the work of Kurt Gödel, Alonzo Church, Rózsa Péter, Alan Turing, Stephen Kleene, and Emil Post. The fundamental results the researchers obtained established Turing computability as the correct formalization of the informal idea of effective calculation. In 1952, these results led Kleene to coin the two names \"Church's thesis\" and \"Turing's thesis\". Nowadays these are often considered as a single hypothesis, the Church–Turing thesis, which states that any function that is computable by an algorithm is a computable function. Although initially skeptical, by 1946 Gödel argued in favor of this thesis: \"Tarski has stressed in his lecture (and I think justly) the great importance of the concept of general recursiveness (or Turing's computability).",
      "char_count": 821,
      "token_estimate": 205,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0002",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Introduction ==",
      "heading_path": "== Introduction ==",
      "start_char": 1943,
      "end_char": 2923,
      "content": "It seems to me that this importance is largely due to the fact that with this concept one has for the first time succeeded in giving an absolute notion to an interesting epistemological notion, i.e., one not depending on the formalism chosen.\" With a definition of effective calculation came the first proofs that there are problems in mathematics that cannot be effectively decided. In 1936, Church and Turing were inspired by techniques used by Gödel to prove his incompleteness theorems - in 1931, Gödel independently demonstrated that the Entscheidungsproblem is not effectively decidable. This result showed that there is no algorithmic procedure that can correctly decide whether arbitrary mathematical propositions are true or false. Many problems in mathematics have been shown to be undecidable after these initial examples were established. In 1947, Markov and Post published independent papers showing that the word problem for semigroups cannot be effectively decided.",
      "char_count": 980,
      "token_estimate": 245,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0003",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Introduction ==",
      "heading_path": "== Introduction ==",
      "start_char": 2924,
      "end_char": 3562,
      "content": "Extending this result, Pyotr Novikov and William Boone showed independently in the 1950s that the word problem for groups is not effectively solvable: there is no effective procedure that, given a word in a finitely presented group, will decide whether the element represented by the word is the identity element of the group. In 1970, Yuri Matiyasevich proved (using results of Julia Robinson) Matiyasevich's theorem, which implies that Hilbert's tenth problem has no effective solution; this problem asked whether there is an effective procedure to decide whether a Diophantine equation over the integers has a solution in the integers.",
      "char_count": 638,
      "token_estimate": 159,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0004",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Turing computability ==",
      "heading_path": "== Turing computability ==",
      "start_char": 3571,
      "end_char": 4444,
      "content": "== Turing computability == The main form of computability studied in the field was introduced by Turing in 1936. A set of natural numbers is said to be a computable set (also called a decidable, recursive, or Turing computable set) if there is a Turing machine that, given a number n, halts with output 1 if n is in the set and halts with output 0 if n is not in the set. A function f from natural numbers to natural numbers is a (Turing) computable, or recursive function if there is a Turing machine that, on input n, halts and returns output f(n). The use of Turing machines here is not necessary; there are many other models of computation that have the same computing power as Turing machines; for example the μ-recursive functions obtained from primitive recursion and the μ operator. The terminology for computable functions and sets is not completely standardized.",
      "char_count": 872,
      "token_estimate": 218,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0005",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Turing computability ==",
      "heading_path": "== Turing computability ==",
      "start_char": 4444,
      "end_char": 5375,
      "content": "The definition in terms of μ-recursive functions as well as a different definition of rekursiv functions by Gödel led to the traditional name recursive for sets and functions computable by a Turing machine. The word decidable stems from the German word Entscheidungsproblem which was used in the original papers of Turing and others. In contemporary use, the term \"computable function\" has various definitions: according to Nigel J. Cutland, it is a partial recursive function (which can be undefined for some inputs), while according to Robert I. Soare it is a total recursive (equivalently, general recursive) function. This article follows the second of these conventions. In 1996, Soare gave additional comments about the terminology. Not every set of natural numbers is computable. The halting problem, which is the set of (descriptions of) Turing machines that halt on input 0, is a well-known example of a noncomputable set.",
      "char_count": 931,
      "token_estimate": 232,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0006",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Turing computability ==",
      "heading_path": "== Turing computability ==",
      "start_char": 5376,
      "end_char": 6197,
      "content": "The existence of many noncomputable sets follows from the facts that there are only countably many Turing machines, and thus only countably many computable sets, but according to the Cantor's theorem, there are uncountably many sets of natural numbers. Although the halting problem is not computable, it is possible to simulate program execution and produce an infinite list of the programs that do halt. Thus the halting problem is an example of a computably enumerable (c.e.) set, which is a set that can be enumerated by a Turing machine (other terms for computably enumerable include recursively enumerable and semidecidable). Equivalently, a set is c.e. if and only if it is the range of some computable function. The c.e. sets, although not decidable in general, have been studied in detail in computability theory.",
      "char_count": 821,
      "token_estimate": 205,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0007",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Areas of research ==",
      "heading_path": "== Areas of research ==",
      "start_char": 6195,
      "end_char": 6548,
      "content": "== Areas of research == Beginning with the theory of computable sets and functions described above, the field of computability theory has grown to include the study of many closely related topics. These are not independent areas of research: each of these areas draws ideas and results from the others, and most computability theorists are familiar with the majority of them.",
      "char_count": 375,
      "token_estimate": 93,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0008",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Relative computability and the Turing degrees ==",
      "heading_path": "== = Relative computability and the Turing degrees ==",
      "start_char": 6601,
      "end_char": 7375,
      "content": "== = Relative computability and the Turing degrees === Computability theory in mathematical logic has traditionally focused on relative computability, a generalization of Turing computability defined using oracle Turing machines, introduced by Turing in 1939. An oracle Turing machine is a hypothetical device which, in addition to performing the actions of a regular Turing machine, is able to ask questions of an oracle, which is a particular set of natural numbers. The oracle machine may only ask questions of the form \"Is n in the oracle set?\". Each question will be immediately answered correctly, even if the oracle set is not computable. Thus an oracle machine with a noncomputable oracle will be able to compute sets that a Turing machine without an oracle cannot.",
      "char_count": 773,
      "token_estimate": 193,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0009",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Relative computability and the Turing degrees ==",
      "heading_path": "== = Relative computability and the Turing degrees ==",
      "start_char": 7375,
      "end_char": 8327,
      "content": "Informally, a set of natural numbers A is Turing reducible to a set B if there is an oracle machine that correctly tells whether numbers are in A when run with B as the oracle set (in this case, the set A is also said to be (relatively) computable from B and recursive in B). If a set A is Turing reducible to a set B and B is Turing reducible to A then the sets are said to have the same Turing degree (also called degree of unsolvability). The Turing degree of a set gives a precise measure of how uncomputable the set is. The natural examples of sets that are not computable, including many different sets that encode variants of the halting problem, have two properties in common: They are computably enumerable, and Each can be translated into any other via a many-one reduction. That is, given such sets A and B, there is a total computable function f such that A = {x : f(x) ∈ B}. These sets are said to be many-one equivalent (or m-equivalent).",
      "char_count": 952,
      "token_estimate": 238,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0010",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Relative computability and the Turing degrees ==",
      "heading_path": "== = Relative computability and the Turing degrees ==",
      "start_char": 8328,
      "end_char": 9208,
      "content": "Many-one reductions are \"stronger\" than Turing reductions: if a set A is many-one reducible to a set B, then A is Turing reducible to B, but the converse does not always hold. Although the natural examples of noncomputable sets are all many-one equivalent, it is possible to construct computably enumerable sets A and B such that A is Turing reducible to B but not many-one reducible to B. It can be shown that every computably enumerable set is many-one reducible to the halting problem, and thus the halting problem is the most complicated computably enumerable set with respect to many-one reducibility and with respect to Turing reducibility. In 1944, Post asked whether every computably enumerable set is either computable or Turing equivalent to the halting problem, that is, whether there is no computably enumerable set with a Turing degree intermediate between those two.",
      "char_count": 880,
      "token_estimate": 220,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0011",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Relative computability and the Turing degrees ==",
      "heading_path": "== = Relative computability and the Turing degrees ==",
      "start_char": 9209,
      "end_char": 10171,
      "content": "As intermediate results, Post defined natural types of computably enumerable sets like the simple, hypersimple and hyperhypersimple sets. Post showed that these sets are strictly between the computable sets and the halting problem with respect to many-one reducibility. Post also showed that some of them are strictly intermediate under other reducibility notions stronger than Turing reducibility. But Post left open the main problem of the existence of computably enumerable sets of intermediate Turing degree; this problem became known as Post's problem. After ten years, Kleene and Post showed in 1954 that there are intermediate Turing degrees between those of the computable sets and the halting problem, but they failed to show that any of these degrees contains a computably enumerable set. Very soon after this, Friedberg and Muchnik independently solved Post's problem by establishing the existence of computably enumerable sets of intermediate degree.",
      "char_count": 962,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0012",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Relative computability and the Turing degrees ==",
      "heading_path": "== = Relative computability and the Turing degrees ==",
      "start_char": 10172,
      "end_char": 11123,
      "content": "This groundbreaking result opened a wide study of the Turing degrees of the computably enumerable sets which turned out to possess a very complicated and non-trivial structure. There are uncountably many sets that are not computably enumerable, and the investigation of the Turing degrees of all sets is as central in computability theory as the investigation of the computably enumerable Turing degrees. Many degrees with special properties were constructed: hyperimmune-free degrees where every function computable relative to that degree is majorized by a (unrelativized) computable function; high degrees relative to which one can compute a function f which dominates every computable function g in the sense that there is a constant c depending on g such that g(x) < f(x) for all x > c; random degrees containing algorithmically random sets; 1-generic degrees of 1-generic sets; and the degrees below the halting problem of limit-computable sets.",
      "char_count": 951,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0013",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Relative computability and the Turing degrees ==",
      "heading_path": "== = Relative computability and the Turing degrees ==",
      "start_char": 11124,
      "end_char": 12011,
      "content": "The study of arbitrary (not necessarily computably enumerable) Turing degrees involves the study of the Turing jump. Given a set A, the Turing jump of A is a set of natural numbers encoding a solution to the halting problem for oracle Turing machines running with oracle A. The Turing jump of any set is always of higher Turing degree than the original set, and a theorem of Friedburg shows that any set that computes the Halting problem can be obtained as the Turing jump of another set. Post's theorem establishes a close relationship between the Turing jump operation and the arithmetical hierarchy, which is a classification of certain subsets of the natural numbers based on their definability in arithmetic. Much recent research on Turing degrees has focused on the overall structure of the set of Turing degrees and the set of Turing degrees containing computably enumerable sets.",
      "char_count": 887,
      "token_estimate": 221,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0014",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Relative computability and the Turing degrees ==",
      "heading_path": "== = Relative computability and the Turing degrees ==",
      "start_char": 12012,
      "end_char": 12281,
      "content": "A deep theorem of Shore and Slaman states that the function mapping a degree x to the degree of its Turing jump is definable in the partial order of the Turing degrees. A survey by Ambos-Spies and Fejer gives an overview of this research and its historical progression.",
      "char_count": 269,
      "token_estimate": 67,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0015",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Other reducibilities ==",
      "heading_path": "== = Other reducibilities ==",
      "start_char": 12257,
      "end_char": 13219,
      "content": "== = Other reducibilities === An ongoing area of research in computability theory studies reducibility relations other than Turing reducibility. Post introduced several strong reducibilities, so named because they imply truth-table reducibility. A Turing machine implementing a strong reducibility will compute a total function regardless of which oracle it is presented with. Weak reducibilities are those where a reduction process may not terminate for all oracles; Turing reducibility is one example. The strong reducibilities include: One-one reducibility: A is one-one reducible (or 1-reducible) to B if there is a total computable injective function f such that each n is in A if and only if f(n) is in B. Many-one reducibility: This is essentially one-one reducibility without the constraint that f be injective. A is many-one reducible (or m-reducible) to B if there is a total computable function f such that each n is in A if and only if f(n) is in B.",
      "char_count": 961,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0016",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Other reducibilities ==",
      "heading_path": "== = Other reducibilities ==",
      "start_char": 13219,
      "end_char": 14176,
      "content": "Truth-table reducibility: A is truth-table reducible to B if A is Turing reducible to B via an oracle Turing machine that computes a total function regardless of the oracle it is given. Because of compactness of Cantor space, this is equivalent to saying that the reduction presents a single list of questions (depending only on the input) to the oracle simultaneously, and then having seen their answers is able to produce an output without asking additional questions regardless of the oracle's answer to the initial queries. Many variants of truth-table reducibility have also been studied. Further reducibilities (positive, disjunctive, conjunctive, linear and their weak and bounded versions) are discussed in the article Reduction (computability theory). The major research on strong reducibilities has been to compare their theories, both for the class of all computably enumerable sets as well as for the class of all subsets of the natural numbers.",
      "char_count": 957,
      "token_estimate": 239,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0017",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Other reducibilities ==",
      "heading_path": "== = Other reducibilities ==",
      "start_char": 14177,
      "end_char": 14706,
      "content": "Furthermore, the relations between the reducibilities has been studied. For example, it is known that every Turing degree is either a truth-table degree or is the union of infinitely many truth-table degrees. Reducibilities weaker than Turing reducibility (that is, reducibilities that are implied by Turing reducibility) have also been studied. The most well known are arithmetical reducibility and hyperarithmetical reducibility. These reducibilities are closely connected to definability over the standard model of arithmetic.",
      "char_count": 529,
      "token_estimate": 132,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0018",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Rice's theorem and the arithmetical hierarchy ==",
      "heading_path": "== = Rice's theorem and the arithmetical hierarchy ==",
      "start_char": 14732,
      "end_char": 15558,
      "content": "== = Rice's theorem and the arithmetical hierarchy === Rice showed that for every nontrivial class C (which contains some but not all c.e. sets) the index set E = {e: the eth c.e. set We is in C} has the property that either the halting problem or its complement is many-one reducible to E, that is, can be mapped using a many-one reduction to E (see Rice's theorem for more detail). But, many of these index sets are even more complicated than the halting problem. These type of sets can be classified using the arithmetical hierarchy. For example, the index set FIN of the class of all finite sets is on the level Σ2, the index set REC of the class of all recursive sets is on the level Σ3, the index set COFIN of all cofinite sets is also on the level Σ3 and the index set COMP of the class of all Turing-complete sets Σ4.",
      "char_count": 825,
      "token_estimate": 206,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0019",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Rice's theorem and the arithmetical hierarchy ==",
      "heading_path": "== = Rice's theorem and the arithmetical hierarchy ==",
      "start_char": 15558,
      "end_char": 15874,
      "content": "These hierarchy levels are defined inductively, Σn+1 contains just all sets which are computably enumerable relative to Σn; Σ1 contains the computably enumerable sets. The index sets given here are even complete for their levels, that is, all the sets in these levels can be many-one reduced to the given index sets.",
      "char_count": 316,
      "token_estimate": 79,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0020",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Reverse mathematics ==",
      "heading_path": "== = Reverse mathematics ==",
      "start_char": 15849,
      "end_char": 16508,
      "content": "== = Reverse mathematics === The program of reverse mathematics asks which set-existence axioms are necessary to prove particular theorems of mathematics in subsystems of second-order arithmetic. This study was initiated by Harvey Friedman and was studied in detail by Stephen Simpson and others; in 1999, Simpson gave a detailed discussion of the program. The set-existence axioms in question correspond informally to axioms saying that the powerset of the natural numbers is closed under various reducibility notions. The weakest such axiom studied in reverse mathematics is recursive comprehension, which states that the powerset of the naturals is closed under Turing reducibility.",
      "char_count": 685,
      "token_estimate": 171,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0021",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Numberings ==",
      "heading_path": "== = Numberings ==",
      "start_char": 16526,
      "end_char": 17278,
      "content": "== = Numberings === A numbering is an enumeration of functions; it has two parameters, e and x and outputs the value of the e-th function in the numbering on the input x. Numberings can be partial-computable although some of its members are total computable functions. Admissible numberings are those into which all others can be translated. A Friedberg numbering (named after its discoverer) is a one-one numbering of all partial-computable functions; it is necessarily not an admissible numbering. Later research dealt also with numberings of other classes like classes of computably enumerable sets. Goncharov discovered for example a class of computably enumerable sets for which the numberings fall into exactly two classes with respect to computable isomorphisms.",
      "char_count": 769,
      "token_estimate": 192,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0022",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = The priority method ==",
      "heading_path": "== = The priority method ==",
      "start_char": 17305,
      "end_char": 18212,
      "content": "== = The priority method === Post's problem was solved with a method called the priority method; a proof using this method is called a priority argument. This method is primarily used to construct computably enumerable sets with particular properties. To use this method, the desired properties of the set to be constructed are broken up into an infinite list of goals, known as requirements, so that satisfying all the requirements will cause the set constructed to have the desired properties. Each requirement is assigned to a natural number representing the priority of the requirement; so 0 is assigned to the most important priority, 1 to the second most important, and so on. The set is then constructed in stages, each stage attempting to satisfy one of more of the requirements by either adding numbers to the set or banning numbers from the set so that the final set will satisfy the requirement.",
      "char_count": 906,
      "token_estimate": 226,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0023",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = The priority method ==",
      "heading_path": "== = The priority method ==",
      "start_char": 18212,
      "end_char": 18900,
      "content": "It may happen that satisfying one requirement will cause another to become unsatisfied; the priority order is used to decide what to do in such an event. Priority arguments have been employed to solve many problems in computability theory, and have been classified into a hierarchy based on their complexity. Because complex priority arguments can be technical and difficult to follow, it has traditionally been considered desirable to prove results without priority arguments, or to see if results proved with priority arguments can also be proved without them. For example, Kummer published a paper on a proof for the existence of Friedberg numberings without using the priority method.",
      "char_count": 688,
      "token_estimate": 172,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0024",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = The lattice of computably enumerable sets ==",
      "heading_path": "== = The lattice of computably enumerable sets ==",
      "start_char": 18923,
      "end_char": 19774,
      "content": "== = The lattice of computably enumerable sets === When Post defined the notion of a simple set as a c.e. set with an infinite complement not containing any infinite c.e. set, he started to study the structure of the computably enumerable sets under inclusion. This lattice became a well-studied structure. Computable sets can be defined in this structure by the basic result that a set is computable if and only if the set and its complement are both computably enumerable. Infinite c.e. sets have always infinite computable subsets; but on the other hand, simple sets exist but do not always have a coinfinite computable superset. Post introduced already hypersimple and hyperhypersimple sets; later maximal sets were constructed which are c.e. sets such that every c.e. superset is either a finite variant of the given maximal set or is co-finite.",
      "char_count": 850,
      "token_estimate": 212,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0025",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = The lattice of computably enumerable sets ==",
      "heading_path": "== = The lattice of computably enumerable sets ==",
      "start_char": 19774,
      "end_char": 20179,
      "content": "Post's original motivation in the study of this lattice was to find a structural notion such that every set which satisfies this property is neither in the Turing degree of the computable sets nor in the Turing degree of the halting problem. Post did not find such a property and the solution to his problem applied priority methods instead; in 1991, Harrington and Soare found eventually such a property.",
      "char_count": 405,
      "token_estimate": 101,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0026",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Automorphism problems ==",
      "heading_path": "== = Automorphism problems ==",
      "start_char": 20160,
      "end_char": 21033,
      "content": "== = Automorphism problems === Another important question is the existence of automorphisms in computability-theoretic structures. One of these structures is that one of computably enumerable sets under inclusion modulo finite difference; in this structure, A is below B if and only if the set difference B − A is finite. Maximal sets (as defined in the previous paragraph) have the property that they cannot be automorphic to non-maximal sets, that is, if there is an automorphism of the computably enumerable sets under the structure just mentioned, then every maximal set is mapped to another maximal set. In 1974, Soare showed that also the converse holds, that is, every two maximal sets are automorphic. So the maximal sets form an orbit, that is, every automorphism preserves maximality and any two maximal sets are transformed into each other by some automorphism.",
      "char_count": 872,
      "token_estimate": 218,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0027",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Automorphism problems ==",
      "heading_path": "== = Automorphism problems ==",
      "start_char": 21033,
      "end_char": 21762,
      "content": "Harrington gave a further example of an automorphic property: that of the creative sets, the sets which are many-one equivalent to the halting problem. Besides the lattice of computably enumerable sets, automorphisms are also studied for the structure of the Turing degrees of all sets as well as for the structure of the Turing degrees of c.e. sets. In both cases, Cooper claims to have constructed nontrivial automorphisms which map some degrees to other degrees; this construction has, however, not been verified and some colleagues believe that the construction contains errors and that the question of whether there is a nontrivial automorphism of the Turing degrees is still one of the main unsolved questions in this area.",
      "char_count": 729,
      "token_estimate": 182,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0028",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Kolmogorov complexity ==",
      "heading_path": "== = Kolmogorov complexity ==",
      "start_char": 21763,
      "end_char": 22682,
      "content": "== = Kolmogorov complexity === The field of Kolmogorov complexity and algorithmic randomness was developed during the 1960s and 1970s by Chaitin, Kolmogorov, Levin, Martin-Löf and Solomonoff (the names are given here in alphabetical order; much of the research was independent, and the unity of the concept of randomness was not understood at the time). The main idea is to consider a universal Turing machine U and to measure the complexity of a number (or string) x as the length of the shortest input p such that U(p) outputs x. This approach revolutionized earlier ways to determine when an infinite sequence (equivalently, characteristic function of a subset of the natural numbers) is random or not by invoking a notion of randomness for finite objects. Kolmogorov complexity became not only a subject of independent study but is also applied to other subjects as a tool for obtaining proofs. There are still many open problems in this area.",
      "char_count": 947,
      "token_estimate": 236,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0029",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Frequency computation ==",
      "heading_path": "== = Frequency computation ==",
      "start_char": 22711,
      "end_char": 23680,
      "content": "== = Frequency computation === This branch of computability theory analyzed the following question: For fixed m and n with 0 < m < n, for which functions A is it possible to compute for any different n inputs x1, x2, ..., xn a tuple of n numbers y1, y2, ..., yn such that at least m of the equations A(xk) = yk are true. Such sets are known as (m, n)-recursive sets. The first major result in this branch of computability theory is Trakhtenbrot's result that a set is computable if it is (m, n)-recursive for some m, n with 2m > n. On the other hand, Jockusch's semirecursive sets (which were already known informally before Jockusch introduced them 1968) are examples of a set which is (m, n)-recursive if and only if 2m < n + 1. There are uncountably many of these sets and also some computably enumerable but noncomputable sets of this type. Later, Degtev established a hierarchy of computably enumerable sets that are (1, n + 1)-recursive but not (1, n)-recursive.",
      "char_count": 968,
      "token_estimate": 242,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0030",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Frequency computation ==",
      "heading_path": "== = Frequency computation ==",
      "start_char": 23680,
      "end_char": 24306,
      "content": "After a long phase of research by Russian scientists, this subject became repopularized in the west by Beigel's thesis on bounded queries, which linked frequency computation to the above-mentioned bounded reducibilities and other related notions. One of the major results was Kummer's Cardinality Theory which states that a set A is computable if and only if there is an n such that some algorithm enumerates for each tuple of n different numbers up to n many possible choices of the cardinality of this set of n numbers intersected with A; these choices must contain the true cardinality but leave out at least one false one.",
      "char_count": 626,
      "token_estimate": 156,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0031",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Inductive inference ==",
      "heading_path": "== = Inductive inference ==",
      "start_char": 24305,
      "end_char": 25261,
      "content": "== = Inductive inference === This is the computability-theoretic branch of learning theory. It is based on E. Mark Gold's model of learning in the limit from 1967 and has developed since then more and more models of learning. The general scenario is the following: Given a class S of computable functions, is there a learner (that is, computable functional) which outputs for any input of the form (f(0), f(1), ..., f(n)) a hypothesis. A learner M learns a function f if almost all hypotheses are the same index e of f with respect to a previously agreed on acceptable numbering of all computable functions; M learns S if M learns every f in S. Basic results are that all computably enumerable classes of functions are learnable while the class REC of all computable functions is not learnable. Many related models have been considered and also the learning of classes of computably enumerable sets from positive data is a topic studied from Gold's pioneering paper in 1967 onwards.",
      "char_count": 982,
      "token_estimate": 245,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0032",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Generalizations of Turing computability ==",
      "heading_path": "== = Generalizations of Turing computability ==",
      "start_char": 25308,
      "end_char": 26193,
      "content": "== = Generalizations of Turing computability === Computability theory includes the study of generalized notions of this field such as arithmetic reducibility, hyperarithmetical reducibility and α-recursion theory, as described by Sacks in 1990. These generalized notions include reducibilities that cannot be executed by Turing machines but are nevertheless natural generalizations of Turing reducibility. These studies include approaches to investigate the analytical hierarchy which differs from the arithmetical hierarchy by permitting quantification over sets of natural numbers in addition to quantification over individual numbers. These areas are linked to the theories of well-orderings and trees; for example the set of all indices of computable (nonbinary) trees without infinite branches is complete for level Π 1 1 {\\displaystyle \\Pi _{1}^{1}} of the analytical hierarchy.",
      "char_count": 884,
      "token_estimate": 221,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0033",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Generalizations of Turing computability ==",
      "heading_path": "== = Generalizations of Turing computability ==",
      "start_char": 26193,
      "end_char": 26402,
      "content": "Both Turing reducibility and hyperarithmetical reducibility are important in the field of effective descriptive set theory. The even more general notion of degrees of constructibility is studied in set theory.",
      "char_count": 209,
      "token_estimate": 52,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0034",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== = Continuous computability theory ==",
      "heading_path": "== = Continuous computability theory ==",
      "start_char": 26395,
      "end_char": 26858,
      "content": "== = Continuous computability theory === Computability theory for digital computation is well developed. Computability theory is less well developed for analog computation that occurs in analog computers, analog signal processing, analog electronics, artificial neural networks and continuous-time control theory, modelled by differential equations and continuous dynamical systems. For example, models of computation such as the Blum–Shub–Smale machine model have formalized computation on the reals.",
      "char_count": 501,
      "token_estimate": 125,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0035",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Relationships between definability, proof and computability ==",
      "heading_path": "== Relationships between definability, proof and computability ==",
      "start_char": 26923,
      "end_char": 27810,
      "content": "== Relationships between definability, proof and computability == There are close relationships between the Turing degree of a set of natural numbers and the difficulty (in terms of the arithmetical hierarchy) of defining that set using a first-order formula. One such relationship is made precise by Post's theorem. A weaker relationship was demonstrated by Kurt Gödel in the proofs of his completeness theorem and incompleteness theorems. Gödel's proofs show that the set of logical consequences of an effective first-order theory is a computably enumerable set, and that if the theory is strong enough this set will be uncomputable. Similarly, Tarski's indefinability theorem can be interpreted both in terms of definability and in terms of computability. Computability theory is also linked to second-order arithmetic, a formal theory of natural numbers and sets of natural numbers.",
      "char_count": 886,
      "token_estimate": 221,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0036",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Relationships between definability, proof and computability ==",
      "heading_path": "== Relationships between definability, proof and computability ==",
      "start_char": 27810,
      "end_char": 28760,
      "content": "The fact that certain sets are computable or relatively computable often implies that these sets can be defined in weak subsystems of second-order arithmetic. The program of reverse mathematics uses these subsystems to measure the non-computability inherent in well known mathematical theorems. In 1999, Simpson discussed many aspects of second-order arithmetic and reverse mathematics. The field of proof theory includes the study of second-order arithmetic and Peano arithmetic, as well as formal theories of the natural numbers weaker than Peano arithmetic. One method of classifying the strength of these weak systems is by characterizing which computable functions the system can prove to be total. For example, in primitive recursive arithmetic any computable function that is provably total is actually primitive recursive, while Peano arithmetic proves that functions like the Ackermann function, which are not primitive recursive, are total.",
      "char_count": 950,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0037",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Name ==",
      "heading_path": "== Name ==",
      "start_char": 28856,
      "end_char": 29667,
      "content": "== Name == The field of mathematical logic dealing with computability and its generalizations has been called \"recursion theory\" since its early days. Robert I. Soare, a prominent researcher in the field, has proposed that the field should be called \"computability theory\" instead. He argues that Turing's terminology using the word \"computable\" is more natural and more widely understood than the terminology using the word \"recursive\" introduced by Kleene. Many contemporary researchers have begun to use this alternate terminology. These researchers also use terminology such as partial computable function and computably enumerable (c.e.) set instead of partial recursive function and recursively enumerable (r.e.) set. Not all researchers have been convinced, however, as explained by Fortnow and Simpson.",
      "char_count": 810,
      "token_estimate": 202,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0038",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Name ==",
      "heading_path": "== Name ==",
      "start_char": 29667,
      "end_char": 30517,
      "content": "Some commentators argue that both the names recursion theory and computability theory fail to convey the fact that most of the objects studied in computability theory are not computable. In 1967, Rogers has suggested that a key property of computability theory is that its results and structures should be invariant under computable bijections on the natural numbers (this suggestion draws on the ideas of the Erlangen program in geometry). The idea is that a computable bijection merely renames numbers in a set, rather than indicating any structure in the set, much as a rotation of the Euclidean plane does not change any geometric aspect of lines drawn on it. Since any two infinite computable sets are linked by a computable bijection, this proposal identifies all the infinite computable sets (the finite computable sets are viewed as trivial).",
      "char_count": 850,
      "token_estimate": 212,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "computabilitytheory_f9e944f3_c0039",
      "article_id": "computabilitytheory_f9e944f3",
      "section": "== Professional organizations ==",
      "heading_path": "== Professional organizations ==",
      "start_char": 30720,
      "end_char": 30992,
      "content": "== Professional organizations == The main professional organization for computability theory is the Association for Symbolic Logic, which holds several research conferences each year. The interdisciplinary research Association Computability in Europe (CiE) also organizes a series of annual conferences.",
      "char_count": 303,
      "token_estimate": 75,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 10,
    "items": [
      {
        "question": "What information is provided about Lead?",
        "answer": "The text provides information about Lead as described in the relevant chunks.",
        "related_chunk_ids": [
          "computabilitytheory_f9e944f3_c0000"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "computabilitytheory_f9e944f3_c0000"
        ]
      },
      {
        "question": "According to the basic results of inductive inference, what type of function classes are considered learnable?",
        "answer": "All computably enumerable classes of functions are considered learnable.",
        "related_chunk_ids": [
          "computabilitytheory_f9e944f3_c0031"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "computabilitytheory_f9e944f3_c0031"
        ]
      },
      {
        "question": "In what year did Markov and Post publish independent papers showing that the word problem for semigroups is undecidable?",
        "answer": "In 1947, Markov and Post published independent papers demonstrating that the word problem for semigroups cannot be effectively decided.",
        "related_chunk_ids": [
          "computabilitytheory_f9e944f3_c0002"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "computabilitytheory_f9e944f3_c0002"
        ]
      },
      {
        "question": "How did the formalization of computability in the 1930s lead to the discovery of undecidable problems in mathematics?",
        "answer": "In the 1930s, researchers including Kurt Gödel, Alonzo Church, and Alan Turing established Turing computability as the formal definition for effective calculation, a concept later known as the Church-Turing thesis. Once this absolute definition of computability was established, it became possible for the first time to prove that certain problems could not be decided by any effective, algorithmic procedure. This led directly to proofs of undecidability, such as the 1936 demonstration by Church and Turing that the Entscheidungsproblem is undecidable.",
        "related_chunk_ids": [
          "computabilitytheory_f9e944f3_c0000",
          "computabilitytheory_f9e944f3_c0001",
          "computabilitytheory_f9e944f3_c0002"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "computabilitytheory_f9e944f3_c0001",
          "computabilitytheory_f9e944f3_c0002",
          "computabilitytheory_f9e944f3_c0000"
        ]
      },
      {
        "question": "How does the concept of an 'effective procedure,' as mentioned in relation to Hilbert's tenth problem, connect to the formal definition of Turing computability?",
        "answer": "The informal concept of an 'effective procedure' is formalized by the model of Turing computability. Problems like Hilbert's tenth problem, which were proven to have no 'effective solution,' are considered noncomputable. This means there is no Turing machine that can consistently halt and provide a correct yes/no answer for every instance of the problem, which is the formal definition of a computable or decidable problem. Therefore, the lack of an 'effective procedure' signifies that a problem is noncomputable.",
        "related_chunk_ids": [
          "computabilitytheory_f9e944f3_c0003",
          "computabilitytheory_f9e944f3_c0004",
          "computabilitytheory_f9e944f3_c0005"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "computabilitytheory_f9e944f3_c0003",
          "computabilitytheory_f9e944f3_c0004",
          "computabilitytheory_f9e944f3_c0005"
        ]
      },
      {
        "question": "How does the concept of relative computability, using oracle Turing machines, address the limitations of standard Turing machines with respect to noncomputable sets?",
        "answer": "While standard Turing machines cannot solve certain noncomputable problems like the halting problem, the field of relative computability introduces oracle Turing machines to study these limitations. An oracle machine can consult an \"oracle\"—a specific set of natural numbers—and can compute sets that are noncomputable for a standard machine, provided the oracle itself is noncomputable. This allows for a more nuanced analysis of computability by examining what becomes computable when access to specific noncomputable information is granted.",
        "related_chunk_ids": [
          "computabilitytheory_f9e944f3_c0006",
          "computabilitytheory_f9e944f3_c0008"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "computabilitytheory_f9e944f3_c0008",
          "computabilitytheory_f9e944f3_c0006"
        ]
      },
      {
        "question": "Provide a chronological overview of the key undecidable problems in mathematics that were proven after the formalization of effective calculation.",
        "answer": "Following the formalization of effective calculation, the first major undecidable problem proven was the Entscheidungsproblem in 1936 by Church and Turing. In 1947, Markov and Post independently showed that the word problem for semigroups is undecidable. This was followed in the 1950s when Pyotr Novikov and William Boone proved that the word problem for groups is not effectively solvable. Finally, in 1970, Yuri Matiyasevich proved that Hilbert's tenth problem has no effective solution.",
        "related_chunk_ids": [
          "computabilitytheory_f9e944f3_c0001",
          "computabilitytheory_f9e944f3_c0002",
          "computabilitytheory_f9e944f3_c0003"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "computabilitytheory_f9e944f3_c0002",
          "computabilitytheory_f9e944f3_c0001",
          "computabilitytheory_f9e944f3_c0003"
        ]
      },
      {
        "question": "What is the distinction between a computable set and a computably enumerable set, and how does the halting problem illustrate this difference?",
        "answer": "A computable set is one for which a Turing machine can always determine membership for any given number, halting with an output of 1 if the number is in the set and 0 if it is not. In contrast, a computably enumerable (c.e.) set is one where a Turing machine can list all the members of the set, but it may not be able to definitively determine if an element is *not* in the set. The halting problem, which is the set of Turing machines that halt on input 0, exemplifies this. It is not a computable set, but it is computably enumerable because one can simulate program execution and produce an infinite list of the programs that do halt.",
        "related_chunk_ids": [
          "computabilitytheory_f9e944f3_c0004",
          "computabilitytheory_f9e944f3_c0005",
          "computabilitytheory_f9e944f3_c0006"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "computabilitytheory_f9e944f3_c0006",
          "computabilitytheory_f9e944f3_c0004",
          "computabilitytheory_f9e944f3_c0005"
        ]
      },
      {
        "question": "What was Post's problem, and what were the key steps leading to its resolution?",
        "answer": "Post's problem, posed in 1944, questioned whether any computably enumerable set exists with a Turing degree intermediate between that of computable sets and the halting problem. As an intermediate result, Post himself identified sets that were strictly between the computable sets and the halting problem with respect to many-one reducibility, which is stronger than Turing reducibility. A major step towards the solution occurred in 1954 when Kleene and Post showed that intermediate Turing degrees exist, but they failed to prove that any of these degrees contained a computably enumerable set. The problem was finally solved shortly after by Friedberg and Muchnik, who independently established the existence of computably enumerable sets of intermediate degree.",
        "related_chunk_ids": [
          "computabilitytheory_f9e944f3_c0010",
          "computabilitytheory_f9e944f3_c0011"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "computabilitytheory_f9e944f3_c0011",
          "computabilitytheory_f9e944f3_c0010"
        ]
      },
      {
        "question": "Distinguish between strong and weak reducibilities, providing examples of each type.",
        "answer": "Strong reducibilities are those that imply truth-table reducibility and are computed by a Turing machine that produces a total function for any given oracle. Examples include one-one reducibility, many-one reducibility, and truth-table reducibility. In contrast, weak reducibilities are those where the reduction process might not terminate for all oracles. Turing reducibility is an example of a weak reducibility, and other types, such as arithmetical and hyperarithmetical reducibility, are even weaker.",
        "related_chunk_ids": [
          "computabilitytheory_f9e944f3_c0015",
          "computabilitytheory_f9e944f3_c0016",
          "computabilitytheory_f9e944f3_c0017"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "computabilitytheory_f9e944f3_c0015",
          "computabilitytheory_f9e944f3_c0016",
          "computabilitytheory_f9e944f3_c0017"
        ]
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-31T06:36:50.725Z",
    "content_format": "markdown",
    "total_chunks": 40,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}