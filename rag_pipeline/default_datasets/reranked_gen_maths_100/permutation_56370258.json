{
  "article": {
    "id": "permutation_56370258",
    "title": "Permutation",
    "url": "https://en.wikipedia.org/wiki/Permutation",
    "lang": "en",
    "created_at": "2025-07-31T06:32:29.676208",
    "content": "---\nid: permutation_56370258\nurl: https://en.wikipedia.org/wiki/Permutation\ntitle: Permutation\nlang: en\ncreated_at: '2025-07-31T06:26:20.940932'\nchecksum: 2cc4aa57dadbe7607774a4df1ecf6f1e9b8dee11c0eba904b88e9c929b6db8d3\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 10228\n  char_count: 58196\n  num_chunks: 58\n  original_chunks: 68\n  filtered_out: 10\n  num_sections: 0\n---\nIn mathematics, a permutation of a set can mean one of two different things: an arrangement of its members in a sequence or linear order, or the act or process of changing the linear order of an ordered set. An example of the first meaning is the six permutations (orderings) of the set {1, 2, 3}: written as tuples, they are (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), and (3, 2, 1). Anagrams of a word whose letters are all different are also permutations: the letters are already ordered in the original word, and the anagram reorders them. The study of permutations of finite sets is an important topic in combinatorics and group theory. Permutations are used in almost every branch of mathematics and in many other fields of science. In computer science, they are used for analyzing sorting algorithms; in quantum physics, for describing states of particles; and in biology, for describing RNA sequences. The number of permutations of n distinct objects is n factorial, usually written as n!, which means the product of all positive integers less than or equal to n. According to the second meaning, a permutation of a set S is defined as a bijection from S to itself. That is, it is a function from S to S for which every element occurs exactly once as an image value. Such a function σ : S → S {\\displaystyle \\sigma :S\\to S} is equivalent to the rearrangement of the elements of S in which each element i is replaced by the corresponding σ ( i ) {\\displaystyle \\sigma (i)} . For example, the permutation (3, 1, 2) corresponds to the function σ {\\displaystyle \\sigma } defined as σ ( 1 ) = 3 , σ ( 2 ) = 1 , σ ( 3 ) = 2. {\\displaystyle \\sigma (1)=3,\\quad \\sigma (2)=1,\\quad \\sigma (3)=2.} The collection of all permutations of a set form a group called the symmetric group of the set. The group operation is the composition of functions (performing one rearrangement after the other), which results in another function (rearrangement). In elementary combinatorics, the k-permutations, or partial permutations, are the ordered arrangements of k distinct elements selected from a set. When k is equal to the size of the set, these are the permutations in the previous sense. == History == Permutation-like objects called hexagrams were used in China in the I Ching (Pinyin: Yi Jing) as early as 1000 BC. In Greece, Plutarch wrote that Xenocrates of Chalcedon (396–314 BC) discovered the number of different syllables possible in the Greek language. This would have been the first attempt on record to solve a difficult problem in permutations and combinations. Al-Khalil (717–786), an Arab mathematician and cryptographer, wrote the Book of Cryptographic Messages. It contains the first use of permutations and combinations, to list all possible Arabic words with and without vowels. The rule to determine the number of permutations of n objects was known in Indian culture around 1150 AD. The Lilavati by the Indian mathematician Bhāskara II contains a passage that translates as follows: The product of multiplication of the arithmetical series beginning and increasing by unity and continued to the number of places, will be the variations of number with specific figures. In 1677, Fabian Stedman described factorials when explaining the number of permutations of bells in change ringing. Starting from two bells: \"first, two must be admitted to be varied in two ways\", which he illustrates by showing 1 2 and 2 1. He then explains that with three bells there are \"three times two figures to be produced out of three\" which again is illustrated. His explanation involves \"cast away 3, and 1.2 will remain; cast away 2, and 1.3 will remain; cast away 1, and 2.3 will remain\". He then moves on to four bells and repeats the casting away argument showing that there will be four different sets of three. Effectively, this is a recursive process. He continues with five bells using the \"casting away\" method and tabulates the resulting 120 combinations. At this point he gives up and remarks: Now the nature of these methods is such, that the changes on one number comprehends the changes on all lesser numbers, ... insomuch that a compleat Peal of changes on one number seemeth to be formed by uniting of the compleat Peals on all lesser numbers into one entire body; Stedman widens the consideration of permutations; he goes on to consider the number of permutations of the letters of the alphabet and of horses from a stable of 20. A first case in which seemingly unrelated mathematical questions were studied with the help of permutations occurred around 1770, when Joseph Louis Lagrange, in the study of polynomial equations, observed that properties of the permutations of the roots of an equation are related to the possibilities to solve it. This line of work ultimately resulted, through the work of Évariste Galois, in Galois theory, which gives a complete description of what is possible and impossible with respect to solving polynomial equations (in one unknown) by radicals. In modern mathematics, there are many similar situations in which understanding a problem requires studying certain permutations related to it. The study of permutations as substitutions on n elements led to the notion of group as algebraic structure, through the works of Cauchy (1815 memoir). Permutations played an important role in the cryptanalysis of the Enigma machine, a cipher device used by Nazi Germany during World War II. In particular, one important property of permutations, namely, that two permutations are conjugate exactly when they have the same cycle type, was used by cryptologist Marian Rejewski to break the German Enigma cipher in turn of years 1932-1933. == Definition == In mathematics texts it is customary to denote permutations using lowercase Greek letters. A permutation can be defined as a bijection (an invertible mapping, a one-to-one and onto function) from a set S to itself: σ : S ⟶ ∼ S . {\\displaystyle \\sigma :S\\ {\\stackrel {\\sim }{\\longrightarrow }}\\ S.} The identity permutation is defined by σ ( x ) = x {\\displaystyle \\sigma (x)=x} for all elements x ∈ S {\\displaystyle x\\in S} , and can be denoted by the number 1 {\\displaystyle 1} , by id = id S {\\displaystyle {\\text{id}}={\\text{id}}_{S}} , or by a single 1-cycle (x). The set of all permutations of a set with n elements forms the symmetric group S n {\\displaystyle S_{n}} , where the group operation is composition of functions. Thus for two permutations σ {\\displaystyle \\sigma } and τ {\\displaystyle \\tau } in the group S n {\\displaystyle S_{n}} , their product π = σ τ {\\displaystyle \\pi =\\sigma \\tau } is defined by π ( i ) = σ ( τ ( i ) ) . {\\displaystyle \\pi (i)=\\sigma (\\tau (i)).} Composition is usually written without a dot or other sign. In general, composition of two permutations is not commutative; that is, typically the permutations τ σ {\\displaystyle \\tau \\sigma } and σ τ {\\displaystyle \\sigma \\tau } are not equal. As a bijection from a set to itself, a permutation is a function that performs a rearrangement of a set, termed an active permutation or substitution. An older viewpoint sees a permutation as an ordered arrangement or list of all the elements of S, called a passive permutation. According to this definition, all permutations in § One-line notation are passive. This meaning is subtly distinct from how passive (i.e. alias) is used in Active and passive transformation and elsewhere, which would consider all permutations open to passive interpretation (regardless of whether they are in one-line notation, two-line notation, etc.). A permutation σ {\\displaystyle \\sigma } can be decomposed into one or more disjoint cycles which are the orbits of the cyclic group ⟨ σ ⟩ = { 1 , σ , σ 2 , … } {\\displaystyle \\langle \\sigma \\rangle =\\{1,\\sigma ,\\sigma ^{2},\\ldots \\}} acting on the set S. A cycle is found by repeatedly applying the permutation to an element: x , σ ( x ) , σ ( σ ( x ) ) , … , σ k − 1 ( x ) {\\displaystyle x,\\sigma (x),\\sigma (\\sigma (x)),\\ldots ,\\sigma ^{k-1}(x)} , where we assume σ k ( x ) = x {\\displaystyle \\sigma ^{k}(x)=x} . A cycle consisting of k elements is called a k-cycle. (See § Cycle notation below.) A fixed point of a permutation σ {\\displaystyle \\sigma } is an element x which is taken to itself, that is σ ( x ) = x {\\displaystyle \\sigma (x)=x} , forming a 1-cycle ( x ) {\\displaystyle (\\,x\\,)} . A permutation with no fixed points is called a derangement. A permutation exchanging two elements (a single 2-cycle) and leaving the others fixed is called a transposition. == Notations == Several notations are widely used to represent permutations conveniently. The properties of permutations do not depend on the nature of the elements being permuted, only on their number, so one often considers the standard set { 1 , 2 , … , n } {\\displaystyle \\{1,2,\\ldots ,n\\}} . Cycle notation is a popular choice, as it is compact and shows the permutation's structure clearly. This article will use cycle notation unless otherwise specified. === Two-line notation === Cauchy's two-line notation lists the elements of S in the first row, and the image of each element below it in the second row. For example, the permutation of S = {1, 2, 3, 4, 5, 6} given by the function σ ( 1 ) = 2 , σ ( 2 ) = 6 , σ ( 3 ) = 5 , σ ( 4 ) = 4 , σ ( 5 ) = 3 , σ ( 6 ) = 1 {\\displaystyle \\sigma (1)=2,\\ \\ \\sigma (2)=6,\\ \\ \\sigma (3)=5,\\ \\ \\sigma (4)=4,\\ \\ \\sigma (5)=3,\\ \\ \\sigma (6)=1} can be written as σ = ( 1 2 3 4 5 6 2 6 5 4 3 1 ) . {\\displaystyle \\sigma ={\\begin{pmatrix}1&2&3&4&5&6\\\\2&6&5&4&3&1\\end{pmatrix}}.} The elements of S may appear in any order in the first row, so this permutation could also be written: σ = ( 2 3 4 5 6 1 6 5 4 3 1 2 ) = ( 6 5 4 3 2 1 1 3 4 5 6 2 ) . {\\displaystyle \\sigma ={\\begin{pmatrix}2&3&4&5&6&1\\\\6&5&4&3&1&2\\end{pmatrix}}={\\begin{pmatrix}6&5&4&3&2&1\\\\1&3&4&5&6&2\\end{pmatrix}}.} === One-line notation === If there is a \"natural\" order for the elements of S, say x 1 , x 2 , … , x n {\\displaystyle x_{1},x_{2},\\ldots ,x_{n}} , then one uses this for the first row of the two-line notation: σ = ( x 1 x 2 x 3 ⋯ x n σ ( x 1 ) σ ( x 2 ) σ ( x 3 ) ⋯ σ ( x n ) ) . {\\displaystyle \\sigma ={\\begin{pmatrix}x_{1}&x_{2}&x_{3}&\\cdots &x_{n}\\\\\\sigma (x_{1})&\\sigma (x_{2})&\\sigma (x_{3})&\\cdots &\\sigma (x_{n})\\end{pmatrix}}.} Under this assumption, one may omit the first row and write the permutation in one-line notation as σ = σ ( x 1 ) σ ( x 2 ) σ ( x 3 ) ⋯ σ ( x n ) {\\displaystyle \\sigma =\\sigma (x_{1})\\;\\sigma (x_{2})\\;\\sigma (x_{3})\\;\\cdots \\;\\sigma (x_{n})} , that is, as an ordered arrangement of the elements of S. Care must be taken to distinguish one-line notation from the cycle notation described below: a common usage is to omit parentheses or other enclosing marks for one-line notation, while using parentheses for cycle notation. The one-line notation is also called the word representation. The example above would then be: σ = ( 1 2 3 4 5 6 2 6 5 4 3 1 ) = 265431. {\\displaystyle \\sigma ={\\begin{pmatrix}1&2&3&4&5&6\\\\2&6&5&4&3&1\\end{pmatrix}}=265431.} (It is typical to use commas to separate these entries only if some have two or more digits.) This compact form is common in elementary combinatorics and computer science. It is especially useful in applications where the permutations are to be compared as larger or smaller using lexicographic order. === Cycle notation === Cycle notation describes the effect of repeatedly applying the permutation on the elements of the set S, with an orbit being called a cycle. The permutation is written as a list of cycles; since distinct cycles involve disjoint sets of elements, this is referred to as \"decomposition into disjoint cycles\". To write down the permutation σ {\\displaystyle \\sigma } in cycle notation, one proceeds as follows: Write an opening bracket followed by an arbitrary element x of S {\\displaystyle S} : ( x {\\displaystyle (\\,x} Trace the orbit of x, writing down the values under successive applications of σ {\\displaystyle \\sigma } : ( x , σ ( x ) , σ ( σ ( x ) ) , … {\\displaystyle (\\,x,\\sigma (x),\\sigma (\\sigma (x)),\\ldots } Repeat until the value returns to x, and close the parenthesis without repeating x: ( x σ ( x ) σ ( σ ( x ) ) … ) {\\displaystyle (\\,x\\,\\sigma (x)\\,\\sigma (\\sigma (x))\\,\\ldots \\,)} Continue with an element y of S which was not yet written, and repeat the above process: ( x σ ( x ) σ ( σ ( x ) ) … ) ( y … ) {\\displaystyle (\\,x\\,\\sigma (x)\\,\\sigma (\\sigma (x))\\,\\ldots \\,)(\\,y\\,\\ldots \\,)} Repeat until all elements of S are written in cycles. Also, it is common to omit 1-cycles, since these can be inferred: for any element x in S not appearing in any cycle, one implicitly assumes σ ( x ) = x {\\displaystyle \\sigma (x)=x} . Following the convention of omitting 1-cycles, one may interpret an individual cycle as a permutation which fixes all the elements not in the cycle (a cyclic permutation having only one cycle of length greater than 1). Then the list of disjoint cycles can be seen as the composition of these cyclic permutations. For example, the one-line permutation σ = 265431 {\\displaystyle \\sigma =265431} can be written in cycle notation as: σ = ( 126 ) ( 35 ) ( 4 ) = ( 126 ) ( 35 ) . {\\displaystyle \\sigma =(126)(35)(4)=(126)(35).} This may be seen as the composition σ = κ 1 κ 2 {\\displaystyle \\sigma =\\kappa _{1}\\kappa _{2}} of cyclic permutations: κ 1 = ( 126 ) = ( 126 ) ( 3 ) ( 4 ) ( 5 ) , κ 2 = ( 35 ) = ( 35 ) ( 1 ) ( 2 ) ( 6 ) . {\\displaystyle \\kappa _{1}=(126)=(126)(3)(4)(5),\\quad \\kappa _{2}=(35)=(35)(1)(2)(6).} While permutations in general do not commute, disjoint cycles do; for example: σ = ( 126 ) ( 35 ) = ( 35 ) ( 126 ) . {\\displaystyle \\sigma =(126)(35)=(35)(126).} Also, each cycle can be rewritten from a different starting point; for example, σ = ( 126 ) ( 35 ) = ( 261 ) ( 53 ) . {\\displaystyle \\sigma =(126)(35)=(261)(53).} Thus one may write the disjoint cycles of a given permutation in many different ways. A convenient feature of cycle notation is that inverting the permutation is given by reversing the order of the elements in each cycle. For example, σ − 1 = ( A 2 ( 126 ) ( 35 ) ) − 1 = ( 621 ) ( 53 ) . {\\displaystyle \\sigma ^{-1}=\\left({\\vphantom {A^{2}}}(126)(35)\\right)^{-1}=(621)(53).} === Canonical cycle notation === In some combinatorial contexts it is useful to fix a certain order for the elements in the cycles and of the (disjoint) cycles themselves. Miklós Bóna calls the following ordering choices the canonical cycle notation: in each cycle the largest element is listed first the cycles are sorted in increasing order of their first element, not omitting 1-cycles For example, ( 513 ) ( 6 ) ( 827 ) ( 94 ) {\\displaystyle (513)(6)(827)(94)} is a permutation of S = { 1 , 2 , … , 9 } {\\displaystyle S=\\{1,2,\\ldots ,9\\}} in canonical cycle notation. Richard Stanley calls this the \"standard representation\" of a permutation, and Martin Aigner uses \"standard form\". Sergey Kitaev also uses the \"standard form\" terminology, but reverses both choices; that is, each cycle lists its minimal element first, and the cycles are sorted in decreasing order of their minimal elements. === Composition of permutations === There are two ways to denote the composition of two permutations. In the most common notation, σ ⋅ τ {\\displaystyle \\sigma \\cdot \\tau } is the function that maps any element x to σ ( τ ( x ) ) {\\displaystyle \\sigma (\\tau (x))} . The rightmost permutation is applied to the argument first, because the argument is written to the right of the function. A different rule for multiplying permutations comes from writing the argument to the left of the function, so that the leftmost permutation acts first. In this notation, the permutation is often written as an exponent, so σ acting on x is written xσ; then the product is defined by x σ ⋅ τ = ( x σ ) τ {\\displaystyle x^{\\sigma \\cdot \\tau }=(x^{\\sigma })^{\\tau }} . This article uses the first definition, where the rightmost permutation is applied first. The function composition operation satisfies the axioms of a group. It is associative, meaning ( ρ σ ) τ = ρ ( σ τ ) {\\displaystyle (\\rho \\sigma )\\tau =\\rho (\\sigma \\tau )} , and products of more than two permutations are usually written without parentheses. The composition operation also has an identity element (the identity permutation id {\\displaystyle {\\text{id}}} ), and each permutation σ {\\displaystyle \\sigma } has an inverse σ − 1 {\\displaystyle \\sigma ^{-1}} (its inverse function) with σ − 1 σ = σ σ − 1 = id {\\displaystyle \\sigma ^{-1}\\sigma =\\sigma \\sigma ^{-1}={\\text{id}}} . == Other uses of the term permutation == The concept of a permutation as an ordered arrangement admits several generalizations that have been called permutations, especially in older literature. === k-permutations of n === In older literature and elementary textbooks, a k-permutation of n (sometimes called a partial permutation, sequence without repetition, variation, or arrangement) means an ordered arrangement (list) of a k-element subset of an n-set. The number of such k-permutations (k-arrangements) of n {\\displaystyle n} is denoted variously by such symbols as P k n {\\displaystyle P_{k}^{n}} , n P k {\\displaystyle _{n}P_{k}} , n P k {\\displaystyle ^{n}\\!P_{k}} , P n , k {\\displaystyle P_{n,k}} , P ( n , k ) {\\displaystyle P(n,k)} , or A n k {\\displaystyle A_{n}^{k}} , computed by the formula: P ( n , k ) = n ⋅ ( n − 1 ) ⋅ ( n − 2 ) ⋯ ( n − k + 1 ) ⏟ k f a c t o r s {\\displaystyle P(n,k)=\\underbrace {n\\cdot (n-1)\\cdot (n-2)\\cdots (n-k+1)} _{k\\ \\mathrm {factors} }} , which is 0 when k > n, and otherwise is equal to n ! ( n − k ) ! . {\\displaystyle {\\frac {n!}{(n-k)!}}.} The product is well defined without the assumption that n {\\displaystyle n} is a non-negative integer, and is of importance outside combinatorics as well; it is known as the Pochhammer symbol ( n ) k {\\displaystyle (n)_{k}} or as the k {\\displaystyle k} -th falling factorial power n k _ {\\displaystyle n^{\\underline {k}}} : P ( n , k ) = n P k = ( n ) k = n k _ . {\\displaystyle P(n,k)={_{n}}P_{k}=(n)_{k}=n^{\\underline {k}}.} This usage of the term permutation is closely associated with the term combination to mean a subset. A k-combination of a set S is a k-element subset of S: the elements of a combination are not ordered. Ordering the k-combinations of S in all possible ways produces the k-permutations of S. The number of k-combinations of an n-set, C(n,k), is therefore related to the number of k-permutations of n by: C ( n , k ) = P ( n , k ) P ( k , k ) = n k _ k ! = n ! ( n − k ) ! k ! . {\\displaystyle C(n,k)={\\frac {P(n,k)}{P(k,k)}}={\\frac {n^{\\underline {k}}}{k!}}={\\frac {n!}{(n-k)!\\,k!}}.} These numbers are also known as binomial coefficients, usually denoted ( n k ) {\\displaystyle {\\tbinom {n}{k}}} : C ( n , k ) = n C k = ( n k ) . {\\displaystyle C(n,k)={_{n}}C_{k}={\\binom {n}{k}}.} === Permutations with repetition === Ordered arrangements of k elements of a set S, where repetition is allowed, are called k-tuples. They have sometimes been referred to as permutations with repetition, although they are not permutations in the usual sense. They are also called words or strings over the alphabet S. If the set S has n elements, the number of k-tuples over S is n k . {\\displaystyle n^{k}.} === Permutations of multisets === If M is a finite multiset, then a multiset permutation is an ordered arrangement of elements of M in which each element appears a number of times equal exactly to its multiplicity in M. An anagram of a word having some repeated letters is an example of a multiset permutation. If the multiplicities of the elements of M (taken in some order) are m 1 {\\displaystyle m_{1}} , m 2 {\\displaystyle m_{2}} , ..., m l {\\displaystyle m_{l}} and their sum (that is, the size of M) is n, then the number of multiset permutations of M is given by the multinomial coefficient, ( n m 1 , m 2 , … , m l ) = n ! m 1 ! m 2 ! ⋯ m l ! = ( ∑ i = 1 l m i ) ! ∏ i = 1 l m i ! . {\\displaystyle {n \\choose m_{1},m_{2},\\ldots ,m_{l}}={\\frac {n!}{m_{1}!\\,m_{2}!\\,\\cdots \\,m_{l}!}}={\\frac {\\left(\\sum _{i=1}^{l}{m_{i}}\\right)!}{\\prod _{i=1}^{l}{m_{i}!}}}.} For example, the number of distinct anagrams of the word MISSISSIPPI is: 11 ! 1 ! 4 ! 4 ! 2 ! = 34650 {\\displaystyle {\\frac {11!}{1!\\,4!\\,4!\\,2!}}=34650} . A k-permutation of a multiset M is a sequence of k elements of M in which each element appears a number of times less than or equal to its multiplicity in M (an element's repetition number). === Circular permutations === Permutations, when considered as arrangements, are sometimes referred to as linearly ordered arrangements. If, however, the objects are arranged in a circular manner this distinguished ordering is weakened: there is no \"first element\" in the arrangement, as any element can be considered as the start. An arrangement of distinct objects in a circular manner is called a circular permutation. These can be formally defined as equivalence classes of ordinary permutations of these objects, for the equivalence relation generated by moving the final element of the linear arrangement to its front. Two circular permutations are equivalent if one can be rotated into the other. The following four circular permutations on four letters are considered to be the same. 1 4 2 3 4 3 2 1 3 4 1 2 2 3 1 4 The circular arrangements are to be read counter-clockwise, so the following two are not equivalent since no rotation can bring one to the other. 1 1 4 3 3 4 2 2 There are (n – 1)! circular permutations of a set with n elements. == Properties == The number of permutations of n distinct objects is n!. The number of n-permutations with k disjoint cycles is the signless Stirling number of the first kind, denoted c ( n , k ) {\\displaystyle c(n,k)} or [ n k ] {\\displaystyle [{\\begin{smallmatrix}n\\\\k\\end{smallmatrix}}]} . === Cycle type === The cycles (including the fixed points) of a permutation σ {\\displaystyle \\sigma } of a set with n elements partition that set; so the lengths of these cycles form an integer partition of n, which is called the cycle type (or sometimes cycle structure or cycle shape) of σ {\\displaystyle \\sigma } . There is a \"1\" in the cycle type for every fixed point of σ {\\displaystyle \\sigma } , a \"2\" for every transposition, and so on. The cycle type of β = ( 1 2 5 ) ( 3 4 ) ( 6 8 ) ( 7 ) {\\displaystyle \\beta =(1\\,2\\,5\\,)(\\,3\\,4\\,)(6\\,8\\,)(\\,7\\,)} is ( 3 , 2 , 2 , 1 ) . {\\displaystyle (3,2,2,1).} This may also be written in a more compact form as . More precisely, the general form is [ 1 α 1 2 α 2 ⋯ n α n ] {\\displaystyle [1^{\\alpha _{1}}2^{\\alpha _{2}}\\dotsm n^{\\alpha _{n}}]} , where α 1 , … , α n {\\displaystyle \\alpha _{1},\\ldots ,\\alpha _{n}} are the numbers of cycles of respective length. The number of permutations of a given cycle type is n ! 1 α 1 2 α 2 ⋯ n α n α 1 ! α 2 ! ⋯ α n ! {\\displaystyle {\\frac {n!}{1^{\\alpha _{1}}2^{\\alpha _{2}}\\dotsm n^{\\alpha _{n}}\\alpha _{1}!\\alpha _{2}!\\dotsm \\alpha _{n}!}}} . The number of cycle types of a set with n elements equals the value of the partition function p ( n ) {\\displaystyle p(n)} . Polya's cycle index polynomial is a generating function which counts permutations by their cycle type. === Conjugating permutations === In general, composing permutations written in cycle notation follows no easily described pattern – the cycles of the composition can be different from those being composed. However the cycle type is preserved in the special case of conjugating a permutation σ {\\displaystyle \\sigma } by another permutation π {\\displaystyle \\pi } , which means forming the product π σ π − 1 {\\displaystyle \\pi \\sigma \\pi ^{-1}} . Here, π σ π − 1 {\\displaystyle \\pi \\sigma \\pi ^{-1}} is the conjugate of σ {\\displaystyle \\sigma } by π {\\displaystyle \\pi } and its cycle notation can be obtained by taking the cycle notation for σ {\\displaystyle \\sigma } and applying π {\\displaystyle \\pi } to all the entries in it. It follows that two permutations are conjugate exactly when they have the same cycle type. === Order of a permutation === The order of a permutation σ {\\displaystyle \\sigma } is the smallest positive integer m so that σ m = i d {\\displaystyle \\sigma ^{m}=\\mathrm {id} } . It is the least common multiple of the lengths of its cycles. For example, the order of σ = ( 152 ) ( 34 ) {\\displaystyle \\sigma =(152)(34)} is lcm ( 3 , 2 ) = 6 {\\displaystyle {\\text{lcm}}(3,2)=6} . === Parity of a permutation === Every permutation of a finite set can be expressed as the product of transpositions. Although many such expressions for a given permutation may exist, either they all contain an even number of transpositions or they all contain an odd number of transpositions. Thus all permutations can be classified as even or odd depending on this number. This result can be extended so as to assign a sign, written sgn ⁡ σ {\\displaystyle \\operatorname {sgn} \\sigma } , to each permutation. sgn ⁡ σ = + 1 {\\displaystyle \\operatorname {sgn} \\sigma =+1} if σ {\\displaystyle \\sigma } is even and sgn ⁡ σ = − 1 {\\displaystyle \\operatorname {sgn} \\sigma =-1} if σ {\\displaystyle \\sigma } is odd. Then for two permutations σ {\\displaystyle \\sigma } and π {\\displaystyle \\pi } sgn ⁡ ( σ π ) = sgn ⁡ σ ⋅ sgn ⁡ π . {\\displaystyle \\operatorname {sgn} (\\sigma \\pi )=\\operatorname {sgn} \\sigma \\cdot \\operatorname {sgn} \\pi .} It follows that sgn ⁡ ( σ σ − 1 ) = + 1. {\\displaystyle \\operatorname {sgn} \\left(\\sigma \\sigma ^{-1}\\right)=+1.} The sign of a permutation is equal to the determinant of its permutation matrix (below). === Matrix representation === A permutation matrix is an n × n matrix that has exactly one entry 1 in each column and in each row, and all other entries are 0. There are several ways to assign a permutation matrix to a permutation of {1, 2, ..., n}. One natural approach is to define L σ {\\displaystyle L_{\\sigma }} to be the linear transformation of R n {\\displaystyle \\mathbb {R} ^{n}} which permutes the standard basis { e 1 , … , e n } {\\displaystyle \\{\\mathbf {e} _{1},\\ldots ,\\mathbf {e} _{n}\\}} by L σ ( e j ) = e σ ( j ) {\\displaystyle L_{\\sigma }(\\mathbf {e} _{j})=\\mathbf {e} _{\\sigma (j)}} , and define M σ {\\displaystyle M_{\\sigma }} to be its matrix. That is, M σ {\\displaystyle M_{\\sigma }} has its jth column equal to the n × 1 column vector e σ ( j ) {\\displaystyle \\mathbf {e} _{\\sigma (j)}} : its (i, j) entry is to 1 if i = σ(j), and 0 otherwise. Since composition of linear mappings is described by matrix multiplication, it follows that this construction is compatible with composition of permutations: M σ M τ = M σ τ {\\displaystyle M_{\\sigma }M_{\\tau }=M_{\\sigma \\tau }} . For example, the one-line permutations σ = 213 , τ = 231 {\\displaystyle \\sigma =213,\\ \\tau =231} have product σ τ = 132 {\\displaystyle \\sigma \\tau =132} , and the corresponding matrices are: M σ M τ = ( 0 1 0 1 0 0 0 0 1 ) ( 0 0 1 1 0 0 0 1 0 ) = ( 1 0 0 0 0 1 0 1 0 ) = M σ τ . {\\displaystyle M_{\\sigma }M_{\\tau }={\\begin{pmatrix}0&1&0\\\\1&0&0\\\\0&0&1\\end{pmatrix}}{\\begin{pmatrix}0&0&1\\\\1&0&0\\\\0&1&0\\end{pmatrix}}={\\begin{pmatrix}1&0&0\\\\0&0&1\\\\0&1&0\\end{pmatrix}}=M_{\\sigma \\tau }.} It is also common in the literature to find the inverse convention, where a permutation σ is associated to the matrix P σ = ( M σ ) − 1 = ( M σ ) T {\\displaystyle P_{\\sigma }=(M_{\\sigma })^{-1}=(M_{\\sigma })^{T}} whose (i, j) entry is 1 if j = σ(i) and is 0 otherwise. In this convention, permutation matrices multiply in the opposite order from permutations, that is, P σ P τ = P τ σ {\\displaystyle P_{\\sigma }P_{\\tau }=P_{\\tau \\sigma }} . In this correspondence, permutation matrices act on the right side of the standard 1 × n {\\displaystyle 1\\times n} row vectors ( e i ) T {\\displaystyle ({\\bf {e}}_{i})^{T}} : ( e i ) T P σ = ( e σ ( i ) ) T {\\displaystyle ({\\bf {e}}_{i})^{T}P_{\\sigma }=({\\bf {e}}_{\\sigma (i)})^{T}} . The Cayley table on the right shows these matrices for permutations of 3 elements. == Permutations of totally ordered sets == In some applications, the elements of the set being permuted will be compared with each other. This requires that the set S has a total order so that any two elements can be compared. The set {1, 2, ..., n} with the usual ≤ relation is the most frequently used set in these applications. A number of properties of a permutation are directly related to the total ordering of S, considering the permutation written in one-line notation as a sequence σ = σ ( 1 ) σ ( 2 ) ⋯ σ ( n ) {\\displaystyle \\sigma =\\sigma (1)\\sigma (2)\\cdots \\sigma (n)} . === Ascents, descents, runs, exceedances, records === An ascent of a permutation σ of n is any position i < n where the following value is bigger than the current one. That is, i is an ascent if σ ( i ) < σ ( i + 1 ) {\\displaystyle \\sigma (i)<\\sigma (i{+}1)} . For example, the permutation 3452167 has ascents (at positions) 1, 2, 5, and 6. Similarly, a descent is a position i < n with σ ( i ) > σ ( i + 1 ) {\\displaystyle \\sigma (i)>\\sigma (i{+}1)} , so every i with 1 ≤ i < n {\\displaystyle 1\\leq i j. If the inequality is not strict (that is, σj ≥ j), then j is called a weak exceedance. The number of n-permutations with k exceedances coincides with the number of n-permutations with k descents. A record or left-to-right maximum of a permutation σ is an element i such that σ(j) < σ(i) for all j < i. === Foata's transition lemma === Foata's fundamental bijection transforms a permutation σ with a given canonical cycle form into the permutation f ( σ ) = σ ^ {\\displaystyle f(\\sigma )={\\hat {\\sigma }}} whose one-line notation has the same sequence of elements with parentheses removed. For example: σ = ( 513 ) ( 6 ) ( 827 ) ( 94 ) = ( 1 2 3 4 5 6 7 8 9 3 7 5 9 1 6 8 2 4 ) , {\\displaystyle \\sigma =(513)(6)(827)(94)={\\begin{pmatrix}1&2&3&4&5&6&7&8&9\\\\3&7&5&9&1&6&8&2&4\\end{pmatrix}},} σ ^ = 513682794 = ( 1 2 3 4 5 6 7 8 9 5 1 3 6 8 2 7 9 4 ) . {\\displaystyle {\\hat {\\sigma }}=513682794={\\begin{pmatrix}1&2&3&4&5&6&7&8&9\\\\5&1&3&6&8&2&7&9&4\\end{pmatrix}}.} Here the first element in each canonical cycle of σ becomes a record (left-to-right maximum) of σ ^ {\\displaystyle {\\hat {\\sigma }}} . Given σ ^ {\\displaystyle {\\hat {\\sigma }}} , one may find its records and insert parentheses to construct the inverse transformation σ = f − 1 ( σ ^ ) {\\displaystyle \\sigma =f^{-1}({\\hat {\\sigma }})} . Underlining the records in the above example: σ ^ = 5 _ 1 3 6 _ 8 _ 2 7 9 _ 4 {\\displaystyle {\\hat {\\sigma }}={\\underline {5}}\\,1\\,3\\,{\\underline {6}}\\,{\\underline {8}}\\,2\\,7\\,{\\underline {9}}\\,4} , which allows the reconstruction of the cycles of σ. The following table shows σ ^ {\\displaystyle {\\hat {\\sigma }}} and σ for the six permutations of S = {1, 2, 3}, with the bold text on each side showing the notation used in the bijection: one-line notation for σ ^ {\\displaystyle {\\hat {\\sigma }}} and canonical cycle notation for σ. σ ^ = f ( σ ) σ = f − 1 ( σ ^ ) 123 = ( 1 ) ( 2 ) ( 3 ) 123 = ( 1 ) ( 2 ) ( 3 ) 132 = ( 1 ) ( 3 2 ) 132 = ( 1 ) ( 3 2 ) 213 = ( 2 1 ) ( 3 ) 213 = ( 2 1 ) ( 3 ) 231 = ( 3 1 2 ) 321 = ( 2 ) ( 3 1 ) 312 = ( 3 2 1 ) 231 = ( 3 1 2 ) 321 = ( 2 ) ( 3 1 ) 312 = ( 3 2 1 ) {\\displaystyle {\\begin{array}{l|l}{\\hat {\\sigma }}=f(\\sigma )&\\sigma =f^{-1}({\\hat {\\sigma }})\\\\\\hline \\mathbf {123} =(\\,1\\,)(\\,2\\,)(\\,3\\,)&123=\\mathbf {(\\,1\\,)(\\,2\\,)(\\,3\\,)} \\\\\\mathbf {132} =(\\,1\\,)(\\,3\\,2\\,)&132=\\mathbf {(\\,1\\,)(\\,3\\,2\\,)} \\\\\\mathbf {213} =(\\,2\\,1\\,)(\\,3\\,)&213=\\mathbf {(\\,2\\,1\\,)(\\,3\\,)} \\\\\\mathbf {231} =(\\,3\\,1\\,2\\,)&321=\\mathbf {(\\,2\\,)(\\,3\\,1\\,)} \\\\\\mathbf {312} =(\\,3\\,2\\,1\\,)&231=\\mathbf {(\\,3\\,1\\,2\\,)} \\\\\\mathbf {321} =(\\,2\\,)(\\,3\\,1\\,)&312=\\mathbf {(\\,3\\,2\\,1\\,)} \\end{array}}} As a first corollary, the number of n-permutations with exactly k records is equal to the number of n-permutations with exactly k cycles: this last number is the signless Stirling number of the first kind, c ( n , k ) {\\displaystyle c(n,k)} . Furthermore, Foata's mapping takes an n-permutation with k weak exceedances to an n-permutation with k − 1 ascents. For example, (2)(31) = 321 has k = 2 weak exceedances (at index 1 and 2), whereas f(321) = 231 has k − 1 = 1 ascent (at index 1; that is, from 2 to 3). === Inversions === An inversion of a permutation σ is a pair (i, j) of positions where the entries of a permutation are in the opposite order: i < j {\\displaystyle i σ ( j ) {\\displaystyle \\sigma (i)>\\sigma (j)} . Thus a descent is an inversion at two adjacent positions. For example, σ = 23154 has (i, j) = (1, 3), (2, 3), and (4, 5), where (σ(i), σ(j)) = (2, 1), (3, 1), and (5, 4). Sometimes an inversion is defined as the pair of values (σ(i), σ(j)); this makes no difference for the number of inversions, and the reverse pair (σ(j), σ(i)) is an inversion in the above sense for the inverse permutation σ−1. The number of inversions is an important measure for the degree to which the entries of a permutation are out of order; it is the same for σ and for σ−1. To bring a permutation with k inversions into order (that is, transform it into the identity permutation), by successively applying (right-multiplication by) adjacent transpositions, is always possible and requires a sequence of k such operations. Moreover, any reasonable choice for the adjacent transpositions will work: it suffices to choose at each step a transposition of i and i + 1 where i is a descent of the permutation as modified so far (so that the transposition will remove this particular descent, although it might create other descents). This is so because applying such a transposition reduces the number of inversions by 1; as long as this number is not zero, the permutation is not the identity, so it has at least one descent. Bubble sort and insertion sort can be interpreted as particular instances of this procedure to put a sequence into order. Incidentally this procedure proves that any permutation σ can be written as a product of adjacent transpositions; for this one may simply reverse any sequence of such transpositions that transforms σ into the identity. In fact, by enumerating all sequences of adjacent transpositions that would transform σ into the identity, one obtains (after reversal) a complete list of all expressions of minimal length writing σ as a product of adjacent transpositions. The number of permutations of n with k inversions is expressed by a Mahonian number. This is the coefficient of q k {\\displaystyle q^{k}} in the expansion of the product [ n ] q ! = ∏ m = 1 n ∑ i = 0 m − 1 q i = 1 ( 1 + q ) ( 1 + q + q 2 ) ⋯ ( 1 + q + q 2 + ⋯ + q n − 1 ) , {\\displaystyle [n]_{q}!=\\prod _{m=1}^{n}\\sum _{i=0}^{m-1}q^{i}=1\\left(1+q\\right)\\left(1+q+q^{2}\\right)\\cdots \\left(1+q+q^{2}+\\cdots +q^{n-1}\\right),} The notation [ n ] q ! {\\displaystyle [n]_{q}!} denotes the q-factorial. This expansion commonly appears in the study of necklaces. Let σ ∈ S n , i , j ∈ { 1 , 2 , … , n } {\\displaystyle \\sigma \\in S_{n},i,j\\in \\{1,2,\\dots ,n\\}} such that i < j {\\displaystyle i σ ( j ) {\\displaystyle \\sigma (i)>\\sigma (j)} . In this case, say the weight of the inversion ( i , j ) {\\displaystyle (i,j)} is σ ( i ) − σ ( j ) {\\displaystyle \\sigma (i)-\\sigma (j)} . Kobayashi (2011) proved the enumeration formula ∑ i < j , σ ( i ) > σ ( j ) ( σ ( i ) − σ ( j ) ) = | { τ ∈ S n ∣ τ ≤ σ , τ is bigrassmannian } {\\displaystyle \\sum _{i \\sigma (j)}(\\sigma (i)-\\sigma (j))=|\\{\\tau \\in S_{n}\\mid \\tau \\leq \\sigma ,\\tau {\\text{ is bigrassmannian}}\\}} where ≤ {\\displaystyle \\leq } denotes Bruhat order in the symmetric groups. This graded partial order often appears in the context of Coxeter groups. == Permutations in computing == === Numbering permutations === One way to represent permutations of n things is by an integer N with 0 ≤ N < n!, provided convenient methods are given to convert between the number and the representation of a permutation as an ordered arrangement (sequence). This gives the most compact representation of arbitrary permutations, and in computing is particularly attractive when n is small enough that N can be held in a machine word; for 32-bit words this means n ≤ 12, and for 64-bit words this means n ≤ 20. The conversion can be done via the intermediate form of a sequence of numbers dn, dn−1, ..., d2, d1, where di is a non-negative integer less than i (one may omit d1, as it is always 0, but its presence makes the subsequent conversion to a permutation easier to describe). The first step then is to simply express N in the factorial number system, which is just a particular mixed radix representation, where, for numbers less than n!, the bases (place values or multiplication factors) for successive digits are (n − 1)!, (n − 2)!, ..., 2!, 1!. The second step interprets this sequence as a Lehmer code or (almost equivalently) as an inversion table. In the Lehmer code for a permutation σ, the number dn represents the choice made for the first term σ1, the number dn−1 represents the choice made for the second term σ2 among the remaining n − 1 elements of the set, and so forth. More precisely, each dn+1−i gives the number of remaining elements strictly less than the term σi. Since those remaining elements are bound to turn up as some later term σj, the digit dn+1−i counts the inversions (i,j) involving i as smaller index (the number of values j for which i < j and σi > σj). The inversion table for σ is quite similar, but here dn+1−k counts the number of inversions (i,j) where k = σj occurs as the smaller of the two values appearing in inverted order. Both encodings can be visualized by an n by n Rothe diagram (named after Heinrich August Rothe) in which dots at (i,σi) mark the entries of the permutation, and a cross at (i,σj) marks the inversion (i,j); by the definition of inversions a cross appears in any square that comes both before the dot (j,σj) in its column, and before the dot (i,σi) in its row. The Lehmer code lists the numbers of crosses in successive rows, while the inversion table lists the numbers of crosses in successive columns; it is just the Lehmer code for the inverse permutation, and vice versa. To effectively convert a Lehmer code dn, dn−1, ..., d2, d1 into a permutation of an ordered set S, one can start with a list of the elements of S in increasing order, and for i increasing from 1 to n set σi to the element in the list that is preceded by dn+1−i other ones, and remove that element from the list. To convert an inversion table dn, dn−1, ..., d2, d1 into the corresponding permutation, one can traverse the numbers from d1 to dn while inserting the elements of S from largest to smallest into an initially empty sequence; at the step using the number d from the inversion table, the element from S inserted into the sequence at the point where it is preceded by d elements already present. Alternatively one could process the numbers from the inversion table and the elements of S both in the opposite order, starting with a row of n empty slots, and at each step place the element from S into the empty slot that is preceded by d other empty slots. Converting successive natural numbers to the factorial number system produces those sequences in lexicographic order (as is the case with any mixed radix number system), and further converting them to permutations preserves the lexicographic ordering, provided the Lehmer code interpretation is used (using inversion tables, one gets a different ordering, where one starts by comparing permutations by the place of their entries 1 rather than by the value of their first entries). The sum of the numbers in the factorial number system representation gives the number of inversions of the permutation, and the parity of that sum gives the signature of the permutation. Moreover, the positions of the zeroes in the inversion table give the values of left-to-right maxima of the permutation (in the example 6, 8, 9) while the positions of the zeroes in the Lehmer code are the positions of the right-to-left minima (in the example positions the 4, 8, 9 of the values 1, 2, 5); this allows computing the distribution of such extrema among all permutations. A permutation with Lehmer code dn, dn−1, ..., d2, d1 has an ascent n − i if and only if di ≥ di+1. === Algorithms to generate permutations === In computing it may be required to generate permutations of a given sequence of values. The methods best adapted to do this depend on whether one wants some randomly chosen permutations, or all permutations, and in the latter case if a specific ordering is required. Another question is whether possible equality among entries in the given sequence is to be taken into account; if so, one should only generate distinct multiset permutations of the sequence. An obvious way to generate permutations of n is to generate values for the Lehmer code (possibly using the factorial number system representation of integers up to n!), and convert those into the corresponding permutations. However, the latter step, while straightforward, is hard to implement efficiently, because it requires n operations each of selection from a sequence and deletion from it, at an arbitrary position; of the obvious representations of the sequence as an array or a linked list, both require (for different reasons) about n2/4 operations to perform the conversion. With n likely to be rather small (especially if generation of all permutations is needed) that is not too much of a problem, but it turns out that both for random and for systematic generation there are simple alternatives that do considerably better. For this reason it does not seem useful, although certainly possible, to employ a special data structure that would allow performing the conversion from Lehmer code to permutation in O(n log n) time. ==== Random generation of permutations ==== For generating random permutations of a given sequence of n values, it makes no difference whether one applies a randomly selected permutation of n to the sequence, or chooses a random element from the set of distinct (multiset) permutations of the sequence. This is because, even though in case of repeated values there can be many distinct permutations of n that result in the same permuted sequence, the number of such permutations is the same for each possible result. Unlike for systematic generation, which becomes unfeasible for large n due to the growth of the number n!, there is no reason to assume that n will be small for random generation. The basic idea to generate a random permutation is to generate at random one of the n! sequences of integers d1,d2,...,dn satisfying 0 ≤ di < i (since d1 is always zero it may be omitted) and to convert it to a permutation through a bijective correspondence. For the latter correspondence one could interpret the (reverse) sequence as a Lehmer code, and this gives a generation method first published in 1938 by Ronald Fisher and Frank Yates. While at the time computer implementation was not an issue, this method suffers from the difficulty sketched above to convert from Lehmer code to permutation efficiently. This can be remedied by using a different bijective correspondence: after using di to select an element among i remaining elements of the sequence (for decreasing values of i), rather than removing the element and compacting the sequence by shifting down further elements one place, one swaps the element with the final remaining element. Thus the elements remaining for selection form a consecutive range at each point in time, even though they may not occur in the same order as they did in the original sequence. The mapping from sequence of integers to permutations is somewhat complicated, but it can be seen to produce each permutation in exactly one way, by an immediate induction. When the selected element happens to be the final remaining element, the swap operation can be omitted. This does not occur sufficiently often to warrant testing for the condition, but the final element must be included among the candidates of the selection, to guarantee that all permutations can be generated. The resulting algorithm for generating a random permutation of a, a, ..., a[n − 1] can be described as follows in pseudocode: for i from n downto 2 do di ← random element of { 0, ..., i − 1 } swap a[di] and a[i − 1] This can be combined with the initialization of the array a[i] = i as follows for i from 0 to n−1 do di+1 ← random element of { 0, ..., i } a[i] ← a[di+1] a[di+1] ← i If di+1 = i, the first assignment will copy an uninitialized value, but the second will overwrite it with the correct value i. However, Fisher-Yates is not the fastest algorithm for generating a permutation, because Fisher-Yates is essentially a sequential algorithm and \"divide and conquer\" procedures can achieve the same result in parallel. ==== Generation in lexicographic order ==== There are many ways to systematically generate all permutations of a given sequence. One classic, simple, and flexible algorithm is based upon finding the next permutation in lexicographic ordering, if it exists. It can handle repeated values, for which case it generates each distinct multiset permutation once. Even for ordinary permutations it is significantly more efficient than generating values for the Lehmer code in lexicographic order (possibly using the factorial number system) and converting those to permutations. It begins by sorting the sequence in (weakly) increasing order (which gives its lexicographically minimal permutation), and then repeats advancing to the next permutation as long as one is found. The method goes back to Narayana Pandita in 14th century India, and has been rediscovered frequently. The following algorithm generates the next permutation lexicographically after a given permutation. It changes the given permutation in-place. Find the largest index k such that a[k] < a[k + 1]. If no such index exists, the permutation is the last permutation. Find the largest index l greater than k such that a[k] < a[l]. Swap the value of a[k] with that of a[l]. Reverse the sequence from a[k + 1] up to and including the final element a[n]. For example, given the sequence [1, 2, 3, 4] (which is in increasing order), and given that the index is zero-based, the steps are as follows: Index k = 2, because 3 is placed at an index that satisfies condition of being the largest index that is still less than a[k + 1] which is 4. Index l = 3, because 4 is the only value in the sequence that is greater than 3 in order to satisfy the condition a[k] < a[l]. The values of a and a are swapped to form the new sequence [1, 2, 4, 3]. The sequence after k-index a to the final element is reversed. Because only one value lies after this index (the 3), the sequence remains unchanged in this instance. Thus the lexicographic successor of the initial state is permuted: [1, 2, 4, 3]. Following this algorithm, the next lexicographic permutation will be [1, 3, 2, 4], and the 24th permutation will be [4, 3, 2, 1] at which point a[k] < a[k + 1] does not exist, indicating that this is the last permutation. This method uses about 3 comparisons and 1.5 swaps per permutation, amortized over the whole sequence, not counting the initial sort. ==== Generation with minimal changes ==== An alternative to the above algorithm, the Steinhaus–Johnson–Trotter algorithm, generates an ordering on all the permutations of a given sequence with the property that any two consecutive permutations in its output differ by swapping two adjacent values. This ordering on the permutations was known to 17th-century English bell ringers, among whom it was known as \"plain changes\". One advantage of this method is that the small amount of change from one permutation to the next allows the method to be implemented in constant time per permutation. The same can also easily generate the subset of even permutations, again in constant time per permutation, by skipping every other output permutation. An alternative to Steinhaus–Johnson–Trotter is Heap's algorithm, said by Robert Sedgewick in 1977 to be the fastest algorithm of generating permutations in applications. The following figure shows the output of all three aforementioned algorithms for generating all permutations of length n = 4 {\\displaystyle n=4} , and of six additional algorithms described in the literature. Lexicographic ordering; Steinhaus–Johnson–Trotter algorithm; Heap's algorithm; Ehrlich's star-transposition algorithm: in each step, the first entry of the permutation is exchanged with a later entry; Zaks' prefix reversal algorithm: in each step, a prefix of the current permutation is reversed to obtain the next permutation; Sawada-Williams' algorithm: each permutation differs from the previous one either by a cyclic left-shift by one position, or an exchange of the first two entries; Corbett's algorithm: each permutation differs from the previous one by a cyclic left-shift of some prefix by one position; Single-track ordering: each column is a cyclic shift of the other columns; Single-track Gray code: each column is a cyclic shift of the other columns, plus any two consecutive permutations differ only in one or two transpositions. Nested swaps generating algorithm in steps connected to the nested subgroups S k ⊂ S k + 1 {\\displaystyle S_{k}\\subset S_{k+1}} . Each permutation is obtained from the previous by a transposition multiplication to the left. Algorithm is connected to the Factorial_number_system of the index. ==== Generation of permutations in nested swap steps ==== Explicit sequence of swaps (transpositions, 2-cycles ( p q ) {\\displaystyle (pq)} ), is described here, each swap applied (on the left) to the previous chain providing a new permutation, such that all the permutations can be retrieved, each only once. This counting/generating procedure has an additional structure (call it nested), as it is given in steps: after completely retrieving S k − 1 {\\displaystyle S_{k-1}} , continue retrieving S k ∖ S k − 1 {\\displaystyle S_{k}\\backslash S_{k-1}} by cosets S k − 1 τ i {\\displaystyle S_{k-1}\\tau _{i}} of S k − 1 {\\displaystyle S_{k-1}} in S k {\\displaystyle S_{k}} , by appropriately choosing the coset representatives τ i {\\displaystyle \\tau _{i}} to be described below. Since each S m {\\displaystyle S_{m}} is sequentially generated, there is a last element λ m ∈ S m {\\displaystyle \\lambda _{m}\\in S_{m}} . So, after generating S k − 1 {\\displaystyle S_{k-1}} by swaps, the next permutation in S k ∖ S k − 1 {\\displaystyle S_{k}\\backslash S_{k-1}} has to be τ 1 = ( p 1 k ) λ k − 1 {\\displaystyle \\tau _{1}=(p_{1}k)\\lambda _{k-1}} for some 1 ≤ p 1 < k {\\displaystyle 1\\leq p_{1} j > i ≥ 1 {\\displaystyle k>j>i\\geq 1} , ( λ k − 1 ) j − i p i ≠ p j {\\displaystyle (\\lambda _{k-1})^{j-i}p_{i}\\neq p_{j}} (no repeat condition). In particular, for all generated permutations to be distinct it is not necessary for the p i {\\displaystyle p_{i}} values to be distinct. In the process, one gets that λ k = λ k − 1 ( p k − 1 k ) λ k − 1 ( p k − 2 k ) λ k − 1 ⋯ λ k − 1 ( p 1 k ) λ k − 1 {\\displaystyle \\lambda _{k}=\\lambda _{k-1}(p_{k-1}k)\\lambda _{k-1}(p_{k-2}k)\\lambda _{k-1}\\cdots \\lambda _{k-1}(p_{1}k)\\lambda _{k-1}} and this provides the recursion procedure. EXAMPLES: obviously, for λ 2 {\\displaystyle \\lambda _{2}} one has λ 2 = ( 12 ) {\\displaystyle \\lambda _{2}=(12)} ; to build λ 3 {\\displaystyle \\lambda _{3}} there are only two possibilities for the coset beginnings satisfying the no repeat condition; the choice p 1 = p 2 = 1 {\\displaystyle p_{1}=p_{2}=1} leads to λ 3 = λ 2 ( 13 ) λ 2 ( 13 ) λ 2 = ( 13 ) {\\displaystyle \\lambda _{3}=\\lambda _{2}(13)\\lambda _{2}(13)\\lambda _{2}=(13)} . To continue generating S 4 {\\displaystyle S_{4}} one needs appropriate coset beginnings (satisfying the no repeat condition): there is a convenient choice: p 1 = 1 , p 2 = 2 , p 3 = 3 {\\displaystyle p_{1}=1,p_{2}=2,p_{3}=3} , leading to λ 4 = ( 13 ) ( 1234 ) ( 13 ) = ( 1432 ) {\\displaystyle \\lambda _{4}=(13)(1234)(13)=(1432)} . Then, to build λ 5 {\\displaystyle \\lambda _{5}} a convenient choice for the coset beginnings (satisfying the no repeat condition) is p 1 = p 2 = p 3 = p 4 = 1 {\\displaystyle p_{1}=p_{2}=p_{3}=p_{4}=1} , leading to λ 5 = ( 15 ) {\\displaystyle \\lambda _{5}=(15)} . From examples above one can inductively go to higher k {\\displaystyle k} in a similar way, choosing coset beginnings of S k {\\displaystyle S_{k}} in S k + 1 {\\displaystyle S_{k+1}} , as follows: for k {\\displaystyle k} even choosing all coset beginnings equal to 1 and for k {\\displaystyle k} odd choosing coset beginnings equal to ( 1 , 2 , … , k ) {\\displaystyle (1,2,\\dots ,k)} . With such choices the \"last\" permutation is λ k = ( 1 k ) {\\displaystyle \\lambda _{k}=(1k)} for k {\\displaystyle k} odd and λ k = ( 1 k − ) ( 12 ⋯ k ) ( 1 k − ) {\\displaystyle \\lambda _{k}=(1k_{-})(12\\cdots k)(1k_{-})} for k {\\displaystyle k} even ( k − = k − 1 {\\displaystyle k_{-}=k-1} ). Using these explicit formulae one can easily compute the permutation of certain index in the counting/generation steps with minimum computation. For this, writing the index in factorial base is useful. For example, the permutation for index 699 = 5 ( 5 ! ) + 4 ( 4 ! ) + 1 ( 2 ! ) + 1 ( 1 ! ) {\\displaystyle 699=5(5!)+4(4!)+1(2!)+1(1!)} is: σ = λ 2 ( 13 ) λ 2 ( 15 ) λ 4 ( 15 ) λ 4 ( 15 ) λ 4 ( 15 ) λ 4 ( 56 ) λ 5 ( 46 ) λ 5 ( 36 ) λ 5 ( 26 ) λ 5 ( 16 ) λ 5 = {\\displaystyle \\sigma =\\lambda _{2}(13)\\lambda _{2}(15)\\lambda _{4}(15)\\lambda _{4}(15)\\lambda _{4}(15)\\lambda _{4}(56)\\lambda _{5}(46)\\lambda _{5}(36)\\lambda _{5}(26)\\lambda _{5}(16)\\lambda _{5}=} λ 2 ( 13 ) λ 2 ( ( 15 ) λ 4 ) 4 ( λ 5 ) − 1 λ 6 = ( 23 ) ( 14325 ) − 1 ( 15 ) ( 15 ) ( 123456 ) ( 15 ) = {\\displaystyle \\lambda _{2}(13)\\lambda _{2}((15)\\lambda _{4})^{4}(\\lambda _{5})^{-1}\\lambda _{6}=(23)(14325)^{-1}(15)(15)(123456)(15)=} ( 23 ) ( 15234 ) ( 123456 ) ( 15 ) {\\displaystyle (23)(15234)(123456)(15)} , yelding finally, σ = ( 1653 ) ( 24 ) {\\displaystyle \\sigma =(1653)(24)} . Because multiplying by swap permutation takes short computing time and every new generated permutation requires only one such swap multiplication, this generation procedure is quite efficient. Moreover as there is a simple formula, having the last permutation in each S k {\\displaystyle S_{k}} can save even more time to go directly to a permutation with certain index in fewer steps than expected as it can be done in blocks of subgroups rather than swap by swap. === Applications === Permutations are used in the interleaver component of the error detection and correction algorithms, such as turbo codes, for example 3GPP Long Term Evolution mobile telecommunication standard uses these ideas (see 3GPP technical specification 36.212). Such applications raise the question of fast generation of permutations satisfying certain desirable properties. One of the methods is based on the permutation polynomials. Also as a base for optimal hashing in Unique Permutation Hashing. == See also == == Notes == == References == == Bibliography == Bogart, Kenneth P. (1990), Introductory Combinatorics (2nd ed.), Harcourt Brace Jovanovich, ISBN 978-0-15-541576-8 Bóna, Miklós (2004), Combinatorics of Permutations, Chapman Hall-CRC, ISBN 978-1-58488-434-7 Bona, Miklos (2012), Combinatorics of Permutations (2nd ed.), CRC Press, ISBN 978-1-4398-5051-0 Brualdi, Richard A. (2010), Introductory Combinatorics (5th ed.), Prentice-Hall, ISBN 978-0-13-602040-0 Cameron, Peter J. (1994), Combinatorics: Topics, Techniques, Algorithms, Cambridge University Press, ISBN 978-0-521-45761-3 Carmichael, Robert D. (1956) , Introduction to the theory of Groups of Finite Order, Dover, ISBN 978-0-486-60300-1 {{citation}}: ISBN / Date incompatibility (help) Fraleigh, John B. (1976), A First Course In Abstract Algebra (2nd ed.), Reading: Addison-Wesley, ISBN 0-201-01984-1 Gerstein, Larry J. (1987), Discrete Mathematics and Algebraic Structures, W.H. Freeman and Co., ISBN 978-0-7167-1804-8 Hall, Marshall Jr. (1959), The Theory of Groups, MacMillan Humphreys, J. F. (1996), A course in group theory, Oxford University Press, ISBN 978-0-19-853459-4 Knuth, Donald (1973), Sorting and Searching, The Art of Computer Programming, vol. 3 This book mentions the Lehmer code (without using that name) as a variant C1,...,Cn of inversion tables in exercise 5.1.1–7 (p. 19), together with two other variants. Knuth, Donald (2005), Generating All Tuples and Permutations, The Art of Computer Programming, vol. 4, Addison–Wesley, ISBN 978-0-201-85393-3 Fascicle 2, first printing. McCoy, Neal H. (1968), Introduction To Modern Algebra, Revised Edition, Boston: Allyn and Bacon, LCCN 68015225 Nering, Evar D. (1970), Linear Algebra and Matrix Theory (2nd ed.), New York: Wiley, LCCN 76091646 Rotman, Joseph J. (2002), Advanced Modern Algebra, Prentice-Hall, ISBN 978-0-13-087868-7 Stedman, Fabian (1677), Campanalogia, London The publisher is given as \"W.S.\" who may have been William Smith, possibly acting as agent for the Society of College Youths, to which society the \"Dedicatory\" is addressed. In quotations the original long \"S\" has been replaced by a modern short \"s\". Uspensky, James (1937), Introduction to Mathematical Probability, McGraw-Hill Webster's Seventh New Collegiate Dictionary, Springfield: G. & C. Merriam Company, 1969 == Further reading == Biggs, Norman L. (2002), Discrete Mathematics (2nd ed.), Oxford University Press, ISBN 978-0-19-850717-8 Foata, Dominique; Schutzenberger, Marcel-Paul (1970), Théorie Géométrique des Polynômes Eulériens, Lecture Notes in Mathematics, vol. 138, Berlin, Heidelberg: Springer-Verlag, ISBN 978-3-540-04927-2. The link is to a freely available retyped (LaTeX'ed) and revised version of the text originally published by Springer-Verlag. Knuth, Donald (1998), Sorting and Searching, The Art of Computer Programming, vol. 3 (Second ed.), Addison–Wesley, ISBN 978-0-201-89685-5. Section 5.1: Combinatorial Properties of Permutations, pp. 11–72. Sedgewick, Robert (1977). \"Permutation generation methods\". ACM Computing Surveys. 9 (2): 137–164. doi:10.1145/356689.356692. S2CID 12139332. Masato, Kobayashi (2011). \"Enumeration of bigrassmannian permutations below a permutation in Bruhat order\". Order. 1: 131–137. == External links == \"Permutation\", Encyclopedia of Mathematics, EMS Press, 2001"
  },
  "chunks": [
    {
      "id": "permutation_56370258_c0000",
      "article_id": "permutation_56370258",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 921,
      "content": "In mathematics, a permutation of a set can mean one of two different things: an arrangement of its members in a sequence or linear order, or the act or process of changing the linear order of an ordered set. An example of the first meaning is the six permutations (orderings) of the set {1, 2, 3}: written as tuples, they are (1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), and (3, 2, 1). Anagrams of a word whose letters are all different are also permutations: the letters are already ordered in the original word, and the anagram reorders them. The study of permutations of finite sets is an important topic in combinatorics and group theory. Permutations are used in almost every branch of mathematics and in many other fields of science. In computer science, they are used for analyzing sorting algorithms; in quantum physics, for describing states of particles; and in biology, for describing RNA sequences.",
      "char_count": 920,
      "token_estimate": 230,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0001",
      "article_id": "permutation_56370258",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 921,
      "end_char": 1801,
      "content": "The number of permutations of n distinct objects is n factorial, usually written as n!, which means the product of all positive integers less than or equal to n. According to the second meaning, a permutation of a set S is defined as a bijection from S to itself. That is, it is a function from S to S for which every element occurs exactly once as an image value. Such a function σ : S → S {\\displaystyle \\sigma :S\\to S} is equivalent to the rearrangement of the elements of S in which each element i is replaced by the corresponding σ ( i ) {\\displaystyle \\sigma (i)} . For example, the permutation (3, 1, 2) corresponds to the function σ {\\displaystyle \\sigma } defined as σ ( 1 ) = 3 , σ ( 2 ) = 1 , σ ( 3 ) = 2. {\\displaystyle \\sigma (1)=3,\\quad \\sigma (2)=1,\\quad \\sigma (3)=2.} The collection of all permutations of a set form a group called the symmetric group of the set.",
      "char_count": 880,
      "token_estimate": 220,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0002",
      "article_id": "permutation_56370258",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 1802,
      "end_char": 2189,
      "content": "The group operation is the composition of functions (performing one rearrangement after the other), which results in another function (rearrangement). In elementary combinatorics, the k-permutations, or partial permutations, are the ordered arrangements of k distinct elements selected from a set. When k is equal to the size of the set, these are the permutations in the previous sense.",
      "char_count": 387,
      "token_estimate": 96,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0003",
      "article_id": "permutation_56370258",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 2203,
      "end_char": 2918,
      "content": "== History == Permutation-like objects called hexagrams were used in China in the I Ching (Pinyin: Yi Jing) as early as 1000 BC. In Greece, Plutarch wrote that Xenocrates of Chalcedon (396–314 BC) discovered the number of different syllables possible in the Greek language. This would have been the first attempt on record to solve a difficult problem in permutations and combinations. Al-Khalil (717–786), an Arab mathematician and cryptographer, wrote the Book of Cryptographic Messages. It contains the first use of permutations and combinations, to list all possible Arabic words with and without vowels. The rule to determine the number of permutations of n objects was known in Indian culture around 1150 AD.",
      "char_count": 714,
      "token_estimate": 178,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0004",
      "article_id": "permutation_56370258",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 2918,
      "end_char": 3873,
      "content": "The Lilavati by the Indian mathematician Bhāskara II contains a passage that translates as follows: The product of multiplication of the arithmetical series beginning and increasing by unity and continued to the number of places, will be the variations of number with specific figures. In 1677, Fabian Stedman described factorials when explaining the number of permutations of bells in change ringing. Starting from two bells: \"first, two must be admitted to be varied in two ways\", which he illustrates by showing 1 2 and 2 1. He then explains that with three bells there are \"three times two figures to be produced out of three\" which again is illustrated. His explanation involves \"cast away 3, and 1.2 will remain; cast away 2, and 1.3 will remain; cast away 1, and 2.3 will remain\". He then moves on to four bells and repeats the casting away argument showing that there will be four different sets of three. Effectively, this is a recursive process.",
      "char_count": 955,
      "token_estimate": 238,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0005",
      "article_id": "permutation_56370258",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 3874,
      "end_char": 4776,
      "content": "He continues with five bells using the \"casting away\" method and tabulates the resulting 120 combinations. At this point he gives up and remarks: Now the nature of these methods is such, that the changes on one number comprehends the changes on all lesser numbers, ... insomuch that a compleat Peal of changes on one number seemeth to be formed by uniting of the compleat Peals on all lesser numbers into one entire body; Stedman widens the consideration of permutations; he goes on to consider the number of permutations of the letters of the alphabet and of horses from a stable of 20. A first case in which seemingly unrelated mathematical questions were studied with the help of permutations occurred around 1770, when Joseph Louis Lagrange, in the study of polynomial equations, observed that properties of the permutations of the roots of an equation are related to the possibilities to solve it.",
      "char_count": 902,
      "token_estimate": 225,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0006",
      "article_id": "permutation_56370258",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 4777,
      "end_char": 5696,
      "content": "This line of work ultimately resulted, through the work of Évariste Galois, in Galois theory, which gives a complete description of what is possible and impossible with respect to solving polynomial equations (in one unknown) by radicals. In modern mathematics, there are many similar situations in which understanding a problem requires studying certain permutations related to it. The study of permutations as substitutions on n elements led to the notion of group as algebraic structure, through the works of Cauchy (1815 memoir). Permutations played an important role in the cryptanalysis of the Enigma machine, a cipher device used by Nazi Germany during World War II. In particular, one important property of permutations, namely, that two permutations are conjugate exactly when they have the same cycle type, was used by cryptologist Marian Rejewski to break the German Enigma cipher in turn of years 1932-1933.",
      "char_count": 919,
      "token_estimate": 229,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0007",
      "article_id": "permutation_56370258",
      "section": "== Definition ==",
      "heading_path": "== Definition ==",
      "start_char": 5700,
      "end_char": 6664,
      "content": "== Definition == In mathematics texts it is customary to denote permutations using lowercase Greek letters. A permutation can be defined as a bijection (an invertible mapping, a one-to-one and onto function) from a set S to itself: σ : S ⟶ ∼ S . {\\displaystyle \\sigma :S\\ {\\stackrel {\\sim }{\\longrightarrow }}\\ S.} The identity permutation is defined by σ ( x ) = x {\\displaystyle \\sigma (x)=x} for all elements x ∈ S {\\displaystyle x\\in S} , and can be denoted by the number 1 {\\displaystyle 1} , by id = id S {\\displaystyle {\\text{id}}={\\text{id}}_{S}} , or by a single 1-cycle (x). The set of all permutations of a set with n elements forms the symmetric group S n {\\displaystyle S_{n}} , where the group operation is composition of functions. Thus for two permutations σ {\\displaystyle \\sigma } and τ {\\displaystyle \\tau } in the group S n {\\displaystyle S_{n}} , their product π = σ τ {\\displaystyle \\pi =\\sigma \\tau } is defined by π ( i ) = σ ( τ ( i ) ) .",
      "char_count": 963,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0008",
      "article_id": "permutation_56370258",
      "section": "== Definition ==",
      "heading_path": "== Definition ==",
      "start_char": 6664,
      "end_char": 7584,
      "content": "{\\displaystyle \\pi (i)=\\sigma (\\tau (i)).} Composition is usually written without a dot or other sign. In general, composition of two permutations is not commutative; that is, typically the permutations τ σ {\\displaystyle \\tau \\sigma } and σ τ {\\displaystyle \\sigma \\tau } are not equal. As a bijection from a set to itself, a permutation is a function that performs a rearrangement of a set, termed an active permutation or substitution. An older viewpoint sees a permutation as an ordered arrangement or list of all the elements of S, called a passive permutation. According to this definition, all permutations in § One-line notation are passive. This meaning is subtly distinct from how passive (i.e. alias) is used in Active and passive transformation and elsewhere, which would consider all permutations open to passive interpretation (regardless of whether they are in one-line notation, two-line notation, etc.).",
      "char_count": 920,
      "token_estimate": 230,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0009",
      "article_id": "permutation_56370258",
      "section": "== Definition ==",
      "heading_path": "== Definition ==",
      "start_char": 7585,
      "end_char": 8556,
      "content": "A permutation σ {\\displaystyle \\sigma } can be decomposed into one or more disjoint cycles which are the orbits of the cyclic group ⟨ σ ⟩ = { 1 , σ , σ 2 , … } {\\displaystyle \\langle \\sigma \\rangle =\\{1,\\sigma ,\\sigma ^{2},\\ldots \\}} acting on the set S. A cycle is found by repeatedly applying the permutation to an element: x , σ ( x ) , σ ( σ ( x ) ) , … , σ k − 1 ( x ) {\\displaystyle x,\\sigma (x),\\sigma (\\sigma (x)),\\ldots ,\\sigma ^{k-1}(x)} , where we assume σ k ( x ) = x {\\displaystyle \\sigma ^{k}(x)=x} . A cycle consisting of k elements is called a k-cycle. (See § Cycle notation below.) A fixed point of a permutation σ {\\displaystyle \\sigma } is an element x which is taken to itself, that is σ ( x ) = x {\\displaystyle \\sigma (x)=x} , forming a 1-cycle ( x ) {\\displaystyle (\\,x\\,)} . A permutation with no fixed points is called a derangement. A permutation exchanging two elements (a single 2-cycle) and leaving the others fixed is called a transposition.",
      "char_count": 971,
      "token_estimate": 242,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0010",
      "article_id": "permutation_56370258",
      "section": "== Notations ==",
      "heading_path": "== Notations ==",
      "start_char": 8556,
      "end_char": 9003,
      "content": "== Notations == Several notations are widely used to represent permutations conveniently. The properties of permutations do not depend on the nature of the elements being permuted, only on their number, so one often considers the standard set { 1 , 2 , … , n } {\\displaystyle \\{1,2,\\ldots ,n\\}} . Cycle notation is a popular choice, as it is compact and shows the permutation's structure clearly. This article will use cycle notation unless otherwise specified.",
      "char_count": 461,
      "token_estimate": 115,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0011",
      "article_id": "permutation_56370258",
      "section": "== = Two-line notation ==",
      "heading_path": "== = Two-line notation ==",
      "start_char": 9028,
      "end_char": 9864,
      "content": "== = Two-line notation === Cauchy's two-line notation lists the elements of S in the first row, and the image of each element below it in the second row. For example, the permutation of S = {1, 2, 3, 4, 5, 6} given by the function σ ( 1 ) = 2 , σ ( 2 ) = 6 , σ ( 3 ) = 5 , σ ( 4 ) = 4 , σ ( 5 ) = 3 , σ ( 6 ) = 1 {\\displaystyle \\sigma (1)=2,\\ \\ \\sigma (2)=6,\\ \\ \\sigma (3)=5,\\ \\ \\sigma (4)=4,\\ \\ \\sigma (5)=3,\\ \\ \\sigma (6)=1} can be written as σ = ( 1 2 3 4 5 6 2 6 5 4 3 1 ) . {\\displaystyle \\sigma ={\\begin{pmatrix}1&2&3&4&5&6\\\\2&6&5&4&3&1\\end{pmatrix}}.} The elements of S may appear in any order in the first row, so this permutation could also be written: σ = ( 2 3 4 5 6 1 6 5 4 3 1 2 ) = ( 6 5 4 3 2 1 1 3 4 5 6 2 ) . {\\displaystyle \\sigma ={\\begin{pmatrix}2&3&4&5&6&1\\\\6&5&4&3&1&2\\end{pmatrix}}={\\begin{pmatrix}6&5&4&3&2&1\\\\1&3&4&5&6&2\\end{pmatrix}}.}",
      "char_count": 860,
      "token_estimate": 215,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0012",
      "article_id": "permutation_56370258",
      "section": "== = One-line notation ==",
      "heading_path": "== = One-line notation ==",
      "start_char": 9889,
      "end_char": 10850,
      "content": "== = One-line notation === If there is a \"natural\" order for the elements of S, say x 1 , x 2 , … , x n {\\displaystyle x_{1},x_{2},\\ldots ,x_{n}} , then one uses this for the first row of the two-line notation: σ = ( x 1 x 2 x 3 ⋯ x n σ ( x 1 ) σ ( x 2 ) σ ( x 3 ) ⋯ σ ( x n ) ) . {\\displaystyle \\sigma ={\\begin{pmatrix}x_{1}&x_{2}&x_{3}&\\cdots &x_{n}\\\\\\sigma (x_{1})&\\sigma (x_{2})&\\sigma (x_{3})&\\cdots &\\sigma (x_{n})\\end{pmatrix}}.} Under this assumption, one may omit the first row and write the permutation in one-line notation as σ = σ ( x 1 ) σ ( x 2 ) σ ( x 3 ) ⋯ σ ( x n ) {\\displaystyle \\sigma =\\sigma (x_{1})\\;\\sigma (x_{2})\\;\\sigma (x_{3})\\;\\cdots \\;\\sigma (x_{n})} , that is, as an ordered arrangement of the elements of S. Care must be taken to distinguish one-line notation from the cycle notation described below: a common usage is to omit parentheses or other enclosing marks for one-line notation, while using parentheses for cycle notation.",
      "char_count": 960,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0013",
      "article_id": "permutation_56370258",
      "section": "== = One-line notation ==",
      "heading_path": "== = One-line notation ==",
      "start_char": 10850,
      "end_char": 11375,
      "content": "The one-line notation is also called the word representation. The example above would then be: σ = ( 1 2 3 4 5 6 2 6 5 4 3 1 ) = 265431. {\\displaystyle \\sigma ={\\begin{pmatrix}1&2&3&4&5&6\\\\2&6&5&4&3&1\\end{pmatrix}}=265431.} (It is typical to use commas to separate these entries only if some have two or more digits.) This compact form is common in elementary combinatorics and computer science. It is especially useful in applications where the permutations are to be compared as larger or smaller using lexicographic order.",
      "char_count": 525,
      "token_estimate": 131,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0014",
      "article_id": "permutation_56370258",
      "section": "== = Cycle notation ==",
      "heading_path": "== = Cycle notation ==",
      "start_char": 11373,
      "end_char": 12152,
      "content": "== = Cycle notation === Cycle notation describes the effect of repeatedly applying the permutation on the elements of the set S, with an orbit being called a cycle. The permutation is written as a list of cycles; since distinct cycles involve disjoint sets of elements, this is referred to as \"decomposition into disjoint cycles\". To write down the permutation σ {\\displaystyle \\sigma } in cycle notation, one proceeds as follows: Write an opening bracket followed by an arbitrary element x of S {\\displaystyle S} : ( x {\\displaystyle (\\,x} Trace the orbit of x, writing down the values under successive applications of σ {\\displaystyle \\sigma } : ( x , σ ( x ) , σ ( σ ( x ) ) , … {\\displaystyle (\\,x,\\sigma (x),\\sigma (\\sigma (x)),\\ldots } Repeat until the value returns to x,",
      "char_count": 778,
      "token_estimate": 194,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0015",
      "article_id": "permutation_56370258",
      "section": "== = Cycle notation ==",
      "heading_path": "== = Cycle notation ==",
      "start_char": 12152,
      "end_char": 13053,
      "content": "and close the parenthesis without repeating x: ( x σ ( x ) σ ( σ ( x ) ) … ) {\\displaystyle (\\,x\\,\\sigma (x)\\,\\sigma (\\sigma (x))\\,\\ldots \\,)} Continue with an element y of S which was not yet written, and repeat the above process: ( x σ ( x ) σ ( σ ( x ) ) … ) ( y … ) {\\displaystyle (\\,x\\,\\sigma (x)\\,\\sigma (\\sigma (x))\\,\\ldots \\,)(\\,y\\,\\ldots \\,)} Repeat until all elements of S are written in cycles. Also, it is common to omit 1-cycles, since these can be inferred: for any element x in S not appearing in any cycle, one implicitly assumes σ ( x ) = x {\\displaystyle \\sigma (x)=x} . Following the convention of omitting 1-cycles, one may interpret an individual cycle as a permutation which fixes all the elements not in the cycle (a cyclic permutation having only one cycle of length greater than 1). Then the list of disjoint cycles can be seen as the composition of these cyclic permutations.",
      "char_count": 901,
      "token_estimate": 225,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0016",
      "article_id": "permutation_56370258",
      "section": "== = Cycle notation ==",
      "heading_path": "== = Cycle notation ==",
      "start_char": 13054,
      "end_char": 13965,
      "content": "For example, the one-line permutation σ = 265431 {\\displaystyle \\sigma =265431} can be written in cycle notation as: σ = ( 126 ) ( 35 ) ( 4 ) = ( 126 ) ( 35 ) . {\\displaystyle \\sigma =(126)(35)(4)=(126)(35).} This may be seen as the composition σ = κ 1 κ 2 {\\displaystyle \\sigma =\\kappa _{1}\\kappa _{2}} of cyclic permutations: κ 1 = ( 126 ) = ( 126 ) ( 3 ) ( 4 ) ( 5 ) , κ 2 = ( 35 ) = ( 35 ) ( 1 ) ( 2 ) ( 6 ) . {\\displaystyle \\kappa _{1}=(126)=(126)(3)(4)(5),\\quad \\kappa _{2}=(35)=(35)(1)(2)(6).} While permutations in general do not commute, disjoint cycles do; for example: σ = ( 126 ) ( 35 ) = ( 35 ) ( 126 ) . {\\displaystyle \\sigma =(126)(35)=(35)(126).} Also, each cycle can be rewritten from a different starting point; for example, σ = ( 126 ) ( 35 ) = ( 261 ) ( 53 ) . {\\displaystyle \\sigma =(126)(35)=(261)(53).} Thus one may write the disjoint cycles of a given permutation in many different ways.",
      "char_count": 911,
      "token_estimate": 227,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0017",
      "article_id": "permutation_56370258",
      "section": "== = Cycle notation ==",
      "heading_path": "== = Cycle notation ==",
      "start_char": 13966,
      "end_char": 14255,
      "content": "A convenient feature of cycle notation is that inverting the permutation is given by reversing the order of the elements in each cycle. For example, σ − 1 = ( A 2 ( 126 ) ( 35 ) ) − 1 = ( 621 ) ( 53 ) . {\\displaystyle \\sigma ^{-1}=\\left({\\vphantom {A^{2}}}(126)(35)\\right)^{-1}=(621)(53).}",
      "char_count": 289,
      "token_estimate": 72,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0018",
      "article_id": "permutation_56370258",
      "section": "== = Canonical cycle notation ==",
      "heading_path": "== = Canonical cycle notation ==",
      "start_char": 14266,
      "end_char": 15132,
      "content": "== = Canonical cycle notation === In some combinatorial contexts it is useful to fix a certain order for the elements in the cycles and of the (disjoint) cycles themselves. Miklós Bóna calls the following ordering choices the canonical cycle notation: in each cycle the largest element is listed first the cycles are sorted in increasing order of their first element, not omitting 1-cycles For example, ( 513 ) ( 6 ) ( 827 ) ( 94 ) {\\displaystyle (513)(6)(827)(94)} is a permutation of S = { 1 , 2 , … , 9 } {\\displaystyle S=\\{1,2,\\ldots ,9\\}} in canonical cycle notation. Richard Stanley calls this the \"standard representation\" of a permutation, and Martin Aigner uses \"standard form\". Sergey Kitaev also uses the \"standard form\" terminology, but reverses both choices; that is, each cycle lists its minimal element first, and the cycles are sorted in decreasing order of their minimal elements.",
      "char_count": 897,
      "token_estimate": 224,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0019",
      "article_id": "permutation_56370258",
      "section": "== = Composition of permutations ==",
      "heading_path": "== = Composition of permutations ==",
      "start_char": 15167,
      "end_char": 16078,
      "content": "== = Composition of permutations === There are two ways to denote the composition of two permutations. In the most common notation, σ ⋅ τ {\\displaystyle \\sigma \\cdot \\tau } is the function that maps any element x to σ ( τ ( x ) ) {\\displaystyle \\sigma (\\tau (x))} . The rightmost permutation is applied to the argument first, because the argument is written to the right of the function. A different rule for multiplying permutations comes from writing the argument to the left of the function, so that the leftmost permutation acts first. In this notation, the permutation is often written as an exponent, so σ acting on x is written xσ; then the product is defined by x σ ⋅ τ = ( x σ ) τ {\\displaystyle x^{\\sigma \\cdot \\tau }=(x^{\\sigma })^{\\tau }} . This article uses the first definition, where the rightmost permutation is applied first. The function composition operation satisfies the axioms of a group.",
      "char_count": 910,
      "token_estimate": 227,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0020",
      "article_id": "permutation_56370258",
      "section": "== = Composition of permutations ==",
      "heading_path": "== = Composition of permutations ==",
      "start_char": 16078,
      "end_char": 16601,
      "content": "It is associative, meaning ( ρ σ ) τ = ρ ( σ τ ) {\\displaystyle (\\rho \\sigma )\\tau =\\rho (\\sigma \\tau )} , and products of more than two permutations are usually written without parentheses. The composition operation also has an identity element (the identity permutation id {\\displaystyle {\\text{id}}} ), and each permutation σ {\\displaystyle \\sigma } has an inverse σ − 1 {\\displaystyle \\sigma ^{-1}} (its inverse function) with σ − 1 σ = σ σ − 1 = id {\\displaystyle \\sigma ^{-1}\\sigma =\\sigma \\sigma ^{-1}={\\text{id}}} .",
      "char_count": 523,
      "token_estimate": 130,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0021",
      "article_id": "permutation_56370258",
      "section": "== = k-permutations of n ==",
      "heading_path": "== = k-permutations of n ==",
      "start_char": 16789,
      "end_char": 17647,
      "content": "== = k-permutations of n === In older literature and elementary textbooks, a k-permutation of n (sometimes called a partial permutation, sequence without repetition, variation, or arrangement) means an ordered arrangement (list) of a k-element subset of an n-set. The number of such k-permutations (k-arrangements) of n {\\displaystyle n} is denoted variously by such symbols as P k n {\\displaystyle P_{k}^{n}} , n P k {\\displaystyle _{n}P_{k}} , n P k {\\displaystyle ^{n}\\!P_{k}} , P n , k {\\displaystyle P_{n,k}} , P ( n , k ) {\\displaystyle P(n,k)} , or A n k {\\displaystyle A_{n}^{k}} , computed by the formula: P ( n , k ) = n ⋅ ( n − 1 ) ⋅ ( n − 2 ) ⋯ ( n − k + 1 ) ⏟ k f a c t o r s {\\displaystyle P(n,k)=\\underbrace {n\\cdot (n-1)\\cdot (n-2)\\cdots (n-k+1)} _{k\\ \\mathrm {factors} }} , which is 0 when k > n, and otherwise is equal to n ! ( n − k ) ! .",
      "char_count": 857,
      "token_estimate": 214,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0022",
      "article_id": "permutation_56370258",
      "section": "== = k-permutations of n ==",
      "heading_path": "== = k-permutations of n ==",
      "start_char": 17647,
      "end_char": 18589,
      "content": "{\\displaystyle {\\frac {n!}{(n-k)!}}.} The product is well defined without the assumption that n {\\displaystyle n} is a non-negative integer, and is of importance outside combinatorics as well; it is known as the Pochhammer symbol ( n ) k {\\displaystyle (n)_{k}} or as the k {\\displaystyle k} -th falling factorial power n k _ {\\displaystyle n^{\\underline {k}}} : P ( n , k ) = n P k = ( n ) k = n k _ . {\\displaystyle P(n,k)={_{n}}P_{k}=(n)_{k}=n^{\\underline {k}}.} This usage of the term permutation is closely associated with the term combination to mean a subset. A k-combination of a set S is a k-element subset of S: the elements of a combination are not ordered. Ordering the k-combinations of S in all possible ways produces the k-permutations of S. The number of k-combinations of an n-set, C(n,k), is therefore related to the number of k-permutations of n by: C ( n , k ) = P ( n , k ) P ( k , k ) = n k _ k ! = n ! ( n − k ) ! k ! .",
      "char_count": 942,
      "token_estimate": 235,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0023",
      "article_id": "permutation_56370258",
      "section": "== = k-permutations of n ==",
      "heading_path": "== = k-permutations of n ==",
      "start_char": 18590,
      "end_char": 18894,
      "content": "{\\displaystyle C(n,k)={\\frac {P(n,k)}{P(k,k)}}={\\frac {n^{\\underline {k}}}{k!}}={\\frac {n!}{(n-k)!\\,k!}}.} These numbers are also known as binomial coefficients, usually denoted ( n k ) {\\displaystyle {\\tbinom {n}{k}}} : C ( n , k ) = n C k = ( n k ) . {\\displaystyle C(n,k)={_{n}}C_{k}={\\binom {n}{k}}.}",
      "char_count": 304,
      "token_estimate": 76,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0024",
      "article_id": "permutation_56370258",
      "section": "== = Permutations with repetition ==",
      "heading_path": "== = Permutations with repetition ==",
      "start_char": 18904,
      "end_char": 19278,
      "content": "== = Permutations with repetition === Ordered arrangements of k elements of a set S, where repetition is allowed, are called k-tuples. They have sometimes been referred to as permutations with repetition, although they are not permutations in the usual sense. They are also called words or strings over the alphabet S. If the set S has n elements, the number of k-tuples over S is n k . {\\displaystyle n^{k}.}",
      "char_count": 409,
      "token_estimate": 102,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0025",
      "article_id": "permutation_56370258",
      "section": "== = Permutations of multisets ==",
      "heading_path": "== = Permutations of multisets ==",
      "start_char": 19311,
      "end_char": 20003,
      "content": "== = Permutations of multisets === If M is a finite multiset, then a multiset permutation is an ordered arrangement of elements of M in which each element appears a number of times equal exactly to its multiplicity in M. An anagram of a word having some repeated letters is an example of a multiset permutation. If the multiplicities of the elements of M (taken in some order) are m 1 {\\displaystyle m_{1}} , m 2 {\\displaystyle m_{2}} , ..., m l {\\displaystyle m_{l}} and their sum (that is, the size of M) is n, then the number of multiset permutations of M is given by the multinomial coefficient, ( n m 1 , m 2 , … , m l ) = n ! m 1 ! m 2 ! ⋯ m l ! = ( ∑ i = 1 l m i ) ! ∏ i = 1 l m i ! .",
      "char_count": 691,
      "token_estimate": 172,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0026",
      "article_id": "permutation_56370258",
      "section": "== = Permutations of multisets ==",
      "heading_path": "== = Permutations of multisets ==",
      "start_char": 20003,
      "end_char": 20523,
      "content": "{\\displaystyle {n \\choose m_{1},m_{2},\\ldots ,m_{l}}={\\frac {n!}{m_{1}!\\,m_{2}!\\,\\cdots \\,m_{l}!}}={\\frac {\\left(\\sum _{i=1}^{l}{m_{i}}\\right)!}{\\prod _{i=1}^{l}{m_{i}!}}}.} For example, the number of distinct anagrams of the word MISSISSIPPI is: 11 ! 1 ! 4 ! 4 ! 2 ! = 34650 {\\displaystyle {\\frac {11!}{1!\\,4!\\,4!\\,2!}}=34650} . A k-permutation of a multiset M is a sequence of k elements of M in which each element appears a number of times less than or equal to its multiplicity in M (an element's repetition number).",
      "char_count": 520,
      "token_estimate": 130,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0027",
      "article_id": "permutation_56370258",
      "section": "== = Circular permutations ==",
      "heading_path": "== = Circular permutations ==",
      "start_char": 20520,
      "end_char": 21313,
      "content": "== = Circular permutations === Permutations, when considered as arrangements, are sometimes referred to as linearly ordered arrangements. If, however, the objects are arranged in a circular manner this distinguished ordering is weakened: there is no \"first element\" in the arrangement, as any element can be considered as the start. An arrangement of distinct objects in a circular manner is called a circular permutation. These can be formally defined as equivalence classes of ordinary permutations of these objects, for the equivalence relation generated by moving the final element of the linear arrangement to its front. Two circular permutations are equivalent if one can be rotated into the other. The following four circular permutations on four letters are considered to be the same.",
      "char_count": 792,
      "token_estimate": 198,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0028",
      "article_id": "permutation_56370258",
      "section": "== = Circular permutations ==",
      "heading_path": "== = Circular permutations ==",
      "start_char": 21313,
      "end_char": 21573,
      "content": "1 4 2 3 4 3 2 1 3 4 1 2 2 3 1 4 The circular arrangements are to be read counter-clockwise, so the following two are not equivalent since no rotation can bring one to the other. 1 1 4 3 3 4 2 2 There are (n – 1)! circular permutations of a set with n elements.",
      "char_count": 260,
      "token_estimate": 65,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0029",
      "article_id": "permutation_56370258",
      "section": "== Properties ==",
      "heading_path": "== Properties ==",
      "start_char": 21561,
      "end_char": 21838,
      "content": "== Properties == The number of permutations of n distinct objects is n!. The number of n-permutations with k disjoint cycles is the signless Stirling number of the first kind, denoted c ( n , k ) {\\displaystyle c(n,k)} or [ n k ] {\\displaystyle [{\\begin{smallmatrix}n\\\\k\\end{smallmatrix}}]} .",
      "char_count": 292,
      "token_estimate": 73,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0030",
      "article_id": "permutation_56370258",
      "section": "== = Cycle type ==",
      "heading_path": "== = Cycle type ==",
      "start_char": 21856,
      "end_char": 22769,
      "content": "== = Cycle type === The cycles (including the fixed points) of a permutation σ {\\displaystyle \\sigma } of a set with n elements partition that set; so the lengths of these cycles form an integer partition of n, which is called the cycle type (or sometimes cycle structure or cycle shape) of σ {\\displaystyle \\sigma } . There is a \"1\" in the cycle type for every fixed point of σ {\\displaystyle \\sigma } , a \"2\" for every transposition, and so on. The cycle type of β = ( 1 2 5 ) ( 3 4 ) ( 6 8 ) ( 7 ) {\\displaystyle \\beta =(1\\,2\\,5\\,)(\\,3\\,4\\,)(6\\,8\\,)(\\,7\\,)} is ( 3 , 2 , 2 , 1 ) . {\\displaystyle (3,2,2,1).} This may also be written in a more compact form as . More precisely, the general form is [ 1 α 1 2 α 2 ⋯ n α n ] {\\displaystyle [1^{\\alpha _{1}}2^{\\alpha _{2}}\\dotsm n^{\\alpha _{n}}]} , where α 1 , … , α n {\\displaystyle \\alpha _{1},\\ldots ,\\alpha _{n}} are the numbers of cycles of respective length.",
      "char_count": 912,
      "token_estimate": 228,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0031",
      "article_id": "permutation_56370258",
      "section": "== = Cycle type ==",
      "heading_path": "== = Cycle type ==",
      "start_char": 22769,
      "end_char": 23220,
      "content": "The number of permutations of a given cycle type is n ! 1 α 1 2 α 2 ⋯ n α n α 1 ! α 2 ! ⋯ α n ! {\\displaystyle {\\frac {n!}{1^{\\alpha _{1}}2^{\\alpha _{2}}\\dotsm n^{\\alpha _{n}}\\alpha _{1}!\\alpha _{2}!\\dotsm \\alpha _{n}!}}} . The number of cycle types of a set with n elements equals the value of the partition function p ( n ) {\\displaystyle p(n)} . Polya's cycle index polynomial is a generating function which counts permutations by their cycle type.",
      "char_count": 451,
      "token_estimate": 112,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0032",
      "article_id": "permutation_56370258",
      "section": "== = Conjugating permutations ==",
      "heading_path": "== = Conjugating permutations ==",
      "start_char": 23235,
      "end_char": 24026,
      "content": "== = Conjugating permutations === In general, composing permutations written in cycle notation follows no easily described pattern – the cycles of the composition can be different from those being composed. However the cycle type is preserved in the special case of conjugating a permutation σ {\\displaystyle \\sigma } by another permutation π {\\displaystyle \\pi } , which means forming the product π σ π − 1 {\\displaystyle \\pi \\sigma \\pi ^{-1}} . Here, π σ π − 1 {\\displaystyle \\pi \\sigma \\pi ^{-1}} is the conjugate of σ {\\displaystyle \\sigma } by π {\\displaystyle \\pi } and its cycle notation can be obtained by taking the cycle notation for σ {\\displaystyle \\sigma } and applying π {\\displaystyle \\pi } to all the entries in it. It follows that two permutations are conjugate exactly when they have the same cycle type.",
      "char_count": 822,
      "token_estimate": 205,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0033",
      "article_id": "permutation_56370258",
      "section": "== = Order of a permutation ==",
      "heading_path": "== = Order of a permutation ==",
      "start_char": 24056,
      "end_char": 24408,
      "content": "== = Order of a permutation === The order of a permutation σ {\\displaystyle \\sigma } is the smallest positive integer m so that σ m = i d {\\displaystyle \\sigma ^{m}=\\mathrm {id} } . It is the least common multiple of the lengths of its cycles. For example, the order of σ = ( 152 ) ( 34 ) {\\displaystyle \\sigma =(152)(34)} is lcm ( 3 , 2 ) = 6 {\\displaystyle {\\text{lcm}}(3,2)=6} .",
      "char_count": 381,
      "token_estimate": 95,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0034",
      "article_id": "permutation_56370258",
      "section": "== = Parity of a permutation ==",
      "heading_path": "== = Parity of a permutation ==",
      "start_char": 24439,
      "end_char": 25264,
      "content": "== = Parity of a permutation === Every permutation of a finite set can be expressed as the product of transpositions. Although many such expressions for a given permutation may exist, either they all contain an even number of transpositions or they all contain an odd number of transpositions. Thus all permutations can be classified as even or odd depending on this number. This result can be extended so as to assign a sign, written sgn ⁡ σ {\\displaystyle \\operatorname {sgn} \\sigma } , to each permutation. sgn ⁡ σ = + 1 {\\displaystyle \\operatorname {sgn} \\sigma =+1} if σ {\\displaystyle \\sigma } is even and sgn ⁡ σ = − 1 {\\displaystyle \\operatorname {sgn} \\sigma =-1} if σ {\\displaystyle \\sigma } is odd. Then for two permutations σ {\\displaystyle \\sigma } and π {\\displaystyle \\pi } sgn ⁡ ( σ π ) = sgn ⁡ σ ⋅ sgn ⁡ π .",
      "char_count": 824,
      "token_estimate": 206,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0035",
      "article_id": "permutation_56370258",
      "section": "== = Parity of a permutation ==",
      "heading_path": "== = Parity of a permutation ==",
      "start_char": 25264,
      "end_char": 25575,
      "content": "{\\displaystyle \\operatorname {sgn} (\\sigma \\pi )=\\operatorname {sgn} \\sigma \\cdot \\operatorname {sgn} \\pi .} It follows that sgn ⁡ ( σ σ − 1 ) = + 1. {\\displaystyle \\operatorname {sgn} \\left(\\sigma \\sigma ^{-1}\\right)=+1.} The sign of a permutation is equal to the determinant of its permutation matrix (below).",
      "char_count": 311,
      "token_estimate": 77,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0036",
      "article_id": "permutation_56370258",
      "section": "== = Matrix representation ==",
      "heading_path": "== = Matrix representation ==",
      "start_char": 25574,
      "end_char": 26441,
      "content": "== = Matrix representation === A permutation matrix is an n × n matrix that has exactly one entry 1 in each column and in each row, and all other entries are 0. There are several ways to assign a permutation matrix to a permutation of {1, 2, ..., n}. One natural approach is to define L σ {\\displaystyle L_{\\sigma }} to be the linear transformation of R n {\\displaystyle \\mathbb {R} ^{n}} which permutes the standard basis { e 1 , … , e n } {\\displaystyle \\{\\mathbf {e} _{1},\\ldots ,\\mathbf {e} _{n}\\}} by L σ ( e j ) = e σ ( j ) {\\displaystyle L_{\\sigma }(\\mathbf {e} _{j})=\\mathbf {e} _{\\sigma (j)}} , and define M σ {\\displaystyle M_{\\sigma }} to be its matrix. That is, M σ {\\displaystyle M_{\\sigma }} has its jth column equal to the n × 1 column vector e σ ( j ) {\\displaystyle \\mathbf {e} _{\\sigma (j)}} : its (i, j) entry is to 1 if i = σ(j), and 0 otherwise.",
      "char_count": 866,
      "token_estimate": 216,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0037",
      "article_id": "permutation_56370258",
      "section": "== = Matrix representation ==",
      "heading_path": "== = Matrix representation ==",
      "start_char": 26441,
      "end_char": 27422,
      "content": "Since composition of linear mappings is described by matrix multiplication, it follows that this construction is compatible with composition of permutations: M σ M τ = M σ τ {\\displaystyle M_{\\sigma }M_{\\tau }=M_{\\sigma \\tau }} . For example, the one-line permutations σ = 213 , τ = 231 {\\displaystyle \\sigma =213,\\ \\tau =231} have product σ τ = 132 {\\displaystyle \\sigma \\tau =132} , and the corresponding matrices are: M σ M τ = ( 0 1 0 1 0 0 0 0 1 ) ( 0 0 1 1 0 0 0 1 0 ) = ( 1 0 0 0 0 1 0 1 0 ) = M σ τ . {\\displaystyle M_{\\sigma }M_{\\tau }={\\begin{pmatrix}0&1&0\\\\1&0&0\\\\0&0&1\\end{pmatrix}}{\\begin{pmatrix}0&0&1\\\\1&0&0\\\\0&1&0\\end{pmatrix}}={\\begin{pmatrix}1&0&0\\\\0&0&1\\\\0&1&0\\end{pmatrix}}=M_{\\sigma \\tau }.} It is also common in the literature to find the inverse convention, where a permutation σ is associated to the matrix P σ = ( M σ ) − 1 = ( M σ ) T {\\displaystyle P_{\\sigma }=(M_{\\sigma })^{-1}=(M_{\\sigma })^{T}} whose (i, j) entry is 1 if j = σ(i) and is 0 otherwise.",
      "char_count": 981,
      "token_estimate": 245,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0038",
      "article_id": "permutation_56370258",
      "section": "== = Matrix representation ==",
      "heading_path": "== = Matrix representation ==",
      "start_char": 27423,
      "end_char": 27962,
      "content": "In this convention, permutation matrices multiply in the opposite order from permutations, that is, P σ P τ = P τ σ {\\displaystyle P_{\\sigma }P_{\\tau }=P_{\\tau \\sigma }} . In this correspondence, permutation matrices act on the right side of the standard 1 × n {\\displaystyle 1\\times n} row vectors ( e i ) T {\\displaystyle ({\\bf {e}}_{i})^{T}} : ( e i ) T P σ = ( e σ ( i ) ) T {\\displaystyle ({\\bf {e}}_{i})^{T}P_{\\sigma }=({\\bf {e}}_{\\sigma (i)})^{T}} . The Cayley table on the right shows these matrices for permutations of 3 elements.",
      "char_count": 539,
      "token_estimate": 134,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0039",
      "article_id": "permutation_56370258",
      "section": "== Permutations of totally ordered sets ==",
      "heading_path": "== Permutations of totally ordered sets ==",
      "start_char": 27976,
      "end_char": 28519,
      "content": "== Permutations of totally ordered sets == In some applications, the elements of the set being permuted will be compared with each other. This requires that the set S has a total order so that any two elements can be compared. The set {1, 2, ..., n} with the usual ≤ relation is the most frequently used set in these applications. A number of properties of a permutation are directly related to the total ordering of S, considering the permutation written in one-line notation as a sequence σ = σ ( 1 ) σ ( 2 ) ⋯ σ ( n ) {\\displaystyle \\sigma =\\sigma (1)\\sigma (2)\\cdots \\sigma (n)} .",
      "char_count": 584,
      "token_estimate": 146,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0040",
      "article_id": "permutation_56370258",
      "section": "== = Ascents, descents, runs, exceedances, records ==",
      "heading_path": "== = Ascents, descents, runs, exceedances, records ==",
      "start_char": 28572,
      "end_char": 29327,
      "content": "== = Ascents, descents, runs, exceedances, records === An ascent of a permutation σ of n is any position i < n where the following value is bigger than the current one. That is, i is an ascent if σ ( i ) < σ ( i + 1 ) {\\displaystyle \\sigma (i)<\\sigma (i{+}1)} . For example, the permutation 3452167 has ascents (at positions) 1, 2, 5, and 6. Similarly, a descent is a position i < n with σ ( i ) > σ ( i + 1 ) {\\displaystyle \\sigma (i)>\\sigma (i{+}1)} , so every i with 1 ≤ i < n {\\displaystyle 1\\leq i j. If the inequality is not strict (that is, σj ≥ j), then j is called a weak exceedance. The number of n-permutations with k exceedances coincides with the number of n-permutations with k descents. A record or left-to-right maximum of a permutation σ is an element i such that σ(j) < σ(i) for all j < i.",
      "char_count": 807,
      "token_estimate": 201,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0041",
      "article_id": "permutation_56370258",
      "section": "== = Foata's transition lemma ==",
      "heading_path": "== = Foata's transition lemma ==",
      "start_char": 29359,
      "end_char": 30153,
      "content": "== = Foata's transition lemma === Foata's fundamental bijection transforms a permutation σ with a given canonical cycle form into the permutation f ( σ ) = σ ^ {\\displaystyle f(\\sigma )={\\hat {\\sigma }}} whose one-line notation has the same sequence of elements with parentheses removed. For example: σ = ( 513 ) ( 6 ) ( 827 ) ( 94 ) = ( 1 2 3 4 5 6 7 8 9 3 7 5 9 1 6 8 2 4 ) , {\\displaystyle \\sigma =(513)(6)(827)(94)={\\begin{pmatrix}1&2&3&4&5&6&7&8&9\\\\3&7&5&9&1&6&8&2&4\\end{pmatrix}},} σ ^ = 513682794 = ( 1 2 3 4 5 6 7 8 9 5 1 3 6 8 2 7 9 4 ) . {\\displaystyle {\\hat {\\sigma }}=513682794={\\begin{pmatrix}1&2&3&4&5&6&7&8&9\\\\5&1&3&6&8&2&7&9&4\\end{pmatrix}}.} Here the first element in each canonical cycle of σ becomes a record (left-to-right maximum) of σ ^ {\\displaystyle {\\hat {\\sigma }}} .",
      "char_count": 793,
      "token_estimate": 198,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0042",
      "article_id": "permutation_56370258",
      "section": "== = Foata's transition lemma ==",
      "heading_path": "== = Foata's transition lemma ==",
      "start_char": 30153,
      "end_char": 30888,
      "content": "Given σ ^ {\\displaystyle {\\hat {\\sigma }}} , one may find its records and insert parentheses to construct the inverse transformation σ = f − 1 ( σ ^ ) {\\displaystyle \\sigma =f^{-1}({\\hat {\\sigma }})} . Underlining the records in the above example: σ ^ = 5 _ 1 3 6 _ 8 _ 2 7 9 _ 4 {\\displaystyle {\\hat {\\sigma }}={\\underline {5}}\\,1\\,3\\,{\\underline {6}}\\,{\\underline {8}}\\,2\\,7\\,{\\underline {9}}\\,4} , which allows the reconstruction of the cycles of σ. The following table shows σ ^ {\\displaystyle {\\hat {\\sigma }}} and σ for the six permutations of S = {1, 2, 3}, with the bold text on each side showing the notation used in the bijection: one-line notation for σ ^ {\\displaystyle {\\hat {\\sigma }}} and canonical cycle notation for σ.",
      "char_count": 735,
      "token_estimate": 183,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0043",
      "article_id": "permutation_56370258",
      "section": "== = Foata's transition lemma ==",
      "heading_path": "== = Foata's transition lemma ==",
      "start_char": 30889,
      "end_char": 31875,
      "content": "σ ^ = f ( σ ) σ = f − 1 ( σ ^ ) 123 = ( 1 ) ( 2 ) ( 3 ) 123 = ( 1 ) ( 2 ) ( 3 ) 132 = ( 1 ) ( 3 2 ) 132 = ( 1 ) ( 3 2 ) 213 = ( 2 1 ) ( 3 ) 213 = ( 2 1 ) ( 3 ) 231 = ( 3 1 2 ) 321 = ( 2 ) ( 3 1 ) 312 = ( 3 2 1 ) 231 = ( 3 1 2 ) 321 = ( 2 ) ( 3 1 ) 312 = ( 3 2 1 ) {\\displaystyle {\\begin{array}{l|l}{\\hat {\\sigma }}=f(\\sigma )&\\sigma =f^{-1}({\\hat {\\sigma }})\\\\\\hline \\mathbf {123} =(\\,1\\,)(\\,2\\,)(\\,3\\,)&123=\\mathbf {(\\,1\\,)(\\,2\\,)(\\,3\\,)} \\\\\\mathbf {132} =(\\,1\\,)(\\,3\\,2\\,)&132=\\mathbf {(\\,1\\,)(\\,3\\,2\\,)} \\\\\\mathbf {213} =(\\,2\\,1\\,)(\\,3\\,)&213=\\mathbf {(\\,2\\,1\\,)(\\,3\\,)} \\\\\\mathbf {231} =(\\,3\\,1\\,2\\,)&321=\\mathbf {(\\,2\\,)(\\,3\\,1\\,)} \\\\\\mathbf {312} =(\\,3\\,2\\,1\\,)&231=\\mathbf {(\\,3\\,1\\,2\\,)} \\\\\\mathbf {321} =(\\,2\\,)(\\,3\\,1\\,)&312=\\mathbf {(\\,3\\,2\\,1\\,)} \\end{array}}} As a first corollary, the number of n-permutations with exactly k records is equal to the number of n-permutations with exactly k cycles: this last number is the signless Stirling number of the first kind, c ( n ,",
      "char_count": 986,
      "token_estimate": 246,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0044",
      "article_id": "permutation_56370258",
      "section": "== = Foata's transition lemma ==",
      "heading_path": "== = Foata's transition lemma ==",
      "start_char": 31876,
      "end_char": 32172,
      "content": "k ) {\\displaystyle c(n,k)} . Furthermore, Foata's mapping takes an n-permutation with k weak exceedances to an n-permutation with k − 1 ascents. For example, (2)(31) = 321 has k = 2 weak exceedances (at index 1 and 2), whereas f(321) = 231 has k − 1 = 1 ascent (at index 1; that is, from 2 to 3).",
      "char_count": 296,
      "token_estimate": 74,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0045",
      "article_id": "permutation_56370258",
      "section": "== = Inversions ==",
      "heading_path": "== = Inversions ==",
      "start_char": 32159,
      "end_char": 32926,
      "content": "== = Inversions === An inversion of a permutation σ is a pair (i, j) of positions where the entries of a permutation are in the opposite order: i < j {\\displaystyle i σ ( j ) {\\displaystyle \\sigma (i)>\\sigma (j)} . Thus a descent is an inversion at two adjacent positions. For example, σ = 23154 has (i, j) = (1, 3), (2, 3), and (4, 5), where (σ(i), σ(j)) = (2, 1), (3, 1), and (5, 4). Sometimes an inversion is defined as the pair of values (σ(i), σ(j)); this makes no difference for the number of inversions, and the reverse pair (σ(j), σ(i)) is an inversion in the above sense for the inverse permutation σ−1. The number of inversions is an important measure for the degree to which the entries of a permutation are out of order; it is the same for σ and for σ−1.",
      "char_count": 766,
      "token_estimate": 191,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0046",
      "article_id": "permutation_56370258",
      "section": "== = Inversions ==",
      "heading_path": "== = Inversions ==",
      "start_char": 32926,
      "end_char": 33794,
      "content": "To bring a permutation with k inversions into order (that is, transform it into the identity permutation), by successively applying (right-multiplication by) adjacent transpositions, is always possible and requires a sequence of k such operations. Moreover, any reasonable choice for the adjacent transpositions will work: it suffices to choose at each step a transposition of i and i + 1 where i is a descent of the permutation as modified so far (so that the transposition will remove this particular descent, although it might create other descents). This is so because applying such a transposition reduces the number of inversions by 1; as long as this number is not zero, the permutation is not the identity, so it has at least one descent. Bubble sort and insertion sort can be interpreted as particular instances of this procedure to put a sequence into order.",
      "char_count": 868,
      "token_estimate": 217,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0047",
      "article_id": "permutation_56370258",
      "section": "== = Inversions ==",
      "heading_path": "== = Inversions ==",
      "start_char": 33795,
      "end_char": 34750,
      "content": "Incidentally this procedure proves that any permutation σ can be written as a product of adjacent transpositions; for this one may simply reverse any sequence of such transpositions that transforms σ into the identity. In fact, by enumerating all sequences of adjacent transpositions that would transform σ into the identity, one obtains (after reversal) a complete list of all expressions of minimal length writing σ as a product of adjacent transpositions. The number of permutations of n with k inversions is expressed by a Mahonian number. This is the coefficient of q k {\\displaystyle q^{k}} in the expansion of the product [ n ] q ! = ∏ m = 1 n ∑ i = 0 m − 1 q i = 1 ( 1 + q ) ( 1 + q + q 2 ) ⋯ ( 1 + q + q 2 + ⋯ + q n − 1 ) , {\\displaystyle [n]_{q}!=\\prod _{m=1}^{n}\\sum _{i=0}^{m-1}q^{i}=1\\left(1+q\\right)\\left(1+q+q^{2}\\right)\\cdots \\left(1+q+q^{2}+\\cdots +q^{n-1}\\right),} The notation [ n ] q ! {\\displaystyle [n]_{q}!} denotes the q-factorial.",
      "char_count": 955,
      "token_estimate": 238,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0048",
      "article_id": "permutation_56370258",
      "section": "== = Inversions ==",
      "heading_path": "== = Inversions ==",
      "start_char": 34751,
      "end_char": 35555,
      "content": "This expansion commonly appears in the study of necklaces. Let σ ∈ S n , i , j ∈ { 1 , 2 , … , n } {\\displaystyle \\sigma \\in S_{n},i,j\\in \\{1,2,\\dots ,n\\}} such that i < j {\\displaystyle i σ ( j ) {\\displaystyle \\sigma (i)>\\sigma (j)} . In this case, say the weight of the inversion ( i , j ) {\\displaystyle (i,j)} is σ ( i ) − σ ( j ) {\\displaystyle \\sigma (i)-\\sigma (j)} . Kobayashi (2011) proved the enumeration formula ∑ i < j , σ ( i ) > σ ( j ) ( σ ( i ) − σ ( j ) ) = | { τ ∈ S n ∣ τ ≤ σ , τ is bigrassmannian } {\\displaystyle \\sum _{i \\sigma (j)}(\\sigma (i)-\\sigma (j))=|\\{\\tau \\in S_{n}\\mid \\tau \\leq \\sigma ,\\tau {\\text{ is bigrassmannian}}\\}} where ≤ {\\displaystyle \\leq } denotes Bruhat order in the symmetric groups. This graded partial order often appears in the context of Coxeter groups.",
      "char_count": 804,
      "token_estimate": 201,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0049",
      "article_id": "permutation_56370258",
      "section": "== = Numbering permutations ==",
      "heading_path": "== = Numbering permutations ==",
      "start_char": 35600,
      "end_char": 36383,
      "content": "== = Numbering permutations === One way to represent permutations of n things is by an integer N with 0 ≤ N < n!, provided convenient methods are given to convert between the number and the representation of a permutation as an ordered arrangement (sequence). This gives the most compact representation of arbitrary permutations, and in computing is particularly attractive when n is small enough that N can be held in a machine word; for 32-bit words this means n ≤ 12, and for 64-bit words this means n ≤ 20. The conversion can be done via the intermediate form of a sequence of numbers dn, dn−1, ..., d2, d1, where di is a non-negative integer less than i (one may omit d1, as it is always 0, but its presence makes the subsequent conversion to a permutation easier to describe).",
      "char_count": 782,
      "token_estimate": 195,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0050",
      "article_id": "permutation_56370258",
      "section": "== = Numbering permutations ==",
      "heading_path": "== = Numbering permutations ==",
      "start_char": 36383,
      "end_char": 37294,
      "content": "The first step then is to simply express N in the factorial number system, which is just a particular mixed radix representation, where, for numbers less than n!, the bases (place values or multiplication factors) for successive digits are (n − 1)!, (n − 2)!, ..., 2!, 1!. The second step interprets this sequence as a Lehmer code or (almost equivalently) as an inversion table. In the Lehmer code for a permutation σ, the number dn represents the choice made for the first term σ1, the number dn−1 represents the choice made for the second term σ2 among the remaining n − 1 elements of the set, and so forth. More precisely, each dn+1−i gives the number of remaining elements strictly less than the term σi. Since those remaining elements are bound to turn up as some later term σj, the digit dn+1−i counts the inversions (i,j) involving i as smaller index (the number of values j for which i < j and σi > σj).",
      "char_count": 911,
      "token_estimate": 227,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0051",
      "article_id": "permutation_56370258",
      "section": "== = Numbering permutations ==",
      "heading_path": "== = Numbering permutations ==",
      "start_char": 37295,
      "end_char": 38048,
      "content": "The inversion table for σ is quite similar, but here dn+1−k counts the number of inversions (i,j) where k = σj occurs as the smaller of the two values appearing in inverted order. Both encodings can be visualized by an n by n Rothe diagram (named after Heinrich August Rothe) in which dots at (i,σi) mark the entries of the permutation, and a cross at (i,σj) marks the inversion (i,j); by the definition of inversions a cross appears in any square that comes both before the dot (j,σj) in its column, and before the dot (i,σi) in its row. The Lehmer code lists the numbers of crosses in successive rows, while the inversion table lists the numbers of crosses in successive columns; it is just the Lehmer code for the inverse permutation, and vice versa.",
      "char_count": 753,
      "token_estimate": 188,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0052",
      "article_id": "permutation_56370258",
      "section": "== = Numbering permutations ==",
      "heading_path": "== = Numbering permutations ==",
      "start_char": 38049,
      "end_char": 39012,
      "content": "To effectively convert a Lehmer code dn, dn−1, ..., d2, d1 into a permutation of an ordered set S, one can start with a list of the elements of S in increasing order, and for i increasing from 1 to n set σi to the element in the list that is preceded by dn+1−i other ones, and remove that element from the list. To convert an inversion table dn, dn−1, ..., d2, d1 into the corresponding permutation, one can traverse the numbers from d1 to dn while inserting the elements of S from largest to smallest into an initially empty sequence; at the step using the number d from the inversion table, the element from S inserted into the sequence at the point where it is preceded by d elements already present. Alternatively one could process the numbers from the inversion table and the elements of S both in the opposite order, starting with a row of n empty slots, and at each step place the element from S into the empty slot that is preceded by d other empty slots.",
      "char_count": 963,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0053",
      "article_id": "permutation_56370258",
      "section": "== = Numbering permutations ==",
      "heading_path": "== = Numbering permutations ==",
      "start_char": 39013,
      "end_char": 39680,
      "content": "Converting successive natural numbers to the factorial number system produces those sequences in lexicographic order (as is the case with any mixed radix number system), and further converting them to permutations preserves the lexicographic ordering, provided the Lehmer code interpretation is used (using inversion tables, one gets a different ordering, where one starts by comparing permutations by the place of their entries 1 rather than by the value of their first entries). The sum of the numbers in the factorial number system representation gives the number of inversions of the permutation, and the parity of that sum gives the signature of the permutation.",
      "char_count": 667,
      "token_estimate": 166,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0054",
      "article_id": "permutation_56370258",
      "section": "== = Numbering permutations ==",
      "heading_path": "== = Numbering permutations ==",
      "start_char": 39681,
      "end_char": 40164,
      "content": "Moreover, the positions of the zeroes in the inversion table give the values of left-to-right maxima of the permutation (in the example 6, 8, 9) while the positions of the zeroes in the Lehmer code are the positions of the right-to-left minima (in the example positions the 4, 8, 9 of the values 1, 2, 5); this allows computing the distribution of such extrema among all permutations. A permutation with Lehmer code dn, dn−1, ..., d2, d1 has an ascent n − i if and only if di ≥ di+1.",
      "char_count": 483,
      "token_estimate": 120,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0055",
      "article_id": "permutation_56370258",
      "section": "== = Algorithms to generate permutations ==",
      "heading_path": "== = Algorithms to generate permutations ==",
      "start_char": 40178,
      "end_char": 40905,
      "content": "== = Algorithms to generate permutations === In computing it may be required to generate permutations of a given sequence of values. The methods best adapted to do this depend on whether one wants some randomly chosen permutations, or all permutations, and in the latter case if a specific ordering is required. Another question is whether possible equality among entries in the given sequence is to be taken into account; if so, one should only generate distinct multiset permutations of the sequence. An obvious way to generate permutations of n is to generate values for the Lehmer code (possibly using the factorial number system representation of integers up to n!), and convert those into the corresponding permutations.",
      "char_count": 726,
      "token_estimate": 181,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0056",
      "article_id": "permutation_56370258",
      "section": "== = Algorithms to generate permutations ==",
      "heading_path": "== = Algorithms to generate permutations ==",
      "start_char": 40905,
      "end_char": 41717,
      "content": "However, the latter step, while straightforward, is hard to implement efficiently, because it requires n operations each of selection from a sequence and deletion from it, at an arbitrary position; of the obvious representations of the sequence as an array or a linked list, both require (for different reasons) about n2/4 operations to perform the conversion. With n likely to be rather small (especially if generation of all permutations is needed) that is not too much of a problem, but it turns out that both for random and for systematic generation there are simple alternatives that do considerably better. For this reason it does not seem useful, although certainly possible, to employ a special data structure that would allow performing the conversion from Lehmer code to permutation in O(n log n) time.",
      "char_count": 812,
      "token_estimate": 203,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "permutation_56370258_c0057",
      "article_id": "permutation_56370258",
      "section": "== = Applications ==",
      "heading_path": "== = Applications ==",
      "start_char": 41695,
      "end_char": 42189,
      "content": "== = Applications === Permutations are used in the interleaver component of the error detection and correction algorithms, such as turbo codes, for example 3GPP Long Term Evolution mobile telecommunication standard uses these ideas (see 3GPP technical specification 36.212). Such applications raise the question of fast generation of permutations satisfying certain desirable properties. One of the methods is based on the permutation polynomials. Also as a base for optimal hashing in Unique Permutation Hashing.",
      "char_count": 513,
      "token_estimate": 128,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 10,
    "items": [
      {
        "question": "What information is provided about == = Foata's transition lemma ==?",
        "answer": "The text provides information about == = Foata's transition lemma == as described in the relevant chunks.",
        "related_chunk_ids": [
          "permutation_56370258_c0043"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "permutation_56370258_c0043"
        ]
      },
      {
        "question": "What information is provided about == = Matrix representation ==?",
        "answer": "The text provides information about == = Matrix representation == as described in the relevant chunks.",
        "related_chunk_ids": [
          "permutation_56370258_c0037"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "permutation_56370258_c0037"
        ]
      },
      {
        "question": "What is a permutation with no fixed points called?",
        "answer": "A permutation with no fixed points is called a derangement.",
        "related_chunk_ids": [
          "permutation_56370258_c0009"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "permutation_56370258_c0009"
        ]
      },
      {
        "question": "What are the two distinct meanings of a permutation in mathematics?",
        "answer": "A permutation of a set can refer to two different concepts. The first is an arrangement of the set's members in a specific sequence or linear order; for example, (1, 3, 2) is a permutation of the set {1, 2, 3}. The second meaning is the act of changing the linear order, which is formally defined as a bijection from the set to itself—a function where each element of the set is mapped to a unique element within the same set.",
        "related_chunk_ids": [
          "permutation_56370258_c0000",
          "permutation_56370258_c0001"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "permutation_56370258_c0000",
          "permutation_56370258_c0001"
        ]
      },
      {
        "question": "Trace the development of the method for calculating the number of permutations, from its early appearance in Indian culture to its later description by Fabian Stedman.",
        "answer": "The rule to determine the number of permutations of n objects was known in Indian culture around 1150 AD. The Indian mathematician Bhāskara II's work, the Lilavati, described this calculation as the product of the arithmetical series starting at one and increasing by unity up to the number of places. Later, in 1677, Fabian Stedman described factorials using a recursive process while explaining the number of permutations of bells in change ringing.",
        "related_chunk_ids": [
          "permutation_56370258_c0003",
          "permutation_56370258_c0004"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "permutation_56370258_c0004",
          "permutation_56370258_c0003"
        ]
      },
      {
        "question": "How did the work of Joseph Louis Lagrange on permutations influence the development of Galois theory?",
        "answer": "Around 1770, Joseph Louis Lagrange observed that the properties of the permutations of a polynomial equation's roots are related to the possibilities of solving it. This line of work ultimately led to the development of Galois theory by Évariste Galois, which provides a complete description of what is possible when solving polynomial equations by radicals.",
        "related_chunk_ids": [
          "permutation_56370258_c0005",
          "permutation_56370258_c0006"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "permutation_56370258_c0006",
          "permutation_56370258_c0005"
        ]
      },
      {
        "question": "What are the two distinct meanings of a permutation, and how is one of these meanings formally defined as a function?",
        "answer": "A permutation can refer to two different concepts: first, an arrangement of a set's members in a sequence or linear order, and second, the act or process of changing that linear order. The second meaning is formally defined as a bijection from a set S to itself. This is a function where every element of the set occurs exactly once as an image value, which is equivalent to rearranging the set's elements.",
        "related_chunk_ids": [
          "permutation_56370258_c0000",
          "permutation_56370258_c0001"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "permutation_56370258_c0001",
          "permutation_56370258_c0000"
        ]
      },
      {
        "question": "Trace the evolution of the application of permutations from early combinatorial problems to abstract algebra and modern cryptography.",
        "answer": "The application of permutations began with early combinatorial problems, such as their use in the Chinese I Ching (1000 BC), counting Greek syllables (Xenocrates), and listing Arabic words (Al-Khalil). This evolved into methods for calculating the total number of permutations, as seen in Indian culture around 1150 AD and later in Fabian Stedman's 1677 work on change ringing, which described factorials. A significant shift occurred around 1770 when Joseph Louis Lagrange applied permutations to the abstract algebraic problem of studying the roots of polynomial equations. This line of work led to Galois theory and the development of group theory. In the 20th century, permutations played a crucial role in modern applications like cryptanalysis, specifically in breaking the German Enigma cipher during World War II.",
        "related_chunk_ids": [
          "permutation_56370258_c0003",
          "permutation_56370258_c0004",
          "permutation_56370258_c0005",
          "permutation_56370258_c0006"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "permutation_56370258_c0006",
          "permutation_56370258_c0003",
          "permutation_56370258_c0005",
          "permutation_56370258_c0004"
        ]
      },
      {
        "question": "What is the distinction between an identity permutation and a fixed point of a permutation?",
        "answer": "An identity permutation is a specific permutation defined by σ(x) = x for all elements x in a set S. In contrast, a fixed point is an individual element x that is mapped to itself by a given permutation σ, such that σ(x) = x. Therefore, while every element of a set is a fixed point under the identity permutation, a general permutation may have some, none, or only one fixed point.",
        "related_chunk_ids": [
          "permutation_56370258_c0007",
          "permutation_56370258_c0009"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "permutation_56370258_c0009",
          "permutation_56370258_c0007"
        ]
      },
      {
        "question": "How is one-line notation for a permutation derived from two-line notation, and what is a specific example of this conversion?",
        "answer": "When the elements of a set have a \"natural\" order, the two-line notation uses this order for its first row. To convert to one-line notation, this first row is omitted, leaving only the second row. For example, the two-line permutation σ = (1 2 3 4 5 6 / 2 6 5 4 3 1) is converted to the one-line notation 265431.",
        "related_chunk_ids": [
          "permutation_56370258_c0012",
          "permutation_56370258_c0013"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "permutation_56370258_c0012",
          "permutation_56370258_c0013"
        ]
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-31T06:36:50.404Z",
    "content_format": "markdown",
    "total_chunks": 58,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}