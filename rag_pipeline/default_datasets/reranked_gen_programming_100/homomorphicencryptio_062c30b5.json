{
  "article": {
    "id": "homomorphicencryptio_062c30b5",
    "title": "Homomorphic encryption",
    "url": "https://en.wikipedia.org/wiki/Homomorphic_encryption",
    "lang": "en",
    "created_at": "2025-07-30T10:37:16.798752",
    "content": "---\nid: homomorphicencryptio_062c30b5\nurl: https://en.wikipedia.org/wiki/Homomorphic_encryption\ntitle: Homomorphic encryption\nlang: en\ncreated_at: '2025-07-30T10:36:42.462613'\nchecksum: e2a10c080aa8b2312e90b853c7134b290d125633456f73ce779dddcd5b29ec2c\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 2\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 2950\n  char_count: 20062\n  num_chunks: 24\n  original_chunks: 31\n  filtered_out: 7\n  num_sections: 0\n---\nHomomorphic encryption is a form of encryption that allows computations to be performed on encrypted data without first having to decrypt it. The resulting computations are left in an encrypted form which, when decrypted, result in an output that is identical to that of the operations performed on the unencrypted data. While homomorphic encryption does not protect against side-channel attacks that observe behavior, it can be used for privacy-preserving outsourced storage and computation. This allows data to be encrypted and outsourced to commercial cloud environments for processing, all while encrypted. As an example of a practical application of homomorphic encryption: encrypted photographs can be scanned for points of interest, without revealing the contents of a photo. However, observation of side-channels can see a photograph being sent to a point-of-interest lookup service, revealing the fact that photographs were taken. Thus, homomorphic encryption eliminates the need for processing data in the clear, thereby preventing attacks that would enable an attacker to access that data while it is being processed, using privilege escalation. For sensitive data, such as healthcare information, homomorphic encryption can be used to enable new services by removing privacy barriers inhibiting data sharing or increasing security to existing services. For example, predictive analytics in healthcare can be hard to apply via a third-party service provider due to medical data privacy concerns. But if the predictive-analytics service provider could operate on encrypted data instead, without having the decryption keys, these privacy concerns are diminished. Moreover, even if the service provider's system is compromised, the data would remain secure. == Description == Homomorphic encryption is a form of encryption with an additional evaluation capability for computing over encrypted data without access to the secret key. The result of such a computation remains encrypted. Homomorphic encryption can be viewed as an extension of public-key cryptography. Homomorphic refers to homomorphism in algebra: the encryption and decryption functions can be thought of as homomorphisms between plaintext and ciphertext spaces. Homomorphic encryption includes multiple types of encryption schemes that can perform different classes of computations over encrypted data. The computations are represented as either Boolean or arithmetic circuits. Some common types of homomorphic encryption are partially homomorphic, somewhat homomorphic, leveled fully homomorphic, and fully homomorphic encryption: Partially homomorphic encryption encompasses schemes that support the evaluation of circuits consisting of only one type of gate, e.g., addition or multiplication. Somewhat homomorphic encryption schemes can evaluate two types of gates, but only for a subset of circuits. Leveled fully homomorphic encryption supports the evaluation of arbitrary circuits composed of multiple types of gates of bounded (pre-determined) depth. Fully homomorphic encryption (FHE) allows the evaluation of arbitrary circuits composed of multiple types of gates of unbounded depth and is the strongest notion of homomorphic encryption. For the majority of homomorphic encryption schemes, the multiplicative depth of circuits is the main practical limitation in performing computations over encrypted data. Homomorphic encryption schemes are inherently malleable. In terms of malleability, homomorphic encryption schemes have weaker security properties than non-homomorphic schemes. == History == Homomorphic encryption schemes have been developed using different approaches. Specifically, fully homomorphic encryption schemes are often grouped into generations corresponding to the underlying approach. === Pre-FHE === The problem of constructing a fully homomorphic encryption scheme was first proposed in 1978, within a year of publishing of the RSA scheme. For more than 30 years, it was unclear whether a solution existed. During that period, partial results included the following schemes: RSA cryptosystem (unbounded number of modular multiplications) ElGamal cryptosystem (unbounded number of modular multiplications) Goldwasser–Micali cryptosystem (unbounded number of exclusive or operations) Benaloh cryptosystem (unbounded number of modular additions) Paillier cryptosystem (unbounded number of modular additions) Sander-Young-Yung system (after more than 20 years solved the problem for logarithmic depth circuits) Boneh–Goh–Nissim cryptosystem (unlimited number of addition operations but at most one multiplication) Ishai-Paskin cryptosystem (polynomial-size branching programs) === First-generation FHE === Craig Gentry, using lattice-based cryptography, described the first plausible construction for a fully homomorphic encryption scheme in 2009. Gentry's scheme supports both addition and multiplication operations on ciphertexts, from which it is possible to construct circuits for performing arbitrary computation. The construction starts from a somewhat homomorphic encryption scheme, which is limited to evaluating low-degree polynomials over encrypted data; it is limited because each ciphertext is noisy in some sense, and this noise grows as one adds and multiplies ciphertexts, until ultimately the noise makes the resulting ciphertext indecipherable. Gentry then shows how to slightly modify this scheme to make it bootstrappable, i.e., capable of evaluating its own decryption circuit and then at least one more operation. Finally, he shows that any bootstrappable somewhat homomorphic encryption scheme can be converted into a fully homomorphic encryption through a recursive self-embedding. For Gentry's \"noisy\" scheme, the bootstrapping procedure effectively \"refreshes\" the ciphertext by applying to it the decryption procedure homomorphically, thereby obtaining a new ciphertext that encrypts the same value as before but has lower noise. By \"refreshing\" the ciphertext periodically whenever the noise grows too large, it is possible to compute an arbitrary number of additions and multiplications without increasing the noise too much. Gentry based the security of his scheme on the assumed hardness of two problems: certain worst-case problems over ideal lattices, and the sparse (or low-weight) subset sum problem. Gentry's Ph.D. thesis provides additional details. The Gentry-Halevi implementation of Gentry's original cryptosystem reported a timing of about 30 minutes per basic bit operation. Extensive design and implementation work in subsequent years have improved upon these early implementations by many orders of magnitude runtime performance. In 2010, Marten van Dijk, Craig Gentry, Shai Halevi and Vinod Vaikuntanathan presented a second fully homomorphic encryption scheme, which uses many of the tools of Gentry's construction, but which does not require ideal lattices. Instead, they show that the somewhat homomorphic component of Gentry's ideal lattice-based scheme can be replaced with a very simple somewhat homomorphic scheme that uses integers. The scheme is therefore conceptually simpler than Gentry's ideal lattice scheme, but has similar properties with regards to homomorphic operations and efficiency. The somewhat homomorphic component in the work of Van Dijk et al. is similar to an encryption scheme proposed by Levieil and Naccache in 2008, and also to one that was proposed by Bram Cohen in 1998. Cohen's method is not even additively homomorphic, however. The Levieil–Naccache scheme supports only additions, but it can be modified to also support a small number of multiplications. Many refinements and optimizations of the scheme of Van Dijk et al. were proposed in a sequence of works by Jean-Sébastien Coron, Tancrède Lepoint, Avradip Mandal, David Naccache, and Mehdi Tibouchi. Some of these works included also implementations of the resulting schemes. === Second-generation FHE === The homomorphic cryptosystems of this generation are derived from techniques that were developed starting in 2011–2012 by Zvika Brakerski, Craig Gentry, Vinod Vaikuntanathan, and others. These innovations led to the development of much more efficient somewhat and fully homomorphic cryptosystems. These include: The Brakerski-Gentry-Vaikuntanathan (BGV, 2011) scheme, building on techniques of Brakerski-Vaikuntanathan; The NTRU-based scheme by Lopez-Alt, Tromer, and Vaikuntanathan (LTV, 2012); The Brakerski/Fan-Vercauteren (BFV, 2012) scheme, building on Brakerski's scale-invariant cryptosystem; The NTRU-based scheme by Bos, Lauter, Loftus, and Naehrig (BLLN, 2013), building on LTV and Brakerski's scale-invariant cryptosystem; The security of most of these schemes is based on the hardness of the (Ring) Learning With Errors (RLWE) problem, except for the LTV and BLLN schemes that rely on an overstretched variant of the NTRU computational problem. This NTRU variant was subsequently shown vulnerable to subfield lattice attacks, which is why these two schemes are no longer used in practice. All the second-generation cryptosystems still follow the basic blueprint of Gentry's original construction, namely they first construct a somewhat homomorphic cryptosystem and then convert it to a fully homomorphic cryptosystem using bootstrapping. A distinguishing characteristic of the second-generation cryptosystems is that they all feature a much slower growth of the noise during the homomorphic computations. Additional optimizations by Craig Gentry, Shai Halevi, and Nigel Smart resulted in cryptosystems with nearly optimal asymptotic complexity: Performing T {\\displaystyle T} operations on data encrypted with security parameter k {\\displaystyle k} has complexity of only T ⋅ p o l y l o g ( k ) {\\displaystyle T\\cdot \\mathrm {polylog} (k)} . These optimizations build on the Smart-Vercauteren techniques that enable packing of many plaintext values in a single ciphertext and operating on all these plaintext values in a SIMD fashion. Many of the advances in these second-generation cryptosystems were also ported to the cryptosystem over the integers. Another distinguishing feature of second-generation schemes is that they are efficient enough for many applications even without invoking bootstrapping, instead operating in the leveled FHE mode. === Third-generation FHE === In 2013, Craig Gentry, Amit Sahai, and Brent Waters (GSW) proposed a new technique for building FHE schemes that avoids an expensive \"relinearization\" step in homomorphic multiplication. Zvika Brakerski and Vinod Vaikuntanathan observed that for certain types of circuits, the GSW cryptosystem features an even slower growth rate of noise, and hence better efficiency and stronger security. Jacob Alperin-Sheriff and Chris Peikert then described a very efficient bootstrapping technique based on this observation. These techniques were further improved to develop efficient ring variants of the GSW cryptosystem: FHEW (2014) and TFHE (2016). The FHEW scheme was the first to show that by refreshing the ciphertexts after every single operation, it is possible to reduce the bootstrapping time to a fraction of a second. FHEW introduced a new method to compute Boolean gates on encrypted data that greatly simplifies bootstrapping and implemented a variant of the bootstrapping procedure. The efficiency of FHEW was further improved by the TFHE scheme, which implements a ring variant of the bootstrapping procedure using a method similar to the one in FHEW. === Fourth-generation FHE === In 2016, Jung Hee Cheon, Andrey Kim, Miran Kim, and Yongsoo Song (CKKS) proposed an approximate homomorphic encryption scheme that supports a special kind of fixed-point arithmetic that is commonly referred to as block floating point arithmetic. The CKKS scheme includes an efficient rescaling operation that scales down an encrypted message after a multiplication. For comparison, such rescaling requires bootstrapping in the BGV and BFV schemes. The rescaling operation makes CKKS scheme the most efficient method for evaluating polynomial approximations, and is the preferred approach for implementing privacy-preserving machine learning applications. The scheme introduces several approximation errors, both nondeterministic and deterministic, that require special handling in practice. A 2020 article by Baiyu Li and Daniele Micciancio discusses passive attacks against CKKS, suggesting that the standard IND-CPA definition may not be sufficient in scenarios where decryption results are shared. The authors apply the attack to four modern homomorphic encryption libraries (HEAAN, SEAL, HElib and PALISADE) and report that it is possible to recover the secret key from decryption results in several parameter configurations. The authors also propose mitigation strategies for these attacks, and include a Responsible Disclosure in the paper suggesting that the homomorphic encryption libraries already implemented mitigations for the attacks before the article became publicly available. Further information on the mitigation strategies implemented in the homomorphic encryption libraries has also been published. == Partially homomorphic cryptosystems == In the following examples, the notation E ( x ) {\\displaystyle {\\mathcal {E}}(x)} is used to denote the encryption of the message x {\\displaystyle x} . Unpadded RSA If the RSA public key has modulus n {\\displaystyle n} and encryption exponent e {\\displaystyle e} , then the encryption of a message m {\\displaystyle m} is given by E ( m ) = m e mod n {\\displaystyle {\\mathcal {E}}(m)=m^{e}\\;{\\bmod {\\;}}n} . The homomorphic property is then E ( m 1 ) ⋅ E ( m 2 ) = m 1 e m 2 e mod n = ( m 1 m 2 ) e mod n = E ( m 1 ⋅ m 2 ) {\\displaystyle {\\begin{aligned}{\\mathcal {E}}(m_{1})\\cdot {\\mathcal {E}}(m_{2})&=m_{1}^{e}m_{2}^{e}\\;{\\bmod {\\;}}n\\\\[6pt]&=(m_{1}m_{2})^{e}\\;{\\bmod {\\;}}n\\\\[6pt]&={\\mathcal {E}}(m_{1}\\cdot m_{2})\\end{aligned}}} ElGamal In the ElGamal cryptosystem, in a cyclic group G {\\displaystyle G} of order q {\\displaystyle q} with generator g {\\displaystyle g} , if the public key is ( G , q , g , h ) {\\displaystyle (G,q,g,h)} , where h = g x {\\displaystyle h=g^{x}} , and x {\\displaystyle x} is the secret key, then the encryption of a message m {\\displaystyle m} is E ( m ) = ( g r , m ⋅ h r ) {\\displaystyle {\\mathcal {E}}(m)=(g^{r},m\\cdot h^{r})} , for some random r ∈ { 0 , … , q − 1 } {\\displaystyle r\\in \\{0,\\ldots ,q-1\\}} . The homomorphic property is then E ( m 1 ) ⋅ E ( m 2 ) = ( g r 1 , m 1 ⋅ h r 1 ) ( g r 2 , m 2 ⋅ h r 2 ) = ( g r 1 + r 2 , ( m 1 ⋅ m 2 ) h r 1 + r 2 ) = E ( m 1 ⋅ m 2 ) . {\\displaystyle {\\begin{aligned}{\\mathcal {E}}(m_{1})\\cdot {\\mathcal {E}}(m_{2})&=(g^{r_{1}},m_{1}\\cdot h^{r_{1}})(g^{r_{2}},m_{2}\\cdot h^{r_{2}})\\\\[6pt]&=(g^{r_{1}+r_{2}},(m_{1}\\cdot m_{2})h^{r_{1}+r_{2}})\\\\[6pt]&={\\mathcal {E}}(m_{1}\\cdot m_{2}).\\end{aligned}}} Goldwasser–Micali In the Goldwasser–Micali cryptosystem, if the public key is the modulus n {\\displaystyle n} and quadratic non-residue x {\\displaystyle x} , then the encryption of a bit b {\\displaystyle b} is E ( b ) = x b r 2 mod n {\\displaystyle {\\mathcal {E}}(b)=x^{b}r^{2}\\;{\\bmod {\\;}}n} , for some random r ∈ { 0 , … , n − 1 } {\\displaystyle r\\in \\{0,\\ldots ,n-1\\}} . The homomorphic property is then E ( b 1 ) ⋅ E ( b 2 ) = x b 1 r 1 2 x b 2 r 2 2 mod n = x b 1 + b 2 ( r 1 r 2 ) 2 mod n = E ( b 1 ⊕ b 2 ) . {\\displaystyle {\\begin{aligned}{\\mathcal {E}}(b_{1})\\cdot {\\mathcal {E}}(b_{2})&=x^{b_{1}}r_{1}^{2}x^{b_{2}}r_{2}^{2}\\;{\\bmod {\\;}}n\\\\[6pt]&=x^{b_{1}+b_{2}}(r_{1}r_{2})^{2}\\;{\\bmod {\\;}}n\\\\[6pt]&={\\mathcal {E}}(b_{1}\\oplus b_{2}).\\end{aligned}}} where ⊕ {\\displaystyle \\oplus } denotes addition modulo 2, (i.e., exclusive-or). Benaloh In the Benaloh cryptosystem, if the public key is the modulus n {\\displaystyle n} and the base g {\\displaystyle g} with a blocksize of c {\\displaystyle c} , then the encryption of a message m {\\displaystyle m} is E ( m ) = g m r c mod n {\\displaystyle {\\mathcal {E}}(m)=g^{m}r^{c}\\;{\\bmod {\\;}}n} , for some random r ∈ { 0 , … , n − 1 } {\\displaystyle r\\in \\{0,\\ldots ,n-1\\}} . The homomorphic property is then E ( m 1 ) ⋅ E ( m 2 ) = ( g m 1 r 1 c ) ( g m 2 r 2 c ) mod n = g m 1 + m 2 ( r 1 r 2 ) c mod n = E ( m 1 + m 2 mod c ) . {\\displaystyle {\\begin{aligned}{\\mathcal {E}}(m_{1})\\cdot {\\mathcal {E}}(m_{2})&=(g^{m_{1}}r_{1}^{c})(g^{m_{2}}r_{2}^{c})\\;{\\bmod {\\;}}n\\\\[6pt]&=g^{m_{1}+m_{2}}(r_{1}r_{2})^{c}\\;{\\bmod {\\;}}n\\\\[6pt]&={\\mathcal {E}}(m_{1}+m_{2}\\;{\\bmod {\\;}}c).\\end{aligned}}} Paillier In the Paillier cryptosystem, if the public key is the modulus n {\\displaystyle n} and the base g {\\displaystyle g} , then the encryption of a message m {\\displaystyle m} is E ( m ) = g m r n mod n 2 {\\displaystyle {\\mathcal {E}}(m)=g^{m}r^{n}\\;{\\bmod {\\;}}n^{2}} , for some random r ∈ { 0 , … , n − 1 } {\\displaystyle r\\in \\{0,\\ldots ,n-1\\}} . The homomorphic property is then E ( m 1 ) ⋅ E ( m 2 ) = ( g m 1 r 1 n ) ( g m 2 r 2 n ) mod n 2 = g m 1 + m 2 ( r 1 r 2 ) n mod n 2 = E ( m 1 + m 2 ) . {\\displaystyle {\\begin{aligned}{\\mathcal {E}}(m_{1})\\cdot {\\mathcal {E}}(m_{2})&=(g^{m_{1}}r_{1}^{n})(g^{m_{2}}r_{2}^{n})\\;{\\bmod {\\;}}n^{2}\\\\[6pt]&=g^{m_{1}+m_{2}}(r_{1}r_{2})^{n}\\;{\\bmod {\\;}}n^{2}\\\\[6pt]&={\\mathcal {E}}(m_{1}+m_{2}).\\end{aligned}}} Other partially homomorphic cryptosystems Okamoto–Uchiyama cryptosystem Naccache–Stern cryptosystem Damgård–Jurik cryptosystem Sander–Young–Yung encryption scheme Boneh–Goh–Nissim cryptosystem Ishai–Paskin cryptosystem Joye-Libert cryptosystem Castagnos–Laguillaumie cryptosystem == Fully homomorphic encryption == A cryptosystem that supports arbitrary computation on ciphertexts is known as fully homomorphic encryption (FHE). Such a scheme enables the construction of programs for any desirable functionality, which can be run on encrypted inputs to produce an encryption of the result. Since such a program need never decrypt its inputs, it can be run by an untrusted party without revealing its inputs and internal state. Fully homomorphic cryptosystems have great practical implications in the outsourcing of private computations, for instance, in the context of cloud computing. === Implementations === A list of open-source FHE libraries implementing second-generation (BGV/BFV), third-generation (FHEW/TFHE), and/or fourth-generation (CKKS) FHE schemes is provided below. There are several open-source implementations of fully homomorphic encryption schemes. Second-generation and fourth-generation FHE scheme implementations typically operate in the leveled FHE mode (though bootstrapping is still available in some libraries) and support efficient SIMD-like packing of data; they are typically used to compute on encrypted integers or real/complex numbers. Third-generation FHE scheme implementations often bootstrap after each operation but have limited support for packing; they were initially used to compute Boolean circuits over encrypted bits, but have been extended to support integer arithmetics and univariate function evaluation. The choice of using a second-generation vs. third-generation vs fourth-generation scheme depends on the input data types and the desired computation. === Standardization === In 2017, researchers from IBM, Microsoft, Intel, the NIST, and others formed the open Homomorphic Encryption Standardization Consortium, which maintains a community security Homomorphic Encryption Standard. == See also == Homomorphic secret sharing Homomorphic signatures for network coding Private biometrics Verifiable computing using a fully homomorphic scheme Client-side encryption Confidential computing Searchable symmetric encryption Secure multi-party computation Format-preserving encryption Polymorphic code Private set intersection == References == == External links == FHE.org Community (conference, meetup and discussion group) Daniele Micciancio's FHE references Vinod Vaikuntanathan's FHE references \"Alice and Bob in Cipherspace\". American Scientist. September 2012. Retrieved 2018-05-08. A list of homomorphic encryption implementations maintained on GitHub"
  },
  "chunks": [
    {
      "id": "homomorphicencryptio_062c30b5_c0000",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 940,
      "content": "Homomorphic encryption is a form of encryption that allows computations to be performed on encrypted data without first having to decrypt it. The resulting computations are left in an encrypted form which, when decrypted, result in an output that is identical to that of the operations performed on the unencrypted data. While homomorphic encryption does not protect against side-channel attacks that observe behavior, it can be used for privacy-preserving outsourced storage and computation. This allows data to be encrypted and outsourced to commercial cloud environments for processing, all while encrypted. As an example of a practical application of homomorphic encryption: encrypted photographs can be scanned for points of interest, without revealing the contents of a photo. However, observation of side-channels can see a photograph being sent to a point-of-interest lookup service, revealing the fact that photographs were taken.",
      "char_count": 939,
      "token_estimate": 234,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0001",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 940,
      "end_char": 1765,
      "content": "Thus, homomorphic encryption eliminates the need for processing data in the clear, thereby preventing attacks that would enable an attacker to access that data while it is being processed, using privilege escalation. For sensitive data, such as healthcare information, homomorphic encryption can be used to enable new services by removing privacy barriers inhibiting data sharing or increasing security to existing services. For example, predictive analytics in healthcare can be hard to apply via a third-party service provider due to medical data privacy concerns. But if the predictive-analytics service provider could operate on encrypted data instead, without having the decryption keys, these privacy concerns are diminished. Moreover, even if the service provider's system is compromised, the data would remain secure.",
      "char_count": 825,
      "token_estimate": 206,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0002",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== Description ==",
      "heading_path": "== Description ==",
      "start_char": 1783,
      "end_char": 2469,
      "content": "== Description == Homomorphic encryption is a form of encryption with an additional evaluation capability for computing over encrypted data without access to the secret key. The result of such a computation remains encrypted. Homomorphic encryption can be viewed as an extension of public-key cryptography. Homomorphic refers to homomorphism in algebra: the encryption and decryption functions can be thought of as homomorphisms between plaintext and ciphertext spaces. Homomorphic encryption includes multiple types of encryption schemes that can perform different classes of computations over encrypted data. The computations are represented as either Boolean or arithmetic circuits.",
      "char_count": 685,
      "token_estimate": 171,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0003",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== Description ==",
      "heading_path": "== Description ==",
      "start_char": 2469,
      "end_char": 3464,
      "content": "Some common types of homomorphic encryption are partially homomorphic, somewhat homomorphic, leveled fully homomorphic, and fully homomorphic encryption: Partially homomorphic encryption encompasses schemes that support the evaluation of circuits consisting of only one type of gate, e.g., addition or multiplication. Somewhat homomorphic encryption schemes can evaluate two types of gates, but only for a subset of circuits. Leveled fully homomorphic encryption supports the evaluation of arbitrary circuits composed of multiple types of gates of bounded (pre-determined) depth. Fully homomorphic encryption (FHE) allows the evaluation of arbitrary circuits composed of multiple types of gates of unbounded depth and is the strongest notion of homomorphic encryption. For the majority of homomorphic encryption schemes, the multiplicative depth of circuits is the main practical limitation in performing computations over encrypted data. Homomorphic encryption schemes are inherently malleable.",
      "char_count": 995,
      "token_estimate": 248,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0004",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = Pre-FHE ==",
      "heading_path": "== = Pre-FHE ==",
      "start_char": 3803,
      "end_char": 4679,
      "content": "== = Pre-FHE === The problem of constructing a fully homomorphic encryption scheme was first proposed in 1978, within a year of publishing of the RSA scheme. For more than 30 years, it was unclear whether a solution existed. During that period, partial results included the following schemes: RSA cryptosystem (unbounded number of modular multiplications) ElGamal cryptosystem (unbounded number of modular multiplications) Goldwasser–Micali cryptosystem (unbounded number of exclusive or operations) Benaloh cryptosystem (unbounded number of modular additions) Paillier cryptosystem (unbounded number of modular additions) Sander-Young-Yung system (after more than 20 years solved the problem for logarithmic depth circuits) Boneh–Goh–Nissim cryptosystem (unlimited number of addition operations but at most one multiplication) Ishai-Paskin cryptosystem (polynomial-size branching programs)",
      "char_count": 890,
      "token_estimate": 222,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0005",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = First-generation FHE ==",
      "heading_path": "== = First-generation FHE ==",
      "start_char": 4707,
      "end_char": 5566,
      "content": "== = First-generation FHE === Craig Gentry, using lattice-based cryptography, described the first plausible construction for a fully homomorphic encryption scheme in 2009. Gentry's scheme supports both addition and multiplication operations on ciphertexts, from which it is possible to construct circuits for performing arbitrary computation. The construction starts from a somewhat homomorphic encryption scheme, which is limited to evaluating low-degree polynomials over encrypted data; it is limited because each ciphertext is noisy in some sense, and this noise grows as one adds and multiplies ciphertexts, until ultimately the noise makes the resulting ciphertext indecipherable. Gentry then shows how to slightly modify this scheme to make it bootstrappable, i.e., capable of evaluating its own decryption circuit and then at least one more operation.",
      "char_count": 858,
      "token_estimate": 214,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0006",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = First-generation FHE ==",
      "heading_path": "== = First-generation FHE ==",
      "start_char": 5566,
      "end_char": 6546,
      "content": "Finally, he shows that any bootstrappable somewhat homomorphic encryption scheme can be converted into a fully homomorphic encryption through a recursive self-embedding. For Gentry's \"noisy\" scheme, the bootstrapping procedure effectively \"refreshes\" the ciphertext by applying to it the decryption procedure homomorphically, thereby obtaining a new ciphertext that encrypts the same value as before but has lower noise. By \"refreshing\" the ciphertext periodically whenever the noise grows too large, it is possible to compute an arbitrary number of additions and multiplications without increasing the noise too much. Gentry based the security of his scheme on the assumed hardness of two problems: certain worst-case problems over ideal lattices, and the sparse (or low-weight) subset sum problem. Gentry's Ph.D. thesis provides additional details. The Gentry-Halevi implementation of Gentry's original cryptosystem reported a timing of about 30 minutes per basic bit operation.",
      "char_count": 980,
      "token_estimate": 245,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0007",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = First-generation FHE ==",
      "heading_path": "== = First-generation FHE ==",
      "start_char": 6547,
      "end_char": 7538,
      "content": "Extensive design and implementation work in subsequent years have improved upon these early implementations by many orders of magnitude runtime performance. In 2010, Marten van Dijk, Craig Gentry, Shai Halevi and Vinod Vaikuntanathan presented a second fully homomorphic encryption scheme, which uses many of the tools of Gentry's construction, but which does not require ideal lattices. Instead, they show that the somewhat homomorphic component of Gentry's ideal lattice-based scheme can be replaced with a very simple somewhat homomorphic scheme that uses integers. The scheme is therefore conceptually simpler than Gentry's ideal lattice scheme, but has similar properties with regards to homomorphic operations and efficiency. The somewhat homomorphic component in the work of Van Dijk et al. is similar to an encryption scheme proposed by Levieil and Naccache in 2008, and also to one that was proposed by Bram Cohen in 1998. Cohen's method is not even additively homomorphic, however.",
      "char_count": 991,
      "token_estimate": 247,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0008",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = First-generation FHE ==",
      "heading_path": "== = First-generation FHE ==",
      "start_char": 7539,
      "end_char": 7941,
      "content": "The Levieil–Naccache scheme supports only additions, but it can be modified to also support a small number of multiplications. Many refinements and optimizations of the scheme of Van Dijk et al. were proposed in a sequence of works by Jean-Sébastien Coron, Tancrède Lepoint, Avradip Mandal, David Naccache, and Mehdi Tibouchi. Some of these works included also implementations of the resulting schemes.",
      "char_count": 402,
      "token_estimate": 100,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0009",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = Second-generation FHE ==",
      "heading_path": "== = Second-generation FHE ==",
      "start_char": 7943,
      "end_char": 8708,
      "content": "== = Second-generation FHE === The homomorphic cryptosystems of this generation are derived from techniques that were developed starting in 2011–2012 by Zvika Brakerski, Craig Gentry, Vinod Vaikuntanathan, and others. These innovations led to the development of much more efficient somewhat and fully homomorphic cryptosystems. These include: The Brakerski-Gentry-Vaikuntanathan (BGV, 2011) scheme, building on techniques of Brakerski-Vaikuntanathan; The NTRU-based scheme by Lopez-Alt, Tromer, and Vaikuntanathan (LTV, 2012); The Brakerski/Fan-Vercauteren (BFV, 2012) scheme, building on Brakerski's scale-invariant cryptosystem; The NTRU-based scheme by Bos, Lauter, Loftus, and Naehrig (BLLN, 2013), building on LTV and Brakerski's scale-invariant cryptosystem;",
      "char_count": 764,
      "token_estimate": 191,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0010",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = Second-generation FHE ==",
      "heading_path": "== = Second-generation FHE ==",
      "start_char": 8708,
      "end_char": 9490,
      "content": "The security of most of these schemes is based on the hardness of the (Ring) Learning With Errors (RLWE) problem, except for the LTV and BLLN schemes that rely on an overstretched variant of the NTRU computational problem. This NTRU variant was subsequently shown vulnerable to subfield lattice attacks, which is why these two schemes are no longer used in practice. All the second-generation cryptosystems still follow the basic blueprint of Gentry's original construction, namely they first construct a somewhat homomorphic cryptosystem and then convert it to a fully homomorphic cryptosystem using bootstrapping. A distinguishing characteristic of the second-generation cryptosystems is that they all feature a much slower growth of the noise during the homomorphic computations.",
      "char_count": 782,
      "token_estimate": 195,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0011",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = Second-generation FHE ==",
      "heading_path": "== = Second-generation FHE ==",
      "start_char": 9491,
      "end_char": 10335,
      "content": "Additional optimizations by Craig Gentry, Shai Halevi, and Nigel Smart resulted in cryptosystems with nearly optimal asymptotic complexity: Performing T {\\displaystyle T} operations on data encrypted with security parameter k {\\displaystyle k} has complexity of only T ⋅ p o l y l o g ( k ) {\\displaystyle T\\cdot \\mathrm {polylog} (k)} . These optimizations build on the Smart-Vercauteren techniques that enable packing of many plaintext values in a single ciphertext and operating on all these plaintext values in a SIMD fashion. Many of the advances in these second-generation cryptosystems were also ported to the cryptosystem over the integers. Another distinguishing feature of second-generation schemes is that they are efficient enough for many applications even without invoking bootstrapping, instead operating in the leveled FHE mode.",
      "char_count": 844,
      "token_estimate": 211,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0012",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = Third-generation FHE ==",
      "heading_path": "== = Third-generation FHE ==",
      "start_char": 10335,
      "end_char": 11185,
      "content": "== = Third-generation FHE === In 2013, Craig Gentry, Amit Sahai, and Brent Waters (GSW) proposed a new technique for building FHE schemes that avoids an expensive \"relinearization\" step in homomorphic multiplication. Zvika Brakerski and Vinod Vaikuntanathan observed that for certain types of circuits, the GSW cryptosystem features an even slower growth rate of noise, and hence better efficiency and stronger security. Jacob Alperin-Sheriff and Chris Peikert then described a very efficient bootstrapping technique based on this observation. These techniques were further improved to develop efficient ring variants of the GSW cryptosystem: FHEW (2014) and TFHE (2016). The FHEW scheme was the first to show that by refreshing the ciphertexts after every single operation, it is possible to reduce the bootstrapping time to a fraction of a second.",
      "char_count": 849,
      "token_estimate": 212,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0013",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = Third-generation FHE ==",
      "heading_path": "== = Third-generation FHE ==",
      "start_char": 11185,
      "end_char": 11522,
      "content": "FHEW introduced a new method to compute Boolean gates on encrypted data that greatly simplifies bootstrapping and implemented a variant of the bootstrapping procedure. The efficiency of FHEW was further improved by the TFHE scheme, which implements a ring variant of the bootstrapping procedure using a method similar to the one in FHEW.",
      "char_count": 337,
      "token_estimate": 84,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0014",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = Fourth-generation FHE ==",
      "heading_path": "== = Fourth-generation FHE ==",
      "start_char": 11524,
      "end_char": 12346,
      "content": "== = Fourth-generation FHE === In 2016, Jung Hee Cheon, Andrey Kim, Miran Kim, and Yongsoo Song (CKKS) proposed an approximate homomorphic encryption scheme that supports a special kind of fixed-point arithmetic that is commonly referred to as block floating point arithmetic. The CKKS scheme includes an efficient rescaling operation that scales down an encrypted message after a multiplication. For comparison, such rescaling requires bootstrapping in the BGV and BFV schemes. The rescaling operation makes CKKS scheme the most efficient method for evaluating polynomial approximations, and is the preferred approach for implementing privacy-preserving machine learning applications. The scheme introduces several approximation errors, both nondeterministic and deterministic, that require special handling in practice.",
      "char_count": 821,
      "token_estimate": 205,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0015",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = Fourth-generation FHE ==",
      "heading_path": "== = Fourth-generation FHE ==",
      "start_char": 12346,
      "end_char": 13173,
      "content": "A 2020 article by Baiyu Li and Daniele Micciancio discusses passive attacks against CKKS, suggesting that the standard IND-CPA definition may not be sufficient in scenarios where decryption results are shared. The authors apply the attack to four modern homomorphic encryption libraries (HEAAN, SEAL, HElib and PALISADE) and report that it is possible to recover the secret key from decryption results in several parameter configurations. The authors also propose mitigation strategies for these attacks, and include a Responsible Disclosure in the paper suggesting that the homomorphic encryption libraries already implemented mitigations for the attacks before the article became publicly available. Further information on the mitigation strategies implemented in the homomorphic encryption libraries has also been published.",
      "char_count": 827,
      "token_estimate": 206,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0016",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== Partially homomorphic cryptosystems ==",
      "heading_path": "== Partially homomorphic cryptosystems ==",
      "start_char": 13186,
      "end_char": 14137,
      "content": "== Partially homomorphic cryptosystems == In the following examples, the notation E ( x ) {\\displaystyle {\\mathcal {E}}(x)} is used to denote the encryption of the message x {\\displaystyle x} . Unpadded RSA If the RSA public key has modulus n {\\displaystyle n} and encryption exponent e {\\displaystyle e} , then the encryption of a message m {\\displaystyle m} is given by E ( m ) = m e mod n {\\displaystyle {\\mathcal {E}}(m)=m^{e}\\;{\\bmod {\\;}}n} . The homomorphic property is then E ( m 1 ) ⋅ E ( m 2 ) = m 1 e m 2 e mod n = ( m 1 m 2 ) e mod n = E ( m 1 ⋅ m 2 ) {\\displaystyle {\\begin{aligned}{\\mathcal {E}}(m_{1})\\cdot {\\mathcal {E}}(m_{2})&=m_{1}^{e}m_{2}^{e}\\;{\\bmod {\\;}}n\\\\[6pt]&=(m_{1}m_{2})^{e}\\;{\\bmod {\\;}}n\\\\[6pt]&={\\mathcal {E}}(m_{1}\\cdot m_{2})\\end{aligned}}} ElGamal In the ElGamal cryptosystem, in a cyclic group G {\\displaystyle G} of order q {\\displaystyle q} with generator g {\\displaystyle g} , if the public key is ( G , q , g ,",
      "char_count": 950,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0017",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== Partially homomorphic cryptosystems ==",
      "heading_path": "== Partially homomorphic cryptosystems ==",
      "start_char": 14137,
      "end_char": 14642,
      "content": "h ) {\\displaystyle (G,q,g,h)} , where h = g x {\\displaystyle h=g^{x}} , and x {\\displaystyle x} is the secret key, then the encryption of a message m {\\displaystyle m} is E ( m ) = ( g r , m ⋅ h r ) {\\displaystyle {\\mathcal {E}}(m)=(g^{r},m\\cdot h^{r})} , for some random r ∈ { 0 , … , q − 1 } {\\displaystyle r\\in \\{0,\\ldots ,q-1\\}} . The homomorphic property is then E ( m 1 ) ⋅ E ( m 2 ) = ( g r 1 , m 1 ⋅ h r 1 ) ( g r 2 , m 2 ⋅ h r 2 ) = ( g r 1 + r 2 , ( m 1 ⋅ m 2 ) h r 1 + r 2 ) = E ( m 1 ⋅ m 2 ) .",
      "char_count": 505,
      "token_estimate": 126,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0018",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== Partially homomorphic cryptosystems ==",
      "heading_path": "== Partially homomorphic cryptosystems ==",
      "start_char": 14643,
      "end_char": 15421,
      "content": "{\\displaystyle {\\begin{aligned}{\\mathcal {E}}(m_{1})\\cdot {\\mathcal {E}}(m_{2})&=(g^{r_{1}},m_{1}\\cdot h^{r_{1}})(g^{r_{2}},m_{2}\\cdot h^{r_{2}})\\\\[6pt]&=(g^{r_{1}+r_{2}},(m_{1}\\cdot m_{2})h^{r_{1}+r_{2}})\\\\[6pt]&={\\mathcal {E}}(m_{1}\\cdot m_{2}).\\end{aligned}}} Goldwasser–Micali In the Goldwasser–Micali cryptosystem, if the public key is the modulus n {\\displaystyle n} and quadratic non-residue x {\\displaystyle x} , then the encryption of a bit b {\\displaystyle b} is E ( b ) = x b r 2 mod n {\\displaystyle {\\mathcal {E}}(b)=x^{b}r^{2}\\;{\\bmod {\\;}}n} , for some random r ∈ { 0 , … , n − 1 } {\\displaystyle r\\in \\{0,\\ldots ,n-1\\}} . The homomorphic property is then E ( b 1 ) ⋅ E ( b 2 ) = x b 1 r 1 2 x b 2 r 2 2 mod n = x b 1 + b 2 ( r 1 r 2 ) 2 mod n = E ( b 1 ⊕ b 2 ) .",
      "char_count": 778,
      "token_estimate": 194,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0019",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== Partially homomorphic cryptosystems ==",
      "heading_path": "== Partially homomorphic cryptosystems ==",
      "start_char": 15422,
      "end_char": 16289,
      "content": "{\\displaystyle {\\begin{aligned}{\\mathcal {E}}(b_{1})\\cdot {\\mathcal {E}}(b_{2})&=x^{b_{1}}r_{1}^{2}x^{b_{2}}r_{2}^{2}\\;{\\bmod {\\;}}n\\\\[6pt]&=x^{b_{1}+b_{2}}(r_{1}r_{2})^{2}\\;{\\bmod {\\;}}n\\\\[6pt]&={\\mathcal {E}}(b_{1}\\oplus b_{2}).\\end{aligned}}} where ⊕ {\\displaystyle \\oplus } denotes addition modulo 2, (i.e., exclusive-or). Benaloh In the Benaloh cryptosystem, if the public key is the modulus n {\\displaystyle n} and the base g {\\displaystyle g} with a blocksize of c {\\displaystyle c} , then the encryption of a message m {\\displaystyle m} is E ( m ) = g m r c mod n {\\displaystyle {\\mathcal {E}}(m)=g^{m}r^{c}\\;{\\bmod {\\;}}n} , for some random r ∈ { 0 , … , n − 1 } {\\displaystyle r\\in \\{0,\\ldots ,n-1\\}} . The homomorphic property is then E ( m 1 ) ⋅ E ( m 2 ) = ( g m 1 r 1 c ) ( g m 2 r 2 c ) mod n = g m 1 + m 2 ( r 1 r 2 ) c mod n = E ( m 1 + m 2 mod c ) .",
      "char_count": 867,
      "token_estimate": 216,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0020",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== Partially homomorphic cryptosystems ==",
      "heading_path": "== Partially homomorphic cryptosystems ==",
      "start_char": 16290,
      "end_char": 17055,
      "content": "{\\displaystyle {\\begin{aligned}{\\mathcal {E}}(m_{1})\\cdot {\\mathcal {E}}(m_{2})&=(g^{m_{1}}r_{1}^{c})(g^{m_{2}}r_{2}^{c})\\;{\\bmod {\\;}}n\\\\[6pt]&=g^{m_{1}+m_{2}}(r_{1}r_{2})^{c}\\;{\\bmod {\\;}}n\\\\[6pt]&={\\mathcal {E}}(m_{1}+m_{2}\\;{\\bmod {\\;}}c).\\end{aligned}}} Paillier In the Paillier cryptosystem, if the public key is the modulus n {\\displaystyle n} and the base g {\\displaystyle g} , then the encryption of a message m {\\displaystyle m} is E ( m ) = g m r n mod n 2 {\\displaystyle {\\mathcal {E}}(m)=g^{m}r^{n}\\;{\\bmod {\\;}}n^{2}} , for some random r ∈ { 0 , … , n − 1 } {\\displaystyle r\\in \\{0,\\ldots ,n-1\\}} . The homomorphic property is then E ( m 1 ) ⋅ E ( m 2 ) = ( g m 1 r 1 n ) ( g m 2 r 2 n ) mod n 2 = g m 1 + m 2 ( r 1 r 2 ) n mod n 2 = E ( m 1 + m 2 ) .",
      "char_count": 765,
      "token_estimate": 191,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0021",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== Fully homomorphic encryption ==",
      "heading_path": "== Fully homomorphic encryption ==",
      "start_char": 17581,
      "end_char": 18153,
      "content": "== Fully homomorphic encryption == A cryptosystem that supports arbitrary computation on ciphertexts is known as fully homomorphic encryption (FHE). Such a scheme enables the construction of programs for any desirable functionality, which can be run on encrypted inputs to produce an encryption of the result. Since such a program need never decrypt its inputs, it can be run by an untrusted party without revealing its inputs and internal state. Fully homomorphic cryptosystems have great practical implications in the outsourcing of private computations, for instance, in the context of cloud computing.",
      "char_count": 605,
      "token_estimate": 151,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0022",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = Implementations ==",
      "heading_path": "== = Implementations ==",
      "start_char": 18176,
      "end_char": 19086,
      "content": "== = Implementations === A list of open-source FHE libraries implementing second-generation (BGV/BFV), third-generation (FHEW/TFHE), and/or fourth-generation (CKKS) FHE schemes is provided below. There are several open-source implementations of fully homomorphic encryption schemes. Second-generation and fourth-generation FHE scheme implementations typically operate in the leveled FHE mode (though bootstrapping is still available in some libraries) and support efficient SIMD-like packing of data; they are typically used to compute on encrypted integers or real/complex numbers. Third-generation FHE scheme implementations often bootstrap after each operation but have limited support for packing; they were initially used to compute Boolean circuits over encrypted bits, but have been extended to support integer arithmetics and univariate function evaluation. The choice of using a second-generation vs.",
      "char_count": 909,
      "token_estimate": 227,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "homomorphicencryptio_062c30b5_c0023",
      "article_id": "homomorphicencryptio_062c30b5",
      "section": "== = Standardization ==",
      "heading_path": "== = Standardization ==",
      "start_char": 19192,
      "end_char": 19401,
      "content": "== = Standardization === In 2017, researchers from IBM, Microsoft, Intel, the NIST, and others formed the open Homomorphic Encryption Standardization Consortium, which maintains a community security Homomorphic Encryption Standard.",
      "char_count": 231,
      "token_estimate": 57,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 2,
    "items": [
      {
        "question": "What are the four common types of homomorphic encryption and how do their capabilities differ?",
        "answer": "The four common types are: Partially homomorphic encryption, which supports circuits with only one type of gate (e.g., addition or multiplication); Somewhat homomorphic encryption, which handles two types of gates but only for a subset of circuits; Leveled fully homomorphic encryption, which supports arbitrary circuits of multiple gate types but with a bounded, pre-determined depth; and Fully homomorphic encryption (FHE), the strongest type, which allows for the evaluation of arbitrary circuits with multiple gate types and unbounded depth.",
        "related_chunk_ids": [
          "homomorphicencryptio_062c30b5_c0003"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "homomorphicencryptio_062c30b5_c0003"
        ]
      },
      {
        "question": "Provide a comprehensive overview of homomorphic encryption, explaining what it is, its connection to other cryptographic concepts, and a specific example of its application in a sensitive field like healthcare.",
        "answer": "Homomorphic encryption is a form of encryption that allows computations to be performed on encrypted data without needing to decrypt it first. It can be viewed as an extension of public-key cryptography, and its name is derived from homomorphism in algebra. This capability enables privacy-preserving outsourced computation, where data can be processed by third-party services, like commercial clouds, while remaining encrypted. For example, in healthcare, predictive analytics can be performed on sensitive medical data by a service provider who does not have the decryption keys. This diminishes privacy concerns and ensures the data remains secure even if the provider's system is compromised.",
        "related_chunk_ids": [
          "homomorphicencryptio_062c30b5_c0000",
          "homomorphicencryptio_062c30b5_c0001",
          "homomorphicencryptio_062c30b5_c0002"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "homomorphicencryptio_062c30b5_c0001",
          "homomorphicencryptio_062c30b5_c0000",
          "homomorphicencryptio_062c30b5_c0002"
        ]
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-30T10:37:30.726Z",
    "content_format": "markdown",
    "total_chunks": 24,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}