{
  "article": {
    "id": "objectorientedprogra_315dbb3b",
    "title": "Object-oriented programming",
    "url": "https://en.wikipedia.org/wiki/Object-oriented_programming",
    "lang": "en",
    "created_at": "2025-07-30T06:55:12.342872",
    "content": "---\nid: objectorientedprogra_315dbb3b\nurl: https://en.wikipedia.org/wiki/Object-oriented_programming\ntitle: Object-oriented programming\nlang: en\ncreated_at: '2025-07-30T06:52:06.211508'\nchecksum: abb66f204ebfe07453b49d3c1fd6c87ff2ae05cc976486377e8d94877db70571\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 3966\n  char_count: 26694\n  num_chunks: 28\n  original_chunks: 36\n  filtered_out: 8\n  num_sections: 0\n---\nObject-oriented programming (OOP) is a programming paradigm based on the object – a software entity that encapsulates data and functionality. An OOP program consists of objects that interact with one another. A programming language that provides OOP features is classified as an OOP language but as the set of features that contribute to OOP is contended, classifying a language as OOP and the degree to which it supports or is OOP, are debatable. As paradigms are not mutually exclusive, a language can be multi-paradigm – can be categorized as more than just OOP. Sometimes, objects represent real-world things and processes in digital form. For example, a graphics program may have objects such as \"circle\", \"square\", and \"menu\". An online shopping system might have objects such as \"shopping cart\", \"customer\", and \"product\". Niklaus Wirth said, \"This paradigm [OOP] closely reflects the structure of systems in the real world and is therefore well suited to model complex systems with complex behavior\". However, more often, objects represent abstract entities, like an open file or a unit converter. Not everyone agrees that OOP makes it easy to copy the real world exactly or that doing so is even necessary. Bob Martin suggests that because classes are software, their relationships don't match the real-world relationships they represent. Bertrand Meyer argues that a program is not a model of the world but a model of some part of the world; \"Reality is a cousin twice removed\". Steve Yegge noted that natural languages lack the OOP approach of naming a thing (object) before an action (method), as opposed to functional programming which does the reverse. This can make an OOP solution more complicated than one written via procedural programming. Notable languages with OOP support include Ada, ActionScript, C++, Common Lisp, C#, Dart, Eiffel, Fortran 2003, Haxe, Java, JavaScript, Kotlin, Logo, MATLAB, Objective-C, Object Pascal, Perl, PHP, Python, R, Raku, Ruby, Scala, SIMSCRIPT, Simula, Smalltalk, Swift, Vala and Visual Basic.NET. == History == The idea of \"objects\" in programming started with the artificial intelligence group at MIT in the late 1950s and early 1960s. Here, \"object\" referred to LISP atoms with identified properties (attributes). Another early example was Sketchpad created by Ivan Sutherland at MIT in 1960–1961. In the glossary of his technical report, Sutherland defined terms like \"object\" and \"instance\" (with the class concept covered by \"master\" or \"definition\"), albeit specialized to graphical interaction. Later, in 1968, AED-0, MIT's version of the ALGOL programming language, connected data structures (\"plexes\") and procedures, prefiguring what were later termed \"messages\", \"methods\", and \"member functions\". Topics such as data abstraction and modular programming were common points of discussion at this time. Meanwhile, in Norway, Simula was developed during the years 1961–1967. Simula introduced essential object-oriented ideas, such as classes, inheritance, and dynamic binding. Simula was used mainly by researchers involved with physical modelling, like the movement of ships and their content through cargo ports. Simula is generally accepted as being the first language with the primary features and framework of an object-oriented language. Influenced by both MIT and Simula, Alan Kay began developing his own ideas in November 1966. He would go on to create Smalltalk, an influential OOP language. By 1967, Kay was already using the term \"object-oriented programming\" in conversation. Although sometimes called the \"father\" of OOP, Kay has said his ideas differ from how OOP is commonly understood, and has implied that the computer science establishment did not adopt his notion. A 1976 MIT memo co-authored by Barbara Liskov lists Simula 67, CLU, and Alphard as object-oriented languages, but does not mention Smalltalk. In the 1970s, the first version of the Smalltalk programming language was developed at Xerox PARC by Alan Kay, Dan Ingalls and Adele Goldberg. Smalltalk-72 was notable for use of objects at the language level and its graphical development environment. Smalltalk was a fully dynamic system, allowing users to create and modify classes as they worked. Much of the theory of OOP was developed in the context of Smalltalk, for example multiple inheritance. In the late 1970s and 1980s, OOP rose to prominence. The Flavors object-oriented Lisp was developed starting 1979, introducing multiple inheritance and mixins. In August 1981, Byte Magazine highlighted Smalltalk and OOP, introducing these ideas to a wide audience. LOOPS, the object system for Interlisp-D, was influenced by Smalltalk and Flavors, and a paper about it was published in 1982. In 1986, the first Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA) was attended by 1,000 people. This conference marked the beginning of efforts to consolidate Lisp object systems, eventually resulting in the Common Lisp Object System. In the 1980s, there were a few attempts to design processor architectures that included hardware support for objects in memory, but these were not successful. Examples include the Intel iAPX 432 and the Linn Smart Rekursiv. In the mid-1980s, new object-oriented languages like Objective-C, C++, and Eiffel emerged. Objective-C was developed by Brad Cox, who had used Smalltalk at ITT Inc. Bjarne Stroustrup created C++ based on his experience using Simula for his PhD thesis. Bertrand Meyer produced the first design of the Eiffel language in 1985, which focused on software quality using a design by contract approach. In the 1990s, OOP became the main way of programming, especially as more languages supported it. These included Visual FoxPro 3.0, C++, and Delphi. OOP became even more popular with the rise of graphical user interfaces, which used objects for buttons, menus and other elements. One well-known example is Apple's Cocoa framework, used on Mac OS X and written in Objective-C. OOP toolkits also enhanced the popularity of event-driven programming. At ETH Zürich, Niklaus Wirth and his colleagues created new approaches to OOP. Modula-2 (1978) and Oberon (1987), included a distinctive approach to object orientation, classes, and type checking across module boundaries. Inheritance is not obvious in Wirth's design since his nomenclature looks in the opposite direction: It is called type extension and the viewpoint is from the parent down to the inheritor. Many programming languages that were initially developed before OOP was popular have been augmented with object-oriented features, including Ada, BASIC, Fortran, Pascal, and COBOL. == Features == The OOP features provided by languages varies. Below are some common features of OOP languages. Comparing OOP with other styles, like relational programming, is difficult because there isn't a clear, agreed-upon definition of OOP. === Encapsulation === An object encapsulates fields and methods. A field (a.k.a. attribute or property) contains information (a.k.a. state) as a variable. A method (a.k.a. function or action) defines behavior via logic code. Encapsulation is about keeping related, code together. === Information hiding === Information hiding is organizing code so that it is accessible only to the code that needs it; not to the rest of the codebase. The internal details of an object are hidden from the outside code – allowing for changing how an object works without affecting its interface and therefore other code. Hidding information helps prevent problems when changing the code. Objects act as a barrier between their internal workings and external, consuming code. Consuming code can only interact with an object via its public members. Some programming languages, like Java, provide information hiding via visibility key words (private and public). Some languages don't provide a visibility feature, but developers might follow a convention such as starting a private member name with an underscore. Intermediate levels of access also exist, such as Java's protected keyword, (which allows access from the same class and its subclasses, but not objects of a different class), and the internal keyword in C#, Swift, and Kotlin, which restricts access to files within the same module. Supporters of information hiding and data abstraction say it makes code easier to reuse and intuitively represents real-world situations. However, others argue that OOP does not enhance readability or modularity. Eric S. Raymond has written that OOP languages tend to encourage thickly layered programs that destroy transparency. Raymond compares this unfavourably to the approach taken with Unix and the C programming language. SOLID includes the open/closed principle, which says that classes and functions should be \"open for extension, but closed for modification\". Luca Cardelli has stated that OOP languages have \"extremely poor modularity properties with respect to class extension and modification\", and tend to be extremely complex. The latter point is reiterated by Joe Armstrong, the principal inventor of Erlang, who is quoted as saying: The problem with object-oriented languages is they've got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle. Leo Brodie says that information hiding can lead to duplicating code, which goes against the don't repeat yourself rule of software development. === Composition === Via object composition, an object can contain other objects. For example, an Employee object might contain an Address object, along with other information like name and position. Composition is a \"has-a\" relationships, like \"an employee has an address\". === Inheritance === Inheritance be supported via the class or the prototype, which have differences but use similar terms like object and instance. ==== Class-based ==== In class-based programming, the most common type of OOP, an object is an instance of a class. The class defines the data (variables) and methods (logic). An object is created via the constructor. Elements of class may include: Class variable – belongs to the class itself; all objects of the class share one copy Instance variable – belongs to an object; every object has its own version of these variables Member variable – refers to both the class and instance variables of a class Class method – can only use class variables Instance method – belongs to an objects; can use both instance and class variables Classes may inherit from other classes, creating a hierarchy of classes -- a subclass inheriting from a super-class. For example, an Employee class might inherit from a Person class which endows the Employee object with the variables from Person. The subclass may add variables and methods that do not affect the super-class. Most languages also allow the subclass to override super-class methods. Some languages support multiple inheritance, where a class can inherit from more than one class, and other languages similarly support mixins or traits. For example, a mixin called UnicodeConversionMixin might add a method unicode_to_ascii() to both a FileReader and a WebPageScraper class. An abstract class cannot be directly instantiated as an object. It is only used as a super-class. Other classes are utility classes which contain only class variables and methods and are not meant to be instantiated or subclassed. ==== Prototype-based ==== Instead of providing a class concept, in prototype-based programming, an object is linked to another object, called its prototype or parent. In Self, an object may have multiple or no parents, but in the most popular prototype-based language, Javascript, an object has exactly one prototype link, up to the base object whose prototype is null. A prototype acts as a model for new objects. For example, if you have an object fruit, you can make two objects apple and orange that share traits of the fruit prototype. Prototype-based languages also allow objects to have their own unique properties, so the apple object might have an attribute sugar_content, while the orange or fruit objects do not. ==== No inheritance ==== Some languages, like Go, don't support inheritance. Instead, they encourage \"composition over inheritance\", where objects are built using smaller parts instead of parent-child relationships. For example, instead of inheriting from class Person, the Employee class could simply contain a Person object. This lets the Employee class control how much of Person it exposes to other parts of the program. Delegation is another language feature that can be used as an alternative to inheritance. Programmers have different opinions on inheritance. Bjarne Stroustrup, author of C++, has stated that it is possible to do OOP without inheritance. Rob Pike has criticized inheritance for creating complicated hierarchies instead of simpler solutions. ==== Inheritance and behavioral subtyping ==== People often think that if one class inherits from another, it means the subclass \"is a\" more specific version of the original class. This presumes the program semantics are that objects from the subclass can always replace objects from the original class without problems. This concept is known as behavioral subtyping, more specifically the Liskov substitution principle. However, this is often not true, especially in programming languages that allow mutable objects, objects that change after they are created. In fact, subtype polymorphism as enforced by the type checker in OOP languages cannot guarantee behavioral subtyping in most if not all contexts. For example, the circle-ellipse problem is notoriously difficult to handle using OOP's concept of inheritance. Behavioral subtyping is undecidable in general, so it cannot be easily implemented by a compiler. Because of this, programmers must carefully design class hierarchies to avoid mistakes that the programming language itself cannot catch. === Dynamic dispatch === A method my be invoked via dynamic dispatch such that the method is selected at runtime instead of compile time. If the method choice depends on more than one type of object (such as other objects passed as parameters), it's called multiple dispatch. Dynamic dispatch works together with inheritance: if an object doesn't have the requested method, it looks up to its parent class (delegation), and continues up the chain to find a matching method. === Message passing === Message passing is when the method name and its inputs are sent like a message to the object for it to act on. === Polymorphism === Polymorphism refers to subtyping or subtype polymorphism, where a function can work with a specific interface and thus manipulate entities of different classes in a uniform manner. For example, imagine a program has two shapes: a circle and a square. Both come from a common class called \"Shape.\" Each shape has its own way of drawing itself. With subtype polymorphism, the program doesn't need to know the type of each shape, and can simply call the \"Draw\" method for each shape. The programming language runtime will ensure the correct version of the \"Draw\" method runs for each shape. Because the details of each shape are handled inside their own classes, this makes the code simpler and more organized, enabling strong separation of concerns. === Open recursion === An object's methods can access the object's data. Many programming languages use a special word, like this or self, to refer to the current object. In languages that support open recursion, a method in an object can call other methods in the same object, including itself, using this special word. This allows a method in one class to call another method defined later in a subclass, a feature known as late binding. == Design patterns == Design patterns are common solutions to problems in software design. Some design patterns are especially useful for OOP, and design patterns are typically introduced in an OOP context. === Object patterns === The following are notable software design patterns for OOP objects. Function object: Class with one main method that acts like an anonymous function (in C++, the function operator, operator()) Immutable object: does not change state after creation First-class object: can be used without restriction Container object: contains other objects Factory object: creates other objects Metaobject: Used to create other objects (similar to a class, but an object) Prototype object: a specialized metaobject that creates new objects by copying itself Singleton object: only instance of its class for the lifetime of the program Filter object: receives a stream of data as its input and transforms it into the object's output A common anti-pattern is the God object, an object that knows or does too much. === Gang of Four design patterns === Design Patterns: Elements of Reusable Object-Oriented Software is a famous book published in 1994 by four authors: Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. People often call them the \"Gang of Four\". The book talks about the strengths and weaknesses of OOP and explains 23 common ways to solve programming problems. These solutions, called \"design patterns,\" are grouped into three types: Creational patterns (5): Factory method pattern, Abstract factory pattern, Singleton pattern, Builder pattern, Prototype pattern Structural patterns (7): Adapter pattern, Bridge pattern, Composite pattern, Decorator pattern, Facade pattern, Flyweight pattern, Proxy pattern Behavioral patterns (11): Chain-of-responsibility pattern, Command pattern, Interpreter pattern, Iterator pattern, Mediator pattern, Memento pattern, Observer pattern, State pattern, Strategy pattern, Template method pattern, Visitor pattern === Object-orientation and databases === Both OOP and relational database management systems (RDBMSs) are widely used in software today. However, relational databases don't store objects directly, which creates a challenge when using them together. This issue is called object-relational impedance mismatch. To solve this problem, developers use different methods, but none of them are perfect. One of the most common solutions is object-relational mapping (ORM), which helps connect object-oriented programs to relational databases. Examples of ORM tools include Visual FoxPro, Java Data Objects, and Ruby on Rails ActiveRecord. Some databases, called object databases, are designed to work with OOP. However, they have not been as popular or successful as relational databases. Date and Darwen have proposed a theoretical foundation that uses OOP as a kind of customizable type system to support RDBMSs, but it forbids objects containing pointers to other objects. === Responsibility- vs. data-driven design === In responsibility-driven design, classes are built around what they need to do and the information they share, in the form of a contract. This is different from data-driven design, where classes are built based on the data they need to store. According to Wirfs-Brock and Wilkerson, the originators of responsibility-driven design, responsibility-driven design is the better approach. === SOLID and GRASP guidelines === SOLID is a set of five rules for designing good software, created by Michael Feathers: Single responsibility principle: A class should have only one reason to change. Open/closed principle: Software entities should be open for extension, but closed for modification. Liskov substitution principle: Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. Interface segregation principle: Clients should not be forced to depend upon interfaces that they do not use. Dependency inversion principle: Depend upon abstractions, not concretes. GRASP (General Responsibility Assignment Software Patterns) is another set of software design rules, created by Craig Larman, that helps developers assign responsibilities to different parts of a program: Creator Principle: allows classes create objects they closely use. Information Expert Principle: assigns tasks to classes with the needed information. Low Coupling Principle: reduces class dependencies to improve flexibility and maintainability. High Cohesion Principle: designing classes with a single, focused responsibility. Controller Principle: assigns system operations to separate classes that manage flow and interactions. Polymorphism: allows different classes to be used through a common interface, promoting flexibility and reuse. Pure Fabrication Principle: create helper classes to improve design, boost cohesion, and reduce coupling. == Formal semantics == Researchers have tried to formally define the semantics of OOP. inheritance presents difficulties, particularly with the interactions between open recursion and encapsulated state. Researchers have used recursive types and co-algebraic data types to incorporate essential features of OOP. Abadi and Cardelli defined several extensions of System F<: that deal with mutable objects, allowing both subtype polymorphism and parametric polymorphism (generics), and were able to formally model many OOP concepts and constructs. Although far from trivial, static analysis of object-oriented programming languages such as Java is a mature field, with several commercial tools. == Criticism == Some believe that OOP places too much focus on using objects rather than on algorithms and data structures. For example, programmer Rob Pike pointed out that OOP can make programmers think more about type hierarchy than composition. He has called OOP \"the Roman numerals of computing\". Rich Hickey, creator of Clojure, described OOP as overly simplistic, especially when it comes to representing real-world things that change over time. Alexander Stepanov said that OOP tries to fit everything into a single type, which can be limiting. He argued that sometimes we need multisorted algebras—families of interfaces that span multiple types, such as in generic programming. Stepanov also said that calling everything an \"object\" doesn't add much understanding. OOP was created to make code easier to reuse and maintain. However, it was not designed to clearly show the flow of a program's instructions—that was left to the compiler. As computers began using more parallel processing and multiple threads, it became more important to understand and control how instructions flow. This is difficult to do with OOP. Many popular programming languages, like C++, Java, and Python, use OOP. In the past, OOP was widely accepted, but recently, some programmers have criticized it and prefer functional programming instead. A study by Potok et al. found no major difference in productivity between OOP and other methods. Paul Graham, a well-known computer scientist, believes big companies like OOP because it helps manage large teams of average programmers. He argues that OOP adds structure, making it harder for one person to make serious mistakes, but at the same time restrains smart programmers. Eric S. Raymond, a Unix programmer and open-source software advocate, argues that OOP is not the best way to write programs. Richard Feldman says that, while OOP features helped some languages stay organized, their popularity comes from other reasons. Lawrence Krubner argues that OOP doesn't offer special advantages compared to other styles, like functional programming, and can make coding more complicated. Luca Cardelli says that OOP is slower and takes longer to compile than procedural programming. == See also == CADES Common Object Request Broker Architecture (CORBA) Comparison of programming languages (object-oriented programming) Component-based software engineering Distributed Component Object Model Interface description language IDEF4 Jeroo List of object-oriented programming languages Object association Object modeling language Object-oriented analysis and design Object-oriented ontology UML == References == == Further reading == Abadi, Martin; Luca Cardelli (1998). A Theory of Objects. Springer Verlag. ISBN 978-0-387-94775-4. Abelson, Harold; Gerald Jay Sussman (1997). Structure and Interpretation of Computer Programs. MIT Press. ISBN 978-0-262-01153-2. Archived from the original on 26 December 2017. Retrieved 22 January 2006. Armstrong, Deborah J. (February 2006). \"The Quarks of Object-Oriented Development\". Communications of the ACM. 49 (2): 123–128. doi:10.1145/1113034.1113040. ISSN 0001-0782. S2CID 11485502. Bloch, Joshua (2018). \"Effective Java: Programming Language Guide\" (third ed.). Addison-Wesley. ISBN 978-0134685991. Booch, Grady (1997). Object-Oriented Analysis and Design with Applications. Addison-Wesley. ISBN 978-0-8053-5340-2. Eeles, Peter; Oliver Sims (1998). Building Business Objects. John Wiley & Sons. ISBN 978-0-471-19176-6. Gamma, Erich; Richard Helm; Ralph Johnson; John Vlissides (1995). Design Patterns: Elements of Reusable Object Oriented Software. Addison-Wesley. Bibcode:1995dper.book.....G. ISBN 978-0-201-63361-0. Harmon, Paul; William Morrissey (1996). The Object Technology Casebook – Lessons from Award-Winning Business Applications. John Wiley & Sons. ISBN 978-0-471-14717-6. Jacobson, Ivar (1992). Object-Oriented Software Engineering: A Use Case-Driven Approach. Addison-Wesley. Bibcode:1992oose.book.....J. ISBN 978-0-201-54435-0. Kay, Alan. The Early History of Smalltalk. Archived from the original on 4 April 2005. Retrieved 18 April 2005. Meyer, Bertrand (1997). Object-Oriented Software Construction. Prentice Hall. ISBN 978-0-13-629155-8. Pecinovsky, Rudolf (2013). OOP – Learn Object Oriented Thinking & Programming. Bruckner Publishing. ISBN 978-80-904661-8-0. Rumbaugh, James; Michael Blaha; William Premerlani; Frederick Eddy; William Lorensen (1991). Object-Oriented Modeling and Design. Prentice Hall. ISBN 978-0-13-629841-0. Schach, Stephen (2006). Object-Oriented and Classical Software Engineering, Seventh Edition. McGraw-Hill. ISBN 978-0-07-319126-3. Schreiner, Axel-Tobias (1993). Object oriented programming with ANSI-C. Hanser. hdl:1850/8544. ISBN 978-3-446-17426-9. Taylor, David A. (1992). Object-Oriented Information Systems – Planning and Implementation. John Wiley & Sons. ISBN 978-0-471-54364-0. Weisfeld, Matt (2009). The Object-Oriented Thought Process, Third Edition. Addison-Wesley. ISBN 978-0-672-33016-2. West, David (2004). Object Thinking (Developer Reference). Microsoft Press. ISBN 978-0-7356-1965-4. == External links == Introduction to Object Oriented Programming Concepts (OOP) and More by L.W.C. Nirosh Discussion on Cons of OOP OOP Concepts (Java Tutorials)"
  },
  "chunks": [
    {
      "id": "objectorientedprogra_315dbb3b_c0000",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 830,
      "content": "Object-oriented programming (OOP) is a programming paradigm based on the object – a software entity that encapsulates data and functionality. An OOP program consists of objects that interact with one another. A programming language that provides OOP features is classified as an OOP language but as the set of features that contribute to OOP is contended, classifying a language as OOP and the degree to which it supports or is OOP, are debatable. As paradigms are not mutually exclusive, a language can be multi-paradigm – can be categorized as more than just OOP. Sometimes, objects represent real-world things and processes in digital form. For example, a graphics program may have objects such as \"circle\", \"square\", and \"menu\". An online shopping system might have objects such as \"shopping cart\", \"customer\", and \"product\".",
      "char_count": 829,
      "token_estimate": 207,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0001",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 830,
      "end_char": 1758,
      "content": "Niklaus Wirth said, \"This paradigm [OOP] closely reflects the structure of systems in the real world and is therefore well suited to model complex systems with complex behavior\". However, more often, objects represent abstract entities, like an open file or a unit converter. Not everyone agrees that OOP makes it easy to copy the real world exactly or that doing so is even necessary. Bob Martin suggests that because classes are software, their relationships don't match the real-world relationships they represent. Bertrand Meyer argues that a program is not a model of the world but a model of some part of the world; \"Reality is a cousin twice removed\". Steve Yegge noted that natural languages lack the OOP approach of naming a thing (object) before an action (method), as opposed to functional programming which does the reverse. This can make an OOP solution more complicated than one written via procedural programming.",
      "char_count": 928,
      "token_estimate": 232,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0002",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 1759,
      "end_char": 2049,
      "content": "Notable languages with OOP support include Ada, ActionScript, C++, Common Lisp, C#, Dart, Eiffel, Fortran 2003, Haxe, Java, JavaScript, Kotlin, Logo, MATLAB, Objective-C, Object Pascal, Perl, PHP, Python, R, Raku, Ruby, Scala, SIMSCRIPT, Simula, Smalltalk, Swift, Vala and Visual Basic.NET.",
      "char_count": 290,
      "token_estimate": 72,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0003",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 2063,
      "end_char": 2949,
      "content": "== History == The idea of \"objects\" in programming started with the artificial intelligence group at MIT in the late 1950s and early 1960s. Here, \"object\" referred to LISP atoms with identified properties (attributes). Another early example was Sketchpad created by Ivan Sutherland at MIT in 1960–1961. In the glossary of his technical report, Sutherland defined terms like \"object\" and \"instance\" (with the class concept covered by \"master\" or \"definition\"), albeit specialized to graphical interaction. Later, in 1968, AED-0, MIT's version of the ALGOL programming language, connected data structures (\"plexes\") and procedures, prefiguring what were later termed \"messages\", \"methods\", and \"member functions\". Topics such as data abstraction and modular programming were common points of discussion at this time. Meanwhile, in Norway, Simula was developed during the years 1961–1967.",
      "char_count": 885,
      "token_estimate": 221,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0004",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 2949,
      "end_char": 3900,
      "content": "Simula introduced essential object-oriented ideas, such as classes, inheritance, and dynamic binding. Simula was used mainly by researchers involved with physical modelling, like the movement of ships and their content through cargo ports. Simula is generally accepted as being the first language with the primary features and framework of an object-oriented language. Influenced by both MIT and Simula, Alan Kay began developing his own ideas in November 1966. He would go on to create Smalltalk, an influential OOP language. By 1967, Kay was already using the term \"object-oriented programming\" in conversation. Although sometimes called the \"father\" of OOP, Kay has said his ideas differ from how OOP is commonly understood, and has implied that the computer science establishment did not adopt his notion. A 1976 MIT memo co-authored by Barbara Liskov lists Simula 67, CLU, and Alphard as object-oriented languages, but does not mention Smalltalk.",
      "char_count": 951,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0005",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 3901,
      "end_char": 4883,
      "content": "In the 1970s, the first version of the Smalltalk programming language was developed at Xerox PARC by Alan Kay, Dan Ingalls and Adele Goldberg. Smalltalk-72 was notable for use of objects at the language level and its graphical development environment. Smalltalk was a fully dynamic system, allowing users to create and modify classes as they worked. Much of the theory of OOP was developed in the context of Smalltalk, for example multiple inheritance. In the late 1970s and 1980s, OOP rose to prominence. The Flavors object-oriented Lisp was developed starting 1979, introducing multiple inheritance and mixins. In August 1981, Byte Magazine highlighted Smalltalk and OOP, introducing these ideas to a wide audience. LOOPS, the object system for Interlisp-D, was influenced by Smalltalk and Flavors, and a paper about it was published in 1982. In 1986, the first Conference on Object-Oriented Programming, Systems, Languages, and Applications (OOPSLA) was attended by 1,000 people.",
      "char_count": 982,
      "token_estimate": 245,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0006",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 4884,
      "end_char": 5790,
      "content": "This conference marked the beginning of efforts to consolidate Lisp object systems, eventually resulting in the Common Lisp Object System. In the 1980s, there were a few attempts to design processor architectures that included hardware support for objects in memory, but these were not successful. Examples include the Intel iAPX 432 and the Linn Smart Rekursiv. In the mid-1980s, new object-oriented languages like Objective-C, C++, and Eiffel emerged. Objective-C was developed by Brad Cox, who had used Smalltalk at ITT Inc. Bjarne Stroustrup created C++ based on his experience using Simula for his PhD thesis. Bertrand Meyer produced the first design of the Eiffel language in 1985, which focused on software quality using a design by contract approach. In the 1990s, OOP became the main way of programming, especially as more languages supported it. These included Visual FoxPro 3.0, C++, and Delphi.",
      "char_count": 906,
      "token_estimate": 226,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0007",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 5791,
      "end_char": 6680,
      "content": "OOP became even more popular with the rise of graphical user interfaces, which used objects for buttons, menus and other elements. One well-known example is Apple's Cocoa framework, used on Mac OS X and written in Objective-C. OOP toolkits also enhanced the popularity of event-driven programming. At ETH Zürich, Niklaus Wirth and his colleagues created new approaches to OOP. Modula-2 (1978) and Oberon (1987), included a distinctive approach to object orientation, classes, and type checking across module boundaries. Inheritance is not obvious in Wirth's design since his nomenclature looks in the opposite direction: It is called type extension and the viewpoint is from the parent down to the inheritor. Many programming languages that were initially developed before OOP was popular have been augmented with object-oriented features, including Ada, BASIC, Fortran, Pascal, and COBOL.",
      "char_count": 889,
      "token_estimate": 222,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0008",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== Features ==",
      "heading_path": "== Features ==",
      "start_char": 6682,
      "end_char": 6914,
      "content": "== Features == The OOP features provided by languages varies. Below are some common features of OOP languages. Comparing OOP with other styles, like relational programming, is difficult because there isn't a clear, agreed-upon definition of OOP.",
      "char_count": 245,
      "token_estimate": 61,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0009",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Encapsulation ==",
      "heading_path": "== = Encapsulation ==",
      "start_char": 6935,
      "end_char": 7195,
      "content": "== = Encapsulation === An object encapsulates fields and methods. A field (a.k.a. attribute or property) contains information (a.k.a. state) as a variable. A method (a.k.a. function or action) defines behavior via logic code. Encapsulation is about keeping related, code together.",
      "char_count": 280,
      "token_estimate": 70,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0010",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Information hiding ==",
      "heading_path": "== = Information hiding ==",
      "start_char": 7221,
      "end_char": 8036,
      "content": "== = Information hiding === Information hiding is organizing code so that it is accessible only to the code that needs it; not to the rest of the codebase. The internal details of an object are hidden from the outside code – allowing for changing how an object works without affecting its interface and therefore other code. Hidding information helps prevent problems when changing the code. Objects act as a barrier between their internal workings and external, consuming code. Consuming code can only interact with an object via its public members. Some programming languages, like Java, provide information hiding via visibility key words (private and public). Some languages don't provide a visibility feature, but developers might follow a convention such as starting a private member name with an underscore.",
      "char_count": 814,
      "token_estimate": 203,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0011",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Information hiding ==",
      "heading_path": "== = Information hiding ==",
      "start_char": 8036,
      "end_char": 8888,
      "content": "Intermediate levels of access also exist, such as Java's protected keyword, (which allows access from the same class and its subclasses, but not objects of a different class), and the internal keyword in C#, Swift, and Kotlin, which restricts access to files within the same module. Supporters of information hiding and data abstraction say it makes code easier to reuse and intuitively represents real-world situations. However, others argue that OOP does not enhance readability or modularity. Eric S. Raymond has written that OOP languages tend to encourage thickly layered programs that destroy transparency. Raymond compares this unfavourably to the approach taken with Unix and the C programming language. SOLID includes the open/closed principle, which says that classes and functions should be \"open for extension, but closed for modification\".",
      "char_count": 852,
      "token_estimate": 213,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0012",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Information hiding ==",
      "heading_path": "== = Information hiding ==",
      "start_char": 8889,
      "end_char": 9528,
      "content": "Luca Cardelli has stated that OOP languages have \"extremely poor modularity properties with respect to class extension and modification\", and tend to be extremely complex. The latter point is reiterated by Joe Armstrong, the principal inventor of Erlang, who is quoted as saying: The problem with object-oriented languages is they've got all this implicit environment that they carry around with them. You wanted a banana but what you got was a gorilla holding the banana and the entire jungle. Leo Brodie says that information hiding can lead to duplicating code, which goes against the don't repeat yourself rule of software development.",
      "char_count": 639,
      "token_estimate": 159,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0013",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Composition ==",
      "heading_path": "== = Composition ==",
      "start_char": 9522,
      "end_char": 9778,
      "content": "== = Composition === Via object composition, an object can contain other objects. For example, an Employee object might contain an Address object, along with other information like name and position. Composition is a \"has-a\" relationships, like \"an employee has an address\".",
      "char_count": 274,
      "token_estimate": 68,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0014",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Dynamic dispatch ==",
      "heading_path": "== = Dynamic dispatch ==",
      "start_char": 9951,
      "end_char": 10402,
      "content": "== = Dynamic dispatch === A method my be invoked via dynamic dispatch such that the method is selected at runtime instead of compile time. If the method choice depends on more than one type of object (such as other objects passed as parameters), it's called multiple dispatch. Dynamic dispatch works together with inheritance: if an object doesn't have the requested method, it looks up to its parent class (delegation), and continues up the chain to find a matching method.",
      "char_count": 474,
      "token_estimate": 118,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0015",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Polymorphism ==",
      "heading_path": "== = Polymorphism ==",
      "start_char": 10558,
      "end_char": 11308,
      "content": "== = Polymorphism === Polymorphism refers to subtyping or subtype polymorphism, where a function can work with a specific interface and thus manipulate entities of different classes in a uniform manner. For example, imagine a program has two shapes: a circle and a square. Both come from a common class called \"Shape.\" Each shape has its own way of drawing itself. With subtype polymorphism, the program doesn't need to know the type of each shape, and can simply call the \"Draw\" method for each shape. The programming language runtime will ensure the correct version of the \"Draw\" method runs for each shape. Because the details of each shape are handled inside their own classes, this makes the code simpler and more organized, enabling strong separation of concerns.",
      "char_count": 769,
      "token_estimate": 192,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0016",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Open recursion ==",
      "heading_path": "== = Open recursion ==",
      "start_char": 11330,
      "end_char": 11749,
      "content": "== = Open recursion === An object's methods can access the object's data. Many programming languages use a special word, like this or self, to refer to the current object. In languages that support open recursion, a method in an object can call other methods in the same object, including itself, using this special word. This allows a method in one class to call another method defined later in a subclass, a feature known as late binding.",
      "char_count": 440,
      "token_estimate": 110,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0017",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== Design patterns ==",
      "heading_path": "== Design patterns ==",
      "start_char": 11770,
      "end_char": 11956,
      "content": "== Design patterns == Design patterns are common solutions to problems in software design. Some design patterns are especially useful for OOP, and design patterns are typically introduced in an OOP context.",
      "char_count": 206,
      "token_estimate": 51,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0018",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Object patterns ==",
      "heading_path": "== = Object patterns ==",
      "start_char": 11979,
      "end_char": 12777,
      "content": "== = Object patterns === The following are notable software design patterns for OOP objects. Function object: Class with one main method that acts like an anonymous function (in C++, the function operator, operator()) Immutable object: does not change state after creation First-class object: can be used without restriction Container object: contains other objects Factory object: creates other objects Metaobject: Used to create other objects (similar to a class, but an object) Prototype object: a specialized metaobject that creates new objects by copying itself Singleton object: only instance of its class for the lifetime of the program Filter object: receives a stream of data as its input and transforms it into the object's output A common anti-pattern is the God object, an object that knows or does too much.",
      "char_count": 820,
      "token_estimate": 205,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0019",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Gang of Four design patterns ==",
      "heading_path": "== = Gang of Four design patterns ==",
      "start_char": 12813,
      "end_char": 13740,
      "content": "== = Gang of Four design patterns === Design Patterns: Elements of Reusable Object-Oriented Software is a famous book published in 1994 by four authors: Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. People often call them the \"Gang of Four\". The book talks about the strengths and weaknesses of OOP and explains 23 common ways to solve programming problems. These solutions, called \"design patterns,\" are grouped into three types: Creational patterns (5): Factory method pattern, Abstract factory pattern, Singleton pattern, Builder pattern, Prototype pattern Structural patterns (7): Adapter pattern, Bridge pattern, Composite pattern, Decorator pattern, Facade pattern, Flyweight pattern, Proxy pattern Behavioral patterns (11): Chain-of-responsibility pattern, Command pattern, Interpreter pattern, Iterator pattern, Mediator pattern, Memento pattern, Observer pattern, State pattern, Strategy pattern, Template method pattern, Visitor pattern",
      "char_count": 962,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0020",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Object-orientation and databases ==",
      "heading_path": "== = Object-orientation and databases ==",
      "start_char": 13780,
      "end_char": 14708,
      "content": "== = Object-orientation and databases === Both OOP and relational database management systems (RDBMSs) are widely used in software today. However, relational databases don't store objects directly, which creates a challenge when using them together. This issue is called object-relational impedance mismatch. To solve this problem, developers use different methods, but none of them are perfect. One of the most common solutions is object-relational mapping (ORM), which helps connect object-oriented programs to relational databases. Examples of ORM tools include Visual FoxPro, Java Data Objects, and Ruby on Rails ActiveRecord. Some databases, called object databases, are designed to work with OOP. However, they have not been as popular or successful as relational databases. Date and Darwen have proposed a theoretical foundation that uses OOP as a kind of customizable type system to support RDBMSs, but it forbids objects containing pointers to other objects.",
      "char_count": 967,
      "token_estimate": 241,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0021",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = Responsibility- vs. data-driven design ==",
      "heading_path": "== = Responsibility- vs. data-driven design ==",
      "start_char": 14754,
      "end_char": 15141,
      "content": "== = Responsibility- vs. data-driven design === In responsibility-driven design, classes are built around what they need to do and the information they share, in the form of a contract. This is different from data-driven design, where classes are built based on the data they need to store. According to Wirfs-Brock and Wilkerson, the originators of responsibility-driven design, responsibility-driven design is the better approach.",
      "char_count": 432,
      "token_estimate": 108,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0022",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = SOLID and GRASP guidelines ==",
      "heading_path": "== = SOLID and GRASP guidelines ==",
      "start_char": 15175,
      "end_char": 16089,
      "content": "== = SOLID and GRASP guidelines === SOLID is a set of five rules for designing good software, created by Michael Feathers: Single responsibility principle: A class should have only one reason to change. Open/closed principle: Software entities should be open for extension, but closed for modification. Liskov substitution principle: Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it. Interface segregation principle: Clients should not be forced to depend upon interfaces that they do not use. Dependency inversion principle: Depend upon abstractions, not concretes. GRASP (General Responsibility Assignment Software Patterns) is another set of software design rules, created by Craig Larman, that helps developers assign responsibilities to different parts of a program: Creator Principle: allows classes create objects they closely use.",
      "char_count": 913,
      "token_estimate": 228,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0023",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== = SOLID and GRASP guidelines ==",
      "heading_path": "== = SOLID and GRASP guidelines ==",
      "start_char": 16089,
      "end_char": 16669,
      "content": "Information Expert Principle: assigns tasks to classes with the needed information. Low Coupling Principle: reduces class dependencies to improve flexibility and maintainability. High Cohesion Principle: designing classes with a single, focused responsibility. Controller Principle: assigns system operations to separate classes that manage flow and interactions. Polymorphism: allows different classes to be used through a common interface, promoting flexibility and reuse. Pure Fabrication Principle: create helper classes to improve design, boost cohesion, and reduce coupling.",
      "char_count": 580,
      "token_estimate": 145,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0024",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== Formal semantics ==",
      "heading_path": "== Formal semantics ==",
      "start_char": 16658,
      "end_char": 17328,
      "content": "== Formal semantics == Researchers have tried to formally define the semantics of OOP. inheritance presents difficulties, particularly with the interactions between open recursion and encapsulated state. Researchers have used recursive types and co-algebraic data types to incorporate essential features of OOP. Abadi and Cardelli defined several extensions of System F<: that deal with mutable objects, allowing both subtype polymorphism and parametric polymorphism (generics), and were able to formally model many OOP concepts and constructs. Although far from trivial, static analysis of object-oriented programming languages such as Java is a mature field, with several commercial tools.",
      "char_count": 691,
      "token_estimate": 172,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0025",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== Criticism ==",
      "heading_path": "== Criticism ==",
      "start_char": 17343,
      "end_char": 18290,
      "content": "== Criticism == Some believe that OOP places too much focus on using objects rather than on algorithms and data structures. For example, programmer Rob Pike pointed out that OOP can make programmers think more about type hierarchy than composition. He has called OOP \"the Roman numerals of computing\". Rich Hickey, creator of Clojure, described OOP as overly simplistic, especially when it comes to representing real-world things that change over time. Alexander Stepanov said that OOP tries to fit everything into a single type, which can be limiting. He argued that sometimes we need multisorted algebras—families of interfaces that span multiple types, such as in generic programming. Stepanov also said that calling everything an \"object\" doesn't add much understanding. OOP was created to make code easier to reuse and maintain. However, it was not designed to clearly show the flow of a program's instructions—that was left to the compiler.",
      "char_count": 946,
      "token_estimate": 236,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0026",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== Criticism ==",
      "heading_path": "== Criticism ==",
      "start_char": 18290,
      "end_char": 19176,
      "content": "As computers began using more parallel processing and multiple threads, it became more important to understand and control how instructions flow. This is difficult to do with OOP. Many popular programming languages, like C++, Java, and Python, use OOP. In the past, OOP was widely accepted, but recently, some programmers have criticized it and prefer functional programming instead. A study by Potok et al. found no major difference in productivity between OOP and other methods. Paul Graham, a well-known computer scientist, believes big companies like OOP because it helps manage large teams of average programmers. He argues that OOP adds structure, making it harder for one person to make serious mistakes, but at the same time restrains smart programmers. Eric S. Raymond, a Unix programmer and open-source software advocate, argues that OOP is not the best way to write programs.",
      "char_count": 886,
      "token_estimate": 221,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "objectorientedprogra_315dbb3b_c0027",
      "article_id": "objectorientedprogra_315dbb3b",
      "section": "== Criticism ==",
      "heading_path": "== Criticism ==",
      "start_char": 19177,
      "end_char": 19557,
      "content": "Richard Feldman says that, while OOP features helped some languages stay organized, their popularity comes from other reasons. Lawrence Krubner argues that OOP doesn't offer special advantages compared to other styles, like functional programming, and can make coding more complicated. Luca Cardelli says that OOP is slower and takes longer to compile than procedural programming.",
      "char_count": 380,
      "token_estimate": 95,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 2,
    "items": [
      {
        "question": "Who developed the first version of the Smalltalk programming language at Xerox PARC?",
        "answer": "The first version of the Smalltalk programming language was developed at Xerox PARC by Alan Kay, Dan Ingalls, and Adele Goldberg.",
        "related_chunk_ids": [
          "objectorientedprogra_315dbb3b_c0005"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "objectorientedprogra_315dbb3b_c0005"
        ]
      },
      {
        "question": "What is the term for the challenge that arises because relational databases do not store objects directly?",
        "answer": "The challenge that arises because relational databases don't store objects directly is called object-relational impedance mismatch.",
        "related_chunk_ids": [
          "objectorientedprogra_315dbb3b_c0020"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "objectorientedprogra_315dbb3b_c0020"
        ]
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-30T10:37:33.126Z",
    "content_format": "markdown",
    "total_chunks": 28,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}