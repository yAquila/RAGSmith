{
  "article": {
    "id": "continuationpassings_5cf42749",
    "title": "Continuation-passing style",
    "url": "https://en.wikipedia.org/wiki/Continuation-passing_style",
    "lang": "en",
    "created_at": "2025-07-30T10:37:16.495461",
    "content": "---\nid: continuationpassings_5cf42749\nurl: https://en.wikipedia.org/wiki/Continuation-passing_style\ntitle: Continuation-passing style\nlang: en\ncreated_at: '2025-07-30T10:36:41.855332'\nchecksum: 512f14954bee386f30608f59bec92a0359e0c282b561508ff111c8edd0f11c48\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 2\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 1807\n  char_count: 11558\n  num_chunks: 13\n  original_chunks: 16\n  filtered_out: 3\n  num_sections: 0\n---\nIn functional programming, continuation-passing style (CPS) is a style of programming in which control is passed explicitly in the form of a continuation. This is contrasted with direct style, which is the usual style of programming. Gerald Jay Sussman and Guy L. Steele, Jr. coined the phrase in AI Memo 349 (1975), which sets out the first version of the programming language Scheme. John C. Reynolds gives a detailed account of the many discoveries of continuations. A function written in continuation-passing style takes an extra argument: an explicit continuation; i.e., a function of one argument. When the CPS function has computed its result value, it \"returns\" it by calling the continuation function with this value as the argument. That means that when invoking a CPS function, the calling function is required to supply a procedure to be invoked with the subroutine's \"return\" value. Expressing code in this form makes a number of things explicit which are implicit in direct style. These include: procedure returns, which become apparent as calls to a continuation; intermediate values, which are all given names; order of argument evaluation, which is made explicit; and tail calls, which simply call a procedure with the same continuation, unmodified, that was passed to the caller. Programs can be automatically transformed from direct style to CPS. Functional and logic compilers often use CPS as an intermediate representation where a compiler for an imperative or procedural programming language would use static single assignment form (SSA). SSA is formally equivalent to a subset of CPS (excluding non-local control flow, which does not occur when CPS is used as intermediate representation). Functional compilers can also use A-normal form (ANF) (but only for languages requiring eager evaluation), rather than with thunks (described in the examples below) in CPS. CPS is used more frequently by compilers than by programmers as a local or global style. == Examples == In CPS, each procedure takes an extra argument representing what should be done with the result the function is calculating. This, along with a restrictive style prohibiting a variety of constructs usually available, is used to expose the semantics of programs, making them easier to analyze. This style also makes it easy to express unusual control structures, like catch/throw or other non-local transfers of control. The key to CPS is to remember that (a) every function takes an extra argument known as its continuation, and (b) every argument in a function call must be either a variable or a lambda expression (not a more complex expression). This has the effect of turning expressions \"inside-out\" because the innermost parts of the expression must be evaluated first, thus CPS makes explicit the order of evaluation as well as the control flow. Some examples of code in direct style and the corresponding CPS appear below. These examples are written in the programming language Scheme; by convention the continuation function is represented as a parameter named \"k\": In the CPS versions, the primitives used, like +& and *& are themselves CPS, not direct style, so to make the above examples work in a Scheme system requires writing these CPS versions of primitives, with for instance *& defined by: To do this in general, we might write a conversion routine: To call a procedure written in CPS from a procedure written in direct style, it is necessary to provide a continuation that will receive the result computed by the CPS procedure. In the example above (assuming that CPS primitives have been provided), we might call (factorial& 10 (lambda (x) (display x) (newline))). There is some variety between compilers in the way primitive functions are provided in CPS. Above is used the simplest convention, however sometimes Boolean primitives are provided that take two thunks to be called in the two possible cases, so the (=& n 0 (lambda (b) (if b ...))) call inside f-aux& definition above would be written instead as (=& n 0 (lambda () (k a)) (lambda () (-& n 1 ...))). Similarly, sometimes the if primitive is not included in CPS, and instead a function if& is provided which takes three arguments: a Boolean condition and the two thunks corresponding to the two arms of the conditional. The translations shown above show that CPS is a global transformation. The direct-style factorial takes, as might be expected, a single argument; the CPS factorial& takes two: the argument and a continuation. Any function calling a CPS-ed function must either provide a new continuation or pass its own; any calls from a CPS-ed function to a non-CPS function will use implicit continuations. Thus, to ensure the total absence of a function stack, the entire program must be in CPS. === CPS in Haskell === A function pyth to calculate a hypotenuse using the Pythagorean theorem can be written in Haskell. A traditional implementation of the pyth function looks like this: To transform the traditional function to CPS, its signature must be changed. The function will get another argument of function type, and its return type depends on that function: First we calculate the square of a in pyth' function and pass a lambda function as a continuation which will accept a square of a as a first argument. And so on until the result of the calculations are reached. To get the result of this function we can pass id function as a final argument which returns the value that was passed to it unchanged: pyth' 3 4 id == 5.0. The mtl library, which is shipped with Glasgow Haskell Compiler (GHC), has the module Control.Monad.Cont. This module provides the Cont type, which implements Monad and some other useful functions. The following snippet shows the pyth' function using Cont: Not only has the syntax become cleaner, but this type allows us to use a function callCC with type MonadCont m => ((a -> m b) -> m a) -> m a. This function has one argument of a function type; that function argument accepts the function too, which discards all computations going after its call. For example, let's break the execution of the pyth function if at least one of its arguments is negative returning zero: === Continuations as objects === Programming with continuations can also be useful when a caller does not want to wait until the callee completes. For example, in user interface (UI) programming, a routine can set up dialog box fields and pass these, along with a continuation function, to the UI framework. This call returns right away, allowing the application code to continue while the user interacts with the dialog box. Once the user presses the \"OK\" button, the framework calls the continuation function with the updated fields. Although this style of coding uses continuations, it is not full CPS. A similar idea can be used when the function must run in a different thread or on a different processor. The framework can execute the called function in a worker thread, then call the continuation function in the original thread with the worker's results. This is in Java 8 using the Swing UI framework: == Tail calls == Every call in CPS is a tail call, and the continuation is explicitly passed. Using CPS without tail call optimization (TCO) will cause both the constructed continuation to potentially grow during recursion, and the call stack. This is usually undesirable, but has been used in interesting ways; see the Chicken Scheme compiler. As CPS and TCO eliminate the concept of an implicit function return, their combined use can eliminate the need for a run-time stack. Several compilers and interpreters for functional programming languages use this ability in novel ways. == Use and implementation == Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. == Use in other fields == Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example. Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). == See also == Tail recursion through trampolining == Notes == == References == Continuation Passing C (CPC) - programming language for writing concurrent systems, designed and developed by Juliusz Chroboczek and Gabriel Kerneis. github repository The construction of a CPS-based compiler for ML is described in: Appel, Andrew W. (1992). Compiling with Continuations. Cambridge University Press. ISBN 978-0-521-41695-5. Danvy, Olivier; Filinski, Andrzej (1992). \"Representing Control, A Study of the CPS Transformation\". Mathematical Structures in Computer Science. 2 (4): 361–391. CiteSeerX 10.1.1.46.84. doi:10.1017/S0960129500001535. S2CID 8790522. Chicken Scheme compiler, a Scheme to C compiler that uses continuation-passing style for translating Scheme procedures into C functions while using the C-stack as the nursery for the generational garbage collector Kelsey, Richard A. (March 1995). \"A Correspondence between Continuation Passing Style and Static Single Assignment Form\". ACM SIGPLAN Notices. 30 (3): 13–22. CiteSeerX 10.1.1.3.6773. doi:10.1145/202530.202532. Appel, Andrew W. (April 1998). \"SSA is Functional Programming\". ACM SIGPLAN Notices. 33 (4): 17–20. CiteSeerX 10.1.1.34.3282. doi:10.1145/278283.278285. S2CID 207227209. Danvy, Olivier; Millikin, Kevin; Nielsen, Lasse R. (2007). \"On One-Pass CPS Transformations\". BRICS Report Series: 24. ISSN 0909-0878. RS-07-6. Retrieved 26 October 2007. Dybvig, R. Kent (2003). The Scheme Programming Language. Prentice Hall. p. 64. Direct link: \"Section 3.4. Continuation Passing Style\"."
  },
  "chunks": [
    {
      "id": "continuationpassings_5cf42749_c0000",
      "article_id": "continuationpassings_5cf42749",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 896,
      "content": "In functional programming, continuation-passing style (CPS) is a style of programming in which control is passed explicitly in the form of a continuation. This is contrasted with direct style, which is the usual style of programming. Gerald Jay Sussman and Guy L. Steele, Jr. coined the phrase in AI Memo 349 (1975), which sets out the first version of the programming language Scheme. John C. Reynolds gives a detailed account of the many discoveries of continuations. A function written in continuation-passing style takes an extra argument: an explicit continuation; i.e., a function of one argument. When the CPS function has computed its result value, it \"returns\" it by calling the continuation function with this value as the argument. That means that when invoking a CPS function, the calling function is required to supply a procedure to be invoked with the subroutine's \"return\" value.",
      "char_count": 895,
      "token_estimate": 223,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0001",
      "article_id": "continuationpassings_5cf42749",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 896,
      "end_char": 1886,
      "content": "Expressing code in this form makes a number of things explicit which are implicit in direct style. These include: procedure returns, which become apparent as calls to a continuation; intermediate values, which are all given names; order of argument evaluation, which is made explicit; and tail calls, which simply call a procedure with the same continuation, unmodified, that was passed to the caller. Programs can be automatically transformed from direct style to CPS. Functional and logic compilers often use CPS as an intermediate representation where a compiler for an imperative or procedural programming language would use static single assignment form (SSA). SSA is formally equivalent to a subset of CPS (excluding non-local control flow, which does not occur when CPS is used as intermediate representation). Functional compilers can also use A-normal form (ANF) (but only for languages requiring eager evaluation), rather than with thunks (described in the examples below) in CPS.",
      "char_count": 990,
      "token_estimate": 247,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0002",
      "article_id": "continuationpassings_5cf42749",
      "section": "== Examples ==",
      "heading_path": "== Examples ==",
      "start_char": 1990,
      "end_char": 2936,
      "content": "== Examples == In CPS, each procedure takes an extra argument representing what should be done with the result the function is calculating. This, along with a restrictive style prohibiting a variety of constructs usually available, is used to expose the semantics of programs, making them easier to analyze. This style also makes it easy to express unusual control structures, like catch/throw or other non-local transfers of control. The key to CPS is to remember that (a) every function takes an extra argument known as its continuation, and (b) every argument in a function call must be either a variable or a lambda expression (not a more complex expression). This has the effect of turning expressions \"inside-out\" because the innermost parts of the expression must be evaluated first, thus CPS makes explicit the order of evaluation as well as the control flow. Some examples of code in direct style and the corresponding CPS appear below.",
      "char_count": 945,
      "token_estimate": 236,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0003",
      "article_id": "continuationpassings_5cf42749",
      "section": "== Examples ==",
      "heading_path": "== Examples ==",
      "start_char": 2936,
      "end_char": 3781,
      "content": "These examples are written in the programming language Scheme; by convention the continuation function is represented as a parameter named \"k\": In the CPS versions, the primitives used, like +& and *& are themselves CPS, not direct style, so to make the above examples work in a Scheme system requires writing these CPS versions of primitives, with for instance *& defined by: To do this in general, we might write a conversion routine: To call a procedure written in CPS from a procedure written in direct style, it is necessary to provide a continuation that will receive the result computed by the CPS procedure. In the example above (assuming that CPS primitives have been provided), we might call (factorial& 10 (lambda (x) (display x) (newline))). There is some variety between compilers in the way primitive functions are provided in CPS.",
      "char_count": 845,
      "token_estimate": 211,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0004",
      "article_id": "continuationpassings_5cf42749",
      "section": "== Examples ==",
      "heading_path": "== Examples ==",
      "start_char": 3782,
      "end_char": 4699,
      "content": "Above is used the simplest convention, however sometimes Boolean primitives are provided that take two thunks to be called in the two possible cases, so the (=& n 0 (lambda (b) (if b ...))) call inside f-aux& definition above would be written instead as (=& n 0 (lambda () (k a)) (lambda () (-& n 1 ...))). Similarly, sometimes the if primitive is not included in CPS, and instead a function if& is provided which takes three arguments: a Boolean condition and the two thunks corresponding to the two arms of the conditional. The translations shown above show that CPS is a global transformation. The direct-style factorial takes, as might be expected, a single argument; the CPS factorial& takes two: the argument and a continuation. Any function calling a CPS-ed function must either provide a new continuation or pass its own; any calls from a CPS-ed function to a non-CPS function will use implicit continuations.",
      "char_count": 917,
      "token_estimate": 229,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0005",
      "article_id": "continuationpassings_5cf42749",
      "section": "== = CPS in Haskell ==",
      "heading_path": "== = CPS in Haskell ==",
      "start_char": 4798,
      "end_char": 5506,
      "content": "== = CPS in Haskell === A function pyth to calculate a hypotenuse using the Pythagorean theorem can be written in Haskell. A traditional implementation of the pyth function looks like this: To transform the traditional function to CPS, its signature must be changed. The function will get another argument of function type, and its return type depends on that function: First we calculate the square of a in pyth' function and pass a lambda function as a continuation which will accept a square of a as a first argument. And so on until the result of the calculations are reached. To get the result of this function we can pass id function as a final argument which returns the value that was passed to it unchanged: pyth' 3 4 id",
      "char_count": 729,
      "token_estimate": 182,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0006",
      "article_id": "continuationpassings_5cf42749",
      "section": "== 5.0. The mtl library, which is shipped with Glasgow Haskell Compiler (GHC), has the module Control.Monad.Cont. This module provides the Cont type, which implements Monad and some other useful functions. The following snippet shows the pyth' function using Cont: Not only has the syntax become cleaner, but this type allows us to use a function callCC with type MonadCont m => ((a -> m b) -> m a) -> m a. This function has one argument of a function type; that function argument accepts the function too, which discards all computations going after its call. For example, let's break the execution of the pyth function if at least one of its arguments is negative returning zero: ==",
      "heading_path": "== 5.0. The mtl library, which is shipped with Glasgow Haskell Compiler (GHC), has the module Control.Monad.Cont. This module provides the Cont type, which implements Monad and some other useful functions. The following snippet shows the pyth' function using Cont: Not only has the syntax become cleaner, but this type allows us to use a function callCC with type MonadCont m => ((a -> m b) -> m a) -> m a. This function has one argument of a function type; that function argument accepts the function too, which discards all computations going after its call. For example, let's break the execution of the pyth function if at least one of its arguments is negative returning zero: ==",
      "start_char": 6190,
      "end_char": 6217,
      "content": "== 5.0. The mtl library, which is shipped with Glasgow Haskell Compiler (GHC), has the module Control.Monad.Cont. This module provides the Cont type, which implements Monad and some other useful functions. The following snippet shows the pyth' function using Cont: Not only has the syntax become cleaner, but this type allows us to use a function callCC with type MonadCont m => ((a -> m b) -> m a) -> m a. This function has one argument of a function type; that function argument accepts the function too, which discards all computations going after its call. For example, let's break the execution of the pyth function if at least one of its arguments is negative returning zero: === Continuations as objects",
      "char_count": 710,
      "token_estimate": 177,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0007",
      "article_id": "continuationpassings_5cf42749",
      "section": "== = Programming with continuations can also be useful when a caller does not want to wait until the callee completes. For example, in user interface (UI) programming, a routine can set up dialog box fields and pass these, along with a continuation function, to the UI framework. This call returns right away, allowing the application code to continue while the user interacts with the dialog box. Once the user presses the \"OK\" button, the framework calls the continuation function with the updated fields. Although this style of coding uses continuations, it is not full CPS. A similar idea can be used when the function must run in a different thread or on a different processor. The framework can execute the called function in a worker thread, then call the continuation function in the original thread with the worker's results. This is in Java 8 using the Swing UI framework: ==",
      "heading_path": "== = Programming with continuations can also be useful when a caller does not want to wait until the callee completes. For example, in user interface (UI) programming, a routine can set up dialog box fields and pass these, along with a continuation function, to the UI framework. This call returns right away, allowing the application code to continue while the user interacts with the dialog box. Once the user presses the \"OK\" button, the framework calls the continuation function with the updated fields. Although this style of coding uses continuations, it is not full CPS. A similar idea can be used when the function must run in a different thread or on a different processor. The framework can execute the called function in a worker thread, then call the continuation function in the original thread with the worker's results. This is in Java 8 using the Swing UI framework: ==",
      "start_char": 7102,
      "end_char": 7114,
      "content": "== = Programming with continuations can also be useful when a caller does not want to wait until the callee completes. For example, in user interface (UI) programming, a routine can set up dialog box fields and pass these, along with a continuation function, to the UI framework. This call returns right away, allowing the application code to continue while the user interacts with the dialog box. Once the user presses the \"OK\" button, the framework calls the continuation function with the updated fields. Although this style of coding uses continuations, it is not full CPS. A similar idea can be used when the function must run in a different thread or on a different processor. The framework can execute the called function in a worker thread, then call the continuation function in the original thread with the worker's results. This is in Java 8 using the Swing UI framework: == Tail calls",
      "char_count": 896,
      "token_estimate": 224,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0008",
      "article_id": "continuationpassings_5cf42749",
      "section": "== Every call in CPS is a tail call, and the continuation is explicitly passed. Using CPS without tail call optimization (TCO) will cause both the constructed continuation to potentially grow during recursion, and the call stack. This is usually undesirable, but has been used in interesting ways; see the Chicken Scheme compiler. As CPS and TCO eliminate the concept of an implicit function return, their combined use can eliminate the need for a run-time stack. Several compilers and interpreters for functional programming languages use this ability in novel ways. ==",
      "heading_path": "== Every call in CPS is a tail call, and the continuation is explicitly passed. Using CPS without tail call optimization (TCO) will cause both the constructed continuation to potentially grow during recursion, and the call stack. This is usually undesirable, but has been used in interesting ways; see the Chicken Scheme compiler. As CPS and TCO eliminate the concept of an implicit function return, their combined use can eliminate the need for a run-time stack. Several compilers and interpreters for functional programming languages use this ability in novel ways. ==",
      "start_char": 7684,
      "end_char": 7708,
      "content": "== Every call in CPS is a tail call, and the continuation is explicitly passed. Using CPS without tail call optimization (TCO) will cause both the constructed continuation to potentially grow during recursion, and the call stack. This is usually undesirable, but has been used in interesting ways; see the Chicken Scheme compiler. As CPS and TCO eliminate the concept of an implicit function return, their combined use can eliminate the need for a run-time stack. Several compilers and interpreters for functional programming languages use this ability in novel ways. == Use and implementation",
      "char_count": 593,
      "token_estimate": 148,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0009",
      "article_id": "continuationpassings_5cf42749",
      "section": "== Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. ==",
      "heading_path": "== Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. ==",
      "start_char": 8828,
      "end_char": 9698,
      "content": "== Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation.",
      "char_count": 869,
      "token_estimate": 217,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0010",
      "article_id": "continuationpassings_5cf42749",
      "section": "== Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. ==",
      "heading_path": "== Continuation passing style can be used to implement continuations and control flow operators in a functional language that does not feature first-class continuations but does have first-class functions and tail-call optimization. Without tail-call optimization, techniques such as trampolining, i.e., using a loop that iteratively invokes thunk-returning functions, can be used; without first-class functions, it is even possible to convert tail calls into just gotos in such a loop. Writing code in CPS, while not impossible, is often error-prone. There are various translations, usually defined as one- or two-pass conversions of pure lambda calculus, which convert direct style expressions into CPS expressions. Writing in trampolined style, however, is extremely difficult; when used, it is usually the target of some sort of transformation, such as compilation. Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. ==",
      "start_char": 9698,
      "end_char": 9968,
      "content": "Functions using more than one continuation can be defined to capture various control flow paradigms, for example (in Scheme): A CPS transform is conceptually a Yoneda embedding. It is also similar to the embedding of lambda calculus in π-calculus. == Use in other fields",
      "char_count": 270,
      "token_estimate": 67,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0011",
      "article_id": "continuationpassings_5cf42749",
      "section": "== Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example. Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). ==",
      "heading_path": "== Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example. Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). ==",
      "start_char": 10011,
      "end_char": 10939,
      "content": "== Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example.",
      "char_count": 927,
      "token_estimate": 231,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "continuationpassings_5cf42749_c0012",
      "article_id": "continuationpassings_5cf42749",
      "section": "== Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example. Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). ==",
      "heading_path": "== Outside of computer science, CPS is of more general interest as an alternative to the conventional method of composing simple expressions into complex expressions. For example, within linguistic semantics, Chris Barker and his collaborators have suggested that specifying the denotations of sentences using CPS might explain certain phenomena in natural language. In mathematics, the Curry–Howard isomorphism between computer programs and mathematical proofs relates continuation-passing style translation to a variation of double-negation embeddings of classical logic into intuitionistic (constructive) logic. Unlike the regular double-negation translation, which maps atomic propositions p to ((p → ⊥) → ⊥), the continuation passing style replaces ⊥ by the type of the final expression. Accordingly, the result is obtained by passing the identity function as a continuation to the CPS expression, as in the above example. Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). ==",
      "start_char": 10939,
      "end_char": 11182,
      "content": "Classical logic itself relates to manipulating the continuation of programs directly, as in Scheme's call-with-current-continuation control operator, an observation due to Tim Griffin (using the closely related C control operator). == See also",
      "char_count": 243,
      "token_estimate": 60,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 2,
    "items": [
      {
        "question": "What intermediate representation is formally equivalent to a subset of Continuation-Passing Style (CPS)?",
        "answer": "Static single assignment form (SSA) is formally equivalent to a subset of CPS.",
        "related_chunk_ids": [
          "continuationpassings_5cf42749_c0001"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "continuationpassings_5cf42749_c0001"
        ]
      },
      {
        "question": "Explain how continuation-passing style (CPS) makes program semantics, such as control flow and evaluation order, more explicit compared to direct style.",
        "answer": "Continuation-passing style (CPS) makes program semantics explicit by altering how functions handle control and results. In CPS, every function takes an extra argument called a continuation, which is a function that receives the computed result. This transforms implicit procedure returns into explicit calls to the continuation function. Furthermore, CPS often imposes a rule that all arguments in a function call must be simple variables or lambda expressions. This forces complex expressions to be broken down, turning them \"inside-out\" so that the innermost parts are evaluated first. This process makes the order of argument evaluation explicit. By making returns and evaluation order explicit, the overall control flow of the program becomes more apparent and easier to analyze.",
        "related_chunk_ids": [
          "continuationpassings_5cf42749_c0000",
          "continuationpassings_5cf42749_c0001",
          "continuationpassings_5cf42749_c0002"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "continuationpassings_5cf42749_c0000",
          "continuationpassings_5cf42749_c0001",
          "continuationpassings_5cf42749_c0002"
        ]
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-30T10:37:30.746Z",
    "content_format": "markdown",
    "total_chunks": 13,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}