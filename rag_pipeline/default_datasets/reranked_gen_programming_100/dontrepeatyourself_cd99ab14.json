{
  "article": {
    "id": "dontrepeatyourself_cd99ab14",
    "title": "Don't repeat yourself",
    "url": "https://en.wikipedia.org/wiki/Don%27t_repeat_yourself",
    "lang": "en",
    "created_at": "2025-07-30T10:31:51.282975",
    "content": "---\nid: dontrepeatyourself_cd99ab14\nurl: https://en.wikipedia.org/wiki/Don%27t_repeat_yourself\ntitle: Don't repeat yourself\nlang: en\ncreated_at: '2025-07-30T10:30:53.329607'\nchecksum: b0dfb891a6399bf7b94f6fe38eedc0139df1a1c072d07bd177653a95a9ed0395\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 624\n  char_count: 3943\n  num_chunks: 4\n  original_chunks: 10\n  filtered_out: 6\n  num_sections: 0\n---\n\"Don't repeat yourself\" (DRY) is a principle of software development aimed at reducing repetition of information which is likely to change, replacing it with abstractions that are less likely to change, or using data normalization which avoids redundancy in the first place. The DRY principle is stated as \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system\". The principle has been formulated by Andy Hunt and Dave Thomas in their book The Pragmatic Programmer. They apply it quite broadly to include database schemas, test plans, the build system, even documentation. When the DRY principle is applied successfully, a modification of any single element of a system does not require a change in other logically unrelated elements. Additionally, elements that are logically related all change predictably and uniformly, and are thus kept in sync. Besides using methods and subroutines in their code, Thomas and Hunt rely on code generators, automatic build systems, and scripting languages to observe the DRY principle across layers. == Single choice principle == A particular case of DRY is the single choice principle. It was defined by Bertrand Meyer as: \"Whenever a software system must support a set of alternatives, one and only one module in the system should know their exhaustive list.\" It was applied when designing Eiffel. == Alternatives == === WET === The opposing view to DRY is called WET, a backronym commonly taken to stand for write everything twice (alternatively write every time, we enjoy typing or waste everyone's time). WET solutions are common in multi-tiered architectures where a developer may be tasked with, for example, adding a comment field on a form in a web application. The text string \"comment\" might be repeated in the label, the HTML tag, in a read function name, a private variable, database DDL, queries, and so on. A DRY approach eliminates that redundancy by using frameworks that reduce or eliminate all those editing tasks except the most important ones, leaving the extensibility of adding new knowledge variables in one place. This conceptualization of \"WET\" as an alternative to \"DRY\" programming has been around since at least 2002 in the Java world, though it is not known who coined the term. === AHA === Another approach to abstractions is to avoid hasty abstractions (AHA). AHA is rooted in the understanding that the deeper the investment engineers have made into abstracting a piece of software, the more they perceive that the cost of that investment can never be recovered (sunk cost fallacy). Thus, engineers tend to continue to iterate on the same abstraction each time the requirement changes. AHA programming assumes that both WET and DRY solutions inevitably create software that is rigid and difficult to maintain. Instead of starting with an abstraction, or abstracting at a specific number of duplications, software can be more flexible and robust if abstraction is done when it is needed, or, when the duplication itself has become the barrier and it is known how the abstraction needs to function. According to Kent C. Dodds, it is optimizing for change first, and avoiding premature optimization. The term was coined by software engineer Cher Scarlett and the practice was described originally by software engineer and author Sandi Metz as \"prefer duplication over the wrong abstraction\". == See also == == References == == External links == Don't Repeat Yourself at WikiWikiWeb Once and Only Once at WikiWikiWeb 97 Things Every Programmer Should Know (O'Reilly) The myth of over-normalization (discussion of academic extremes vs. real-world database scenarios) Wilson G, Aruliah DA, Brown CT, Chue Hong NP, Davis M, Guy RT, et al. (2014). \"Best Practices for Scientific Computing\". PLOS Biol. 12 (1): e1001745. arXiv:1210.0530. doi:10.1371/journal.pbio.1001745. PMC 3886731. PMID 24415924. Don't Repeat Yourself (or Others)"
  },
  "chunks": [
    {
      "id": "dontrepeatyourself_cd99ab14_c0000",
      "article_id": "dontrepeatyourself_cd99ab14",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 899,
      "content": "\"Don't repeat yourself\" (DRY) is a principle of software development aimed at reducing repetition of information which is likely to change, replacing it with abstractions that are less likely to change, or using data normalization which avoids redundancy in the first place. The DRY principle is stated as \"Every piece of knowledge must have a single, unambiguous, authoritative representation within a system\". The principle has been formulated by Andy Hunt and Dave Thomas in their book The Pragmatic Programmer. They apply it quite broadly to include database schemas, test plans, the build system, even documentation. When the DRY principle is applied successfully, a modification of any single element of a system does not require a change in other logically unrelated elements. Additionally, elements that are logically related all change predictably and uniformly, and are thus kept in sync.",
      "char_count": 898,
      "token_estimate": 224,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "dontrepeatyourself_cd99ab14_c0001",
      "article_id": "dontrepeatyourself_cd99ab14",
      "section": "== Single choice principle ==",
      "heading_path": "== Single choice principle ==",
      "start_char": 1115,
      "end_char": 1386,
      "content": "== Single choice principle == A particular case of DRY is the single choice principle. It was defined by Bertrand Meyer as: \"Whenever a software system must support a set of alternatives, one and only one module in the system should know their exhaustive list.\" It was applied when designing Eiffel.",
      "char_count": 299,
      "token_estimate": 74,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "dontrepeatyourself_cd99ab14_c0002",
      "article_id": "dontrepeatyourself_cd99ab14",
      "section": "== = WET ==",
      "heading_path": "== = WET ==",
      "start_char": 1416,
      "end_char": 2296,
      "content": "== = WET === The opposing view to DRY is called WET, a backronym commonly taken to stand for write everything twice (alternatively write every time, we enjoy typing or waste everyone's time). WET solutions are common in multi-tiered architectures where a developer may be tasked with, for example, adding a comment field on a form in a web application. The text string \"comment\" might be repeated in the label, the HTML tag, in a read function name, a private variable, database DDL, queries, and so on. A DRY approach eliminates that redundancy by using frameworks that reduce or eliminate all those editing tasks except the most important ones, leaving the extensibility of adding new knowledge variables in one place. This conceptualization of \"WET\" as an alternative to \"DRY\" programming has been around since at least 2002 in the Java world, though it is not known who coined the term.",
      "char_count": 890,
      "token_estimate": 222,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "dontrepeatyourself_cd99ab14_c0003",
      "article_id": "dontrepeatyourself_cd99ab14",
      "section": "== = AHA ==",
      "heading_path": "== = AHA ==",
      "start_char": 2307,
      "end_char": 3229,
      "content": "== = AHA === Another approach to abstractions is to avoid hasty abstractions (AHA). AHA is rooted in the understanding that the deeper the investment engineers have made into abstracting a piece of software, the more they perceive that the cost of that investment can never be recovered (sunk cost fallacy). Thus, engineers tend to continue to iterate on the same abstraction each time the requirement changes. AHA programming assumes that both WET and DRY solutions inevitably create software that is rigid and difficult to maintain. Instead of starting with an abstraction, or abstracting at a specific number of duplications, software can be more flexible and robust if abstraction is done when it is needed, or, when the duplication itself has become the barrier and it is known how the abstraction needs to function. According to Kent C. Dodds, it is optimizing for change first, and avoiding premature optimization.",
      "char_count": 921,
      "token_estimate": 230,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 4,
    "items": [
      {
        "question": "According to Kent C. Dodds, what is the primary goal of the AHA (Avoid Hasty Abstractions) approach?",
        "answer": "According to Kent C. Dodds, the AHA approach is about optimizing for change first and avoiding premature optimization.",
        "related_chunk_ids": [
          "dontrepeatyourself_cd99ab14_c0003"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "dontrepeatyourself_cd99ab14_c0003"
        ]
      },
      {
        "question": "Who formulated the \"Don't repeat yourself\" (DRY) principle and in what publication?",
        "answer": "The DRY principle was formulated by Andy Hunt and Dave Thomas in their book The Pragmatic Programmer.",
        "related_chunk_ids": [
          "dontrepeatyourself_cd99ab14_c0000"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "dontrepeatyourself_cd99ab14_c0000"
        ]
      },
      {
        "question": "What are the common meanings of the backronym WET in programming?",
        "answer": "WET is a backronym that commonly stands for \"write everything twice\". Alternative meanings include \"write every time\", \"we enjoy typing\", or \"waste everyone's time\".",
        "related_chunk_ids": [
          "dontrepeatyourself_cd99ab14_c0002"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "dontrepeatyourself_cd99ab14_c0002"
        ]
      },
      {
        "question": "What is the relationship between the DRY principle and the Single Choice Principle, and how does the WET approach contrast with both?",
        "answer": "The Single Choice Principle is a specific application or a \"particular case\" of the broader \"Don't repeat yourself\" (DRY) principle. The WET (write everything twice) approach is the opposing view to DRY. While DRY and its specific application, the Single Choice Principle, aim to reduce repetition by ensuring every piece of knowledge has a single, authoritative representation, WET solutions embrace redundancy, such as repeating a text string across multiple layers of an application like the UI, database, and code.",
        "related_chunk_ids": [
          "dontrepeatyourself_cd99ab14_c0000",
          "dontrepeatyourself_cd99ab14_c0001",
          "dontrepeatyourself_cd99ab14_c0002"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "dontrepeatyourself_cd99ab14_c0001",
          "dontrepeatyourself_cd99ab14_c0002",
          "dontrepeatyourself_cd99ab14_c0000"
        ]
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-30T10:37:31.433Z",
    "content_format": "markdown",
    "total_chunks": 4,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}