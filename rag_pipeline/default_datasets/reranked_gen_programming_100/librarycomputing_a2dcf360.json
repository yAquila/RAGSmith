{
  "article": {
    "id": "librarycomputing_a2dcf360",
    "title": "Library (computing)",
    "url": "https://en.wikipedia.org/wiki/Library_(computing)",
    "lang": "en",
    "created_at": "2025-07-30T10:33:32.884682",
    "content": "---\nid: librarycomputing_a2dcf360\nurl: https://en.wikipedia.org/wiki/Library_(computing)\ntitle: Library (computing)\nlang: en\ncreated_at: '2025-07-30T10:31:07.612646'\nchecksum: 5394cff9fe690da943bb3ee885bf16f429fa9fb74637cf2beb36d5cfe9c85dc8\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 2058\n  char_count: 12882\n  num_chunks: 19\n  original_chunks: 28\n  filtered_out: 9\n  num_sections: 0\n---\nIn computing, a library is a collection of resources that can be used during software development to implement a computer program. Commonly, a library consists of executable code such as compiled functions and classes, or a library can be a collection of source code. A resource library may contain data such as images and text. A library can be used by multiple, independent consumers (programs and other libraries). This differs from resources defined in a program which can usually only be used by that program. When a consumer uses a library resource, it gains the value of the library without having to implement it itself. Libraries encourage software reuse in a modular fashion. Libraries can use other libraries resulting in a hierarchy of libraries in a program. When writing code that uses a library, a programmer only needs to know how to use it – not its internal details. For example, a program could use a library that abstracts a complicated system call so that the programmer can use the system feature without spending time to learn the intricacies of the system function. == History == The idea of a computer library dates back to the first computers created by Charles Babbage. An 1888 paper on his Analytical Engine suggested that computer operations could be punched on separate cards from numerical input. If these operation punch cards were saved for reuse then \"by degrees the engine would have a library of its own.\" In 1947 Goldstine and von Neumann speculated that it would be useful to create a \"library\" of subroutines for their work on the IAS machine, an early computer that was not yet operational at that time. They envisioned a physical library of magnetic wire recordings, with each wire storing reusable computer code. Inspired by von Neumann, Wilkes and his team constructed EDSAC. A filing cabinet of punched tape held the subroutine library for this computer. Programs for EDSAC consisted of a main program and a sequence of subroutines copied from the subroutine library. In 1951 the team published the first textbook on programming, The Preparation of Programs for an Electronic Digital Computer, which detailed the creation and the purpose of the library. COBOL included \"primitive capabilities for a library system\" in 1959, but Jean Sammet described them as \"inadequate library facilities\" in retrospect. JOVIAL has a Communication Pool (COMPOOL), roughly a library of header files. Another major contributor to the modern library concept came in the form of the subprogram innovation of FORTRAN. FORTRAN subprograms can be compiled independently of each other, but the compiler lacked a linker. So prior to the introduction of modules in Fortran-90, type checking between FORTRAN subprograms was impossible. By the mid 1960s, copy and macro libraries for assemblers were common. Starting with the popularity of the IBM System/360, libraries containing other types of text elements, e.g., system parameters, also became common. In IBM's OS/360 and its successors this is called a partitioned data set. The first object-oriented programming language, Simula, developed in 1965, supported adding classes to libraries via its compiler. == Linking == The linking (or binding) process resolves references known as symbols (or links) by searching for them in various locations including configured libraries. If a linker (or binder) does not find a symbol, then it fails, but multiple matches may or may not cause failure. Static linking is linking at build time, such that the library executable code is included in the program. Dynamic linking is linking at run time; it involves building the program with information that supports run-time linking to a dynamic link library (DLL). For dynamic linking, a compatible DLL file must be available to the program at run time, but for static linking, the program is standalone. Smart linking is performed by a build tool that excludes unused code in the linking process. For example, a program that only uses integers for arithmetic, or does no arithmetic operations at all, can exclude floating-point library routines. This can lead to smaller program file size and reduced memory usage. == Relocation == Some references in a program or library module are stored in a relative or symbolic form which cannot be resolved until all code and libraries are assigned final static addresses. Relocation is the process of adjusting these references, and is done either by the linker or the loader. In general, relocation cannot be done to individual libraries themselves because the addresses in memory may vary depending on the program using them and other libraries they are combined with. Position-independent code avoids references to absolute addresses and therefore does not require relocation. == Categories == === Executable === An executable library consists of code that has been converted from source code into machine code or an intermediate form such as bytecode. A linker allows for using library objects by associating each reference with an address at which the object is located. For example, in C, a library function is invoked via C's normal function call syntax and semantics. A variant is a library containing compiled code (object code in IBM's nomenclature) in a form that cannot be loaded by the OS but that can be read by the linker. === Static === A static library is an executable library that is linked into a program at build-time by a linker (or whatever the build tool is called that does linking). This process, and the resulting stand-alone file, is known as a static build of the program. A static build may not need any further relocation if virtual memory is used and no address space layout randomization is desired. A static library is sometimes called an archive on Unix-like systems. === Dynamic === A dynamic library is linked when the program is run – either at load-time or runtime. The dynamic library was intended after the static library to support additional software deployment flexibility. === Sources === A source library consists of source code; not compiled code. === Shared === A shared library is a library that contains executable code designed to be used by multiple computer programs or other libraries at runtime, with only one copy of that code in memory, shared by all programs using the code. === Object === Although generally an obsolete technology today, an object library exposes resources for object-oriented programming (OOP) and a distributed object is a remote object library. Examples include: COM/DCOM, SOM/DSOM, DOE, PDO and various CORBA-based systems. The object library technology was developed since as OOP became popular, it became apparent that OOP runtime binding required information than contemporary libraries did not provide. In addition to the names and entry points of the code located within, due to inheritance, OOP binding also requires a list of dependencies – since the full definition of a method may be in different places. Further, this requires more than listing that one library requires the services of another. In OOP, the libraries themselves may not be known at compile time, and vary from system to system. The remote object technology was developed in parallel to support multi-tier programs with a user interface application running on a personal computer (PC) using services of a mainframe or minicomputer such as data storage and processing. For instance, a program on a PC would send messages to a minicomputer via remote procedure call (RPC) to retrieve relatively small samples from a relatively large dataset. In response, distributed object technology was developed. === Class === A class library contains classes that can be used to create objects. In Java, for example, classes are contained in JAR files and objects are created at runtime from the classes. However, in Smalltalk, a class library is the starting point for a system image that includes the entire state of the environment, classes and all instantiated objects. Most class libraries are stored in a package repository (such as Maven Central for Java). Client code explicitly specifies dependencies to external libraries in build configuration files (such as a Maven Pom in Java). === Remote === A remote library runs on another computer and its assets are accessed via remote procedure call (RPC) over a network. This distributed architecture allows for minimizing installation of the library and support for it on each consuming system and ensuring consistent versioning. A significant downside is that each library call entails significantly more overhead than for a local library. === Runtime === A runtime library provides access to the runtime environment that is available to a program – tailored to the host platform. === Language standard === Many modern programming languages specify a standard library that provides a base level of functionality for the language environment. === Code generation === A code generation library has a high-level API generating or transforming byte code for Java. They are used by aspect-oriented programming, some data access frameworks, and for testing to generate dynamic proxy objects. They also are used to intercept field access. == File naming == === Unix-like === On most modern Unix-like systems, library files are stored in directories such as /lib, /usr/lib and /usr/local/lib. A filename typically starts with lib, and ends with .a for a static library (archive) or .so for a shared object (dynamically linked library). For example, libfoo.a and libfoo.so. Often, symbolic link files are used to manage versioning of a library by providing a link file named without a version that links to a file named with a version. For example, libfoo.so.2 might be version 2 of library foo and a link file named libfoo.so provides a version independent name to that file that programs link to. The link file could be changed to a refer to a version 3 (libfoo.so.3) such that consuming programs will then use version 3 without having to change the program. Files with extension .la are libtool archives; not usable by the system. === macOS === The macOS system inherits static library conventions from BSD, with the library stored in a .a file. It uses either .so or .dylib for dynamic libraries. Most libraries in macOS, however, consist of \"frameworks\", placed inside special directories called \"bundles\" which wrap the library's required files and metadata. For example, a framework called Abc would be implemented in a bundle called Abc.framework, with Abc.framework/Abc being either the dynamically linked library file or a symlink to the dynamically linked library file in Abc.framework/Versions/Current/Abc. === Windows === Often, a Windows dynamic-link library (DLL) has the file extension .dll, although sometimes different extensions are used to indicate general content, e.g. .ocx for a OLE library. A .lib file can be either a static library or contain the information needed to build an application that consumes the associated DLL. In the latter case, the associated DLL file must be present at runtime. == See also == Code reuse – Using existing code in new software Object file – File containing relocatable format machine code Plug-in – Software component that extends the functionality of existing software Prelink, also known as prebinding Runtime library – Access to a program's runtime environment Visual Component Library – Object Pascal framework for Windows (VCL) Component Library for Cross Platform (CLX) C standard library – Standard library for the C programming language Java Class Library – Core Java libraries Framework Class Library – Standard library of Microsoft's .NET Framework Generic programming – Style of computer programming (used by the C++ Standard Library) soname – Field of data in a shared object file Method stub – Short and simple version of a method List of open source code libraries == Notes == == References == == Further reading == Levine, John R. (2000) [October 1999]. \"Chapter 9: Shared Libraries & Chapter 10: Dynamic Linking and Loading\". Linkers and Loaders. The Morgan Kaufmann Series in Software Engineering and Programming (1 ed.). San Francisco, USA: Morgan Kaufmann. ISBN 1-55860-496-0. OCLC 42413382. Archived from the original on 2012-12-05. Retrieved 2020-01-12. Code:  Errata:  Article Beginner's Guide to Linkers by David Drysdale Article Faster C++ program startups by improving runtime linking efficiency by Léon Bottou and John Ryland How to Create Program Libraries by Baris Simsek BFD - the Binary File Descriptor Library 1st Library-Centric Software Design Workshop LCSD'05 Archived 2019-08-28 at the Wayback Machine at OOPSLA'05 2nd Library-Centric Software Design Workshop LCSD'06 at OOPSLA'06 How to create shared library by Ulrich Drepper (with much background info) Anatomy of Linux dynamic libraries at IBM.com"
  },
  "chunks": [
    {
      "id": "librarycomputing_a2dcf360_c0000",
      "article_id": "librarycomputing_a2dcf360",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 885,
      "content": "In computing, a library is a collection of resources that can be used during software development to implement a computer program. Commonly, a library consists of executable code such as compiled functions and classes, or a library can be a collection of source code. A resource library may contain data such as images and text. A library can be used by multiple, independent consumers (programs and other libraries). This differs from resources defined in a program which can usually only be used by that program. When a consumer uses a library resource, it gains the value of the library without having to implement it itself. Libraries encourage software reuse in a modular fashion. Libraries can use other libraries resulting in a hierarchy of libraries in a program. When writing code that uses a library, a programmer only needs to know how to use it – not its internal details.",
      "char_count": 884,
      "token_estimate": 221,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0001",
      "article_id": "librarycomputing_a2dcf360",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 885,
      "end_char": 1089,
      "content": "For example, a program could use a library that abstracts a complicated system call so that the programmer can use the system feature without spending time to learn the intricacies of the system function.",
      "char_count": 204,
      "token_estimate": 51,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0002",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 1103,
      "end_char": 2025,
      "content": "== History == The idea of a computer library dates back to the first computers created by Charles Babbage. An 1888 paper on his Analytical Engine suggested that computer operations could be punched on separate cards from numerical input. If these operation punch cards were saved for reuse then \"by degrees the engine would have a library of its own.\" In 1947 Goldstine and von Neumann speculated that it would be useful to create a \"library\" of subroutines for their work on the IAS machine, an early computer that was not yet operational at that time. They envisioned a physical library of magnetic wire recordings, with each wire storing reusable computer code. Inspired by von Neumann, Wilkes and his team constructed EDSAC. A filing cabinet of punched tape held the subroutine library for this computer. Programs for EDSAC consisted of a main program and a sequence of subroutines copied from the subroutine library.",
      "char_count": 921,
      "token_estimate": 230,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0003",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 2025,
      "end_char": 2984,
      "content": "In 1951 the team published the first textbook on programming, The Preparation of Programs for an Electronic Digital Computer, which detailed the creation and the purpose of the library. COBOL included \"primitive capabilities for a library system\" in 1959, but Jean Sammet described them as \"inadequate library facilities\" in retrospect. JOVIAL has a Communication Pool (COMPOOL), roughly a library of header files. Another major contributor to the modern library concept came in the form of the subprogram innovation of FORTRAN. FORTRAN subprograms can be compiled independently of each other, but the compiler lacked a linker. So prior to the introduction of modules in Fortran-90, type checking between FORTRAN subprograms was impossible. By the mid 1960s, copy and macro libraries for assemblers were common. Starting with the popularity of the IBM System/360, libraries containing other types of text elements, e.g., system parameters, also became common.",
      "char_count": 959,
      "token_estimate": 239,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0004",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 2985,
      "end_char": 3189,
      "content": "In IBM's OS/360 and its successors this is called a partitioned data set. The first object-oriented programming language, Simula, developed in 1965, supported adding classes to libraries via its compiler.",
      "char_count": 204,
      "token_estimate": 51,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0005",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== Linking ==",
      "heading_path": "== Linking ==",
      "start_char": 3190,
      "end_char": 4173,
      "content": "== Linking == The linking (or binding) process resolves references known as symbols (or links) by searching for them in various locations including configured libraries. If a linker (or binder) does not find a symbol, then it fails, but multiple matches may or may not cause failure. Static linking is linking at build time, such that the library executable code is included in the program. Dynamic linking is linking at run time; it involves building the program with information that supports run-time linking to a dynamic link library (DLL). For dynamic linking, a compatible DLL file must be available to the program at run time, but for static linking, the program is standalone. Smart linking is performed by a build tool that excludes unused code in the linking process. For example, a program that only uses integers for arithmetic, or does no arithmetic operations at all, can exclude floating-point library routines. This can lead to smaller program file size and reduced memory usage.",
      "char_count": 995,
      "token_estimate": 248,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0006",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== Relocation ==",
      "heading_path": "== Relocation ==",
      "start_char": 4189,
      "end_char": 4778,
      "content": "== Relocation == Some references in a program or library module are stored in a relative or symbolic form which cannot be resolved until all code and libraries are assigned final static addresses. Relocation is the process of adjusting these references, and is done either by the linker or the loader. In general, relocation cannot be done to individual libraries themselves because the addresses in memory may vary depending on the program using them and other libraries they are combined with. Position-independent code avoids references to absolute addresses and therefore does not require relocation.",
      "char_count": 604,
      "token_estimate": 151,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0007",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = Executable ==",
      "heading_path": "== = Executable ==",
      "start_char": 4813,
      "end_char": 5337,
      "content": "== = Executable === An executable library consists of code that has been converted from source code into machine code or an intermediate form such as bytecode. A linker allows for using library objects by associating each reference with an address at which the object is located. For example, in C, a library function is invoked via C's normal function call syntax and semantics. A variant is a library containing compiled code (object code in IBM's nomenclature) in a form that cannot be loaded by the OS but that can be read by the linker.",
      "char_count": 541,
      "token_estimate": 135,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0008",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = Static ==",
      "heading_path": "== = Static ==",
      "start_char": 5351,
      "end_char": 5803,
      "content": "== = Static === A static library is an executable library that is linked into a program at build-time by a linker (or whatever the build tool is called that does linking). This process, and the resulting stand-alone file, is known as a static build of the program. A static build may not need any further relocation if virtual memory is used and no address space layout randomization is desired. A static library is sometimes called an archive on Unix-like systems.",
      "char_count": 465,
      "token_estimate": 116,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0009",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = Dynamic ==",
      "heading_path": "== = Dynamic ==",
      "start_char": 5818,
      "end_char": 6019,
      "content": "== = Dynamic === A dynamic library is linked when the program is run – either at load-time or runtime. The dynamic library was intended after the static library to support additional software deployment flexibility.",
      "char_count": 215,
      "token_estimate": 53,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0010",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = Shared ==",
      "heading_path": "== = Shared ==",
      "start_char": 6111,
      "end_char": 6336,
      "content": "== = Shared === A shared library is a library that contains executable code designed to be used by multiple computer programs or other libraries at runtime, with only one copy of that code in memory, shared by all programs using the code.",
      "char_count": 238,
      "token_estimate": 59,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0011",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = Object ==",
      "heading_path": "== = Object ==",
      "start_char": 6350,
      "end_char": 7203,
      "content": "== = Object === Although generally an obsolete technology today, an object library exposes resources for object-oriented programming (OOP) and a distributed object is a remote object library. Examples include: COM/DCOM, SOM/DSOM, DOE, PDO and various CORBA-based systems. The object library technology was developed since as OOP became popular, it became apparent that OOP runtime binding required information than contemporary libraries did not provide. In addition to the names and entry points of the code located within, due to inheritance, OOP binding also requires a list of dependencies – since the full definition of a method may be in different places. Further, this requires more than listing that one library requires the services of another. In OOP, the libraries themselves may not be known at compile time, and vary from system to system.",
      "char_count": 852,
      "token_estimate": 213,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0012",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = Object ==",
      "heading_path": "== = Object ==",
      "start_char": 7203,
      "end_char": 7671,
      "content": "The remote object technology was developed in parallel to support multi-tier programs with a user interface application running on a personal computer (PC) using services of a mainframe or minicomputer such as data storage and processing. For instance, a program on a PC would send messages to a minicomputer via remote procedure call (RPC) to retrieve relatively small samples from a relatively large dataset. In response, distributed object technology was developed.",
      "char_count": 468,
      "token_estimate": 117,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0013",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = Class ==",
      "heading_path": "== = Class ==",
      "start_char": 7671,
      "end_char": 8239,
      "content": "== = Class === A class library contains classes that can be used to create objects. In Java, for example, classes are contained in JAR files and objects are created at runtime from the classes. However, in Smalltalk, a class library is the starting point for a system image that includes the entire state of the environment, classes and all instantiated objects. Most class libraries are stored in a package repository (such as Maven Central for Java). Client code explicitly specifies dependencies to external libraries in build configuration files (such as a Maven Pom in Java).",
      "char_count": 580,
      "token_estimate": 145,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0014",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = Remote ==",
      "heading_path": "== = Remote ==",
      "start_char": 8253,
      "end_char": 8644,
      "content": "== = Remote === A remote library runs on another computer and its assets are accessed via remote procedure call (RPC) over a network. This distributed architecture allows for minimizing installation of the library and support for it on each consuming system and ensuring consistent versioning. A significant downside is that each library call entails significantly more overhead than for a local library.",
      "char_count": 404,
      "token_estimate": 101,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0015",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = Code generation ==",
      "heading_path": "== = Code generation ==",
      "start_char": 8971,
      "end_char": 9239,
      "content": "== = Code generation === A code generation library has a high-level API generating or transforming byte code for Java. They are used by aspect-oriented programming, some data access frameworks, and for testing to generate dynamic proxy objects. They also are used to intercept field access.",
      "char_count": 290,
      "token_estimate": 72,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0016",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = Unix-like ==",
      "heading_path": "== = Unix-like ==",
      "start_char": 9274,
      "end_char": 10133,
      "content": "== = Unix-like === On most modern Unix-like systems, library files are stored in directories such as /lib, /usr/lib and /usr/local/lib. A filename typically starts with lib, and ends with .a for a static library (archive) or .so for a shared object (dynamically linked library). For example, libfoo.a and libfoo.so. Often, symbolic link files are used to manage versioning of a library by providing a link file named without a version that links to a file named with a version. For example, libfoo.so.2 might be version 2 of library foo and a link file named libfoo.so provides a version independent name to that file that programs link to. The link file could be changed to a refer to a version 3 (libfoo.so.3) such that consuming programs will then use version 3 without having to change the program. Files with extension .la are libtool archives; not usable by the system.",
      "char_count": 875,
      "token_estimate": 218,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0017",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = macOS ==",
      "heading_path": "== = macOS ==",
      "start_char": 10146,
      "end_char": 10719,
      "content": "== = macOS === The macOS system inherits static library conventions from BSD, with the library stored in a .a file. It uses either .so or .dylib for dynamic libraries. Most libraries in macOS, however, consist of \"frameworks\", placed inside special directories called \"bundles\" which wrap the library's required files and metadata. For example, a framework called Abc would be implemented in a bundle called Abc.framework, with Abc.framework/Abc being either the dynamically linked library file or a symlink to the dynamically linked library file in Abc.framework/Versions/Current/Abc.",
      "char_count": 585,
      "token_estimate": 146,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "librarycomputing_a2dcf360_c0018",
      "article_id": "librarycomputing_a2dcf360",
      "section": "== = Windows ==",
      "heading_path": "== = Windows ==",
      "start_char": 10734,
      "end_char": 11123,
      "content": "== = Windows === Often, a Windows dynamic-link library (DLL) has the file extension .dll, although sometimes different extensions are used to indicate general content, e.g. .ocx for a OLE library. A .lib file can be either a static library or contain the information needed to build an application that consumes the associated DLL. In the latter case, the associated DLL file must be present at runtime.",
      "char_count": 403,
      "token_estimate": 100,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 9,
    "items": [
      {
        "question": "What is the key difference between a program using static linking and one using dynamic linking regarding its runtime requirements?",
        "answer": "A program that uses static linking is standalone because the library's executable code is included within the program itself. In contrast, a program using dynamic linking is not standalone and requires a compatible dynamic link library (DLL) file to be available to it at run time.",
        "related_chunk_ids": [
          "librarycomputing_a2dcf360_c0005"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "librarycomputing_a2dcf360_c0005"
        ]
      },
      {
        "question": "What was the title of the first textbook on programming, published in 1951, that detailed the concept of a library?",
        "answer": "The first textbook on programming, published in 1951, was titled \"The Preparation of Programs for an Electronic Digital Computer\".",
        "related_chunk_ids": [
          "librarycomputing_a2dcf360_c0003"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "librarycomputing_a2dcf360_c0003"
        ]
      },
      {
        "question": "What types of resources can a library in computing contain?",
        "answer": "A library can contain executable code like compiled functions and classes, a collection of source code, or data such as images and text.",
        "related_chunk_ids": [
          "librarycomputing_a2dcf360_c0000"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "librarycomputing_a2dcf360_c0000"
        ]
      },
      {
        "question": "How does the historical implementation of the subroutine library for the EDSAC computer align with the modern concept of a software library?",
        "answer": "The subroutine library for the EDSAC computer, which consisted of a filing cabinet of punched tape subroutines, aligns with the modern concept of a software library by promoting software reuse. Programs for the EDSAC were built by copying subroutines from this library, which is an early example of the modern practice where developers use pre-existing library code to build new programs without having to implement the functionality themselves.",
        "related_chunk_ids": [
          "librarycomputing_a2dcf360_c0000",
          "librarycomputing_a2dcf360_c0001",
          "librarycomputing_a2dcf360_c0002"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "librarycomputing_a2dcf360_c0002",
          "librarycomputing_a2dcf360_c0000",
          "librarycomputing_a2dcf360_c0001"
        ]
      },
      {
        "question": "What was a key limitation of early FORTRAN subprograms, and how does the process of linking resolve such limitations?",
        "answer": "A key limitation of early FORTRAN was that while its subprograms could be compiled independently, the compiler lacked a linker, which made type checking between them impossible. The linking process resolves this by searching for and resolving references, known as symbols, across different code units and libraries, effectively connecting them into a cohesive program.",
        "related_chunk_ids": [
          "librarycomputing_a2dcf360_c0003",
          "librarycomputing_a2dcf360_c0004",
          "librarycomputing_a2dcf360_c0005"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "librarycomputing_a2dcf360_c0003",
          "librarycomputing_a2dcf360_c0005",
          "librarycomputing_a2dcf360_c0004"
        ]
      },
      {
        "question": "What is the role of the linker in resolving references within library code?",
        "answer": "A linker makes library objects usable by associating each reference with the final static address where the object is located. This process of adjusting relative or symbolic references to their final addresses is known as relocation, which is a task the linker can perform.",
        "related_chunk_ids": [
          "librarycomputing_a2dcf360_c0006",
          "librarycomputing_a2dcf360_c0007"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "librarycomputing_a2dcf360_c0006",
          "librarycomputing_a2dcf360_c0007"
        ]
      },
      {
        "question": "How does the example of a library abstracting a system call illustrate the benefits of using libraries in software development?",
        "answer": "The example of a library abstracting a complicated system call illustrates a key benefit of libraries: a programmer can use the library's functionality without needing to understand its internal details. This allows the programmer to use a system feature without spending time learning the intricacies of the system function, thereby gaining value and encouraging software reuse in a modular fashion.",
        "related_chunk_ids": [
          "librarycomputing_a2dcf360_c0000",
          "librarycomputing_a2dcf360_c0001"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "librarycomputing_a2dcf360_c0001",
          "librarycomputing_a2dcf360_c0000"
        ]
      },
      {
        "question": "Trace the evolution of computer libraries from their earliest theoretical conception through the mid-1960s, highlighting key innovations, storage media, and associated programming languages.",
        "answer": "The concept of a computer library originated in an 1888 paper on Charles Babbage's Analytical Engine, which suggested saving operation punch cards for reuse. In 1947, Goldstine and von Neumann proposed a physical library of subroutines on magnetic wire recordings for the IAS machine. This inspired the EDSAC computer, which used a library of subroutines stored on punched tape. By 1951, a textbook detailed the library's creation and purpose. Later innovations included COBOL's primitive library system in 1959 and FORTRAN's subprograms, which could be compiled independently. By the mid-1960s, with the popularity of the IBM System/360, libraries for assemblers and other text elements (stored in partitioned data sets) became common. The first object-oriented language, Simula, developed in 1965, also supported adding classes to libraries.",
        "related_chunk_ids": [
          "librarycomputing_a2dcf360_c0002",
          "librarycomputing_a2dcf360_c0003",
          "librarycomputing_a2dcf360_c0004"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "librarycomputing_a2dcf360_c0003",
          "librarycomputing_a2dcf360_c0002",
          "librarycomputing_a2dcf360_c0004"
        ]
      },
      {
        "question": "What technological need prompted the development of distributed object technology, and how is a distributed object defined in this context?",
        "answer": "Distributed object technology was developed to support multi-tier programs where a user interface on a personal computer (PC) needed to use services, such as data storage and processing, from a mainframe or minicomputer. In this context, a distributed object is defined as a remote object library, which exposes resources for object-oriented programming.",
        "related_chunk_ids": [
          "librarycomputing_a2dcf360_c0011",
          "librarycomputing_a2dcf360_c0012"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "librarycomputing_a2dcf360_c0011",
          "librarycomputing_a2dcf360_c0012"
        ]
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-30T10:37:30.743Z",
    "content_format": "markdown",
    "total_chunks": 19,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}