{
  "article": {
    "id": "csharpprogramminglan_6d7f4886",
    "title": "C Sharp (programming language)",
    "url": "https://en.wikipedia.org/wiki/C_Sharp_(programming_language)",
    "lang": "en",
    "created_at": "2025-07-30T08:48:45.568018",
    "content": "---\nid: csharpprogramminglan_6d7f4886\nurl: https://en.wikipedia.org/wiki/C_Sharp_(programming_language)\ntitle: C Sharp (programming language)\nlang: en\ncreated_at: '2025-07-30T08:45:50.858171'\nchecksum: eaba65bda7fb9d8b50111a69ea2033d9aba7aae3cc720174284000a965289b6f\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 5143\n  char_count: 33450\n  num_chunks: 38\n  original_chunks: 52\n  filtered_out: 14\n  num_sections: 0\n---\nC# ( see SHARP) is a general-purpose high-level programming language supporting multiple paradigms. C# encompasses static typing, strong typing, lexically scoped, imperative, declarative, functional, generic, object-oriented (class-based), and component-oriented programming disciplines. The principal inventors of the C# programming language were Anders Hejlsberg, Scott Wiltamuth, and Peter Golde from Microsoft. It was first widely distributed in July 2000 and was later approved as an international standard by Ecma (ECMA-334) in 2002 and ISO/IEC (ISO/IEC 23270 and 20619) in 2003. Microsoft introduced C# along with .NET Framework and Microsoft Visual Studio, both of which are technically speaking, closed-source. At the time, Microsoft had no open-source products. Four years later, in 2004, a free and open-source project called Microsoft Mono began, providing a cross-platform compiler and runtime environment for the C# programming language. A decade later, Microsoft released Visual Studio Code (code editor), Roslyn (compiler), and the unified .NET platform (software framework), all of which support C# and are free, open-source, and cross-platform. Mono also joined Microsoft but was not merged into .NET. As of January 2025, the most recent stable version of the language is C# 13.0, which was released in 2024 in .NET 9.0 == Design goals == The Ecma standard lists these design goals for C#: The language is intended to be a simple, modern, general-purpose, object-oriented programming language. The language, and implementations thereof, should provide support for software engineering principles such as strong type checking, array bounds checking, detection of attempts to use uninitialized variables, and automatic garbage collection. Software robustness, durability, and programmer productivity are important. The language is intended for use in developing software components suitable for deployment in distributed environments. Portability is very important for source code and programmers, especially those already familiar with C and C++. Support for internationalization is very important. C# is intended to be suitable for writing applications for both hosted and embedded systems, ranging from the very large that use sophisticated operating systems, down to the very small having dedicated functions. Although C# applications are intended to be economical with regard to memory and processing power requirements, the language was not intended to compete directly on performance and size with C or assembly language. == History == During the development of the .NET Framework, the class libraries were originally written using a managed code compiler system named Simple Managed C (SMC). In January 1999, Anders Hejlsberg formed a team to build a new language at the time called COOL, which stood for \"C-like Object Oriented Language\". Microsoft had considered keeping the name \"COOL(C-like Object Oriented Language)\" as the final name of the language, but chose not to do so for trademark reasons. By the time the .NET project was publicly announced at the July 2000 Professional Developers Conference, the language had been renamed C#, and the class libraries and ASP.NET runtime were ported to C#. Hejlsberg was C#'s principal designer and lead architect at Microsoft, and had been previously involved with the design of Turbo Pascal, Embarcadero Delphi (formerly CodeGear Delphi, Inprise Delphi and Borland Delphi), and Visual J++. In interviews and technical papers, he has stated that flaws in most major programming languages (e.g. C++, Java, Delphi, and Smalltalk) drove the fundamentals of the Common Language Runtime (CLR), which, in turn, drove the design of the C# language. James Gosling, who created the Java programming language in 1994, and Bill Joy, a co-founder of Sun Microsystems, the originator of Java, called C# an \"imitation\" of Java; Gosling further said: \"[C# is] sort of Java with reliability, productivity and security deleted.\" In July 2000, Hejlsberg said that C# is \"not a Java clone\" and is \"much closer to C++\" in its design. Since the release of C# 2.0 in November 2005, the C# and Java languages have evolved on increasingly divergent trajectories, becoming two quite different languages. One of the first major departures came with the addition of generics to both languages, with vastly different implementations. C# uses reification to provide \"first-class\" generic objects that can be used like any other class, with code generation performed at class-load time. C# has also added several major features to accommodate functional-style programming, culminating in the LINQ extensions released with C# 3.0 and its supporting framework of lambda expressions, extension methods, and anonymous types. These features enable C# programmers to use functional programming techniques, such as closures, when it is advantageous to their application. The LINQ extensions and the functional imports help developers reduce the amount of boilerplate code included in common tasks such as querying a database, parsing an XML file, or searching through a data structure, shifting the emphasis onto the actual program logic to help improve readability and maintainability. C# used to have a mascot called Andy (named after Anders Hejlsberg). It was retired on January 29, 2004. C# was originally submitted to the ISO/IEC JTC 1 subcommittee SC 22 for review, under ISO/IEC 23270:2003, was withdrawn and was then approved under ISO/IEC 23270:2006. The 23270:2006 is withdrawn under 23270:2018 and approved with this version. === Name === Microsoft first used the name C# in 1988 for a variant of the C language designed for incremental compilation. That project was not completed, and the name was later reused. The name \"C sharp\" was inspired by the musical notation whereby a sharp symbol indicates that the written note should be made a semitone higher in pitch. This is similar to the language name of C++, where \"++\" indicates that a variable should be incremented by 1 after being evaluated. The sharp symbol also resembles a ligature of four \"+\" symbols (in a two-by-two grid), further implying that the language is an increment of C++. Due to technical limits of display (standard fonts, browsers, etc.), and most keyboard layouts lacking a sharp symbol (U+266F ♯ MUSIC SHARP SIGN (&sharp;)), the number sign (U+0023 # NUMBER SIGN (&num;)) was chosen to approximate the sharp symbol in the written name of the programming language. This convention is reflected in the ECMA-334 C# Language Specification. The \"sharp\" suffix has been used by a number of other Microsoft .NET compatible/compliant languages that are variants of existing languages, including J# (a .NET language also designed by Microsoft that is derived from Java 1.1), A# (from Ada), and the functional programming language F#. The original implementation of Eiffel for .NET was called Eiffel#, a name retired since the full Eiffel language is now supported. The suffix has also been used for libraries, such as Gtk# (a .NET wrapper for GTK and other GNOME libraries) and Cocoa# (a wrapper for Cocoa). === Versions === Development of the text for standards (beginning with C# 6) is done on GitHub. C# 7 was submitted to Ecma and approved in December 2023. As of January 2024, the standard for C# 8 is currently under development, referencing the approved language proposals. == Syntax == The core syntax of the C# language is similar to that of other C-style languages such as C, Objective-C, C++ and Java, particularly: Semicolons are used to denote the end of a statement. Curly brackets are used to group statements. Statements are commonly grouped into methods (functions), methods into classes, and classes into namespaces. Variables are assigned using an equals sign, but compared using two consecutive equals signs. Square brackets are used with arrays, both to declare them and to get a value at a given index in one of them. \"class\", \"int\" and \"void\" are used to define large-scale (usually main) program functions in scripts most of the time in C-style computer programming languages. == Distinguishing features == Some notable features of C# that distinguish it from C, C++, and Java where noted, are: === Portability === By design, C# is the programming language that most directly reflects the underlying Common Language Infrastructure (CLI). Most of its intrinsic types correspond to value-types implemented by the CLI (Common Language Infrastructure) framework. However, the language specification does not state the code generation requirements of the compiler: that is, it does not state that a C# compiler must target a Common Language Runtime (CLR), or generate Common Intermediate Language (CIL), or generate any other specific format. Some C# compilers can also generate machine code like traditional compilers of Objective-C, C, C++, Assembly and Fortran. === Typing === C# supports strongly, implicitly typed variable declarations with the keyword var, and implicitly typed arrays with the keyword new[] followed by a collection initializer. Its type system is split into two families: Value types, like the built-in numeric types and user-defined structs, which are automatically handed over as copies when used as parameters, and reference types, including arrays, instances of classes, and strings, which only hand over a pointer to the respective object. Due to their special handling of the equality operator and their immutability, strings will nevertheless behave as if they were values, for all practical purposes. You can even use them as case labels. Where necessary, value types will be boxed automatically. C# supports a strict Boolean data type, bool. Statements that take conditions, such as while and if, require an expression of a type that evaluates to the true boolean value. While C++ also has a Boolean type, it can be freely converted to and from integers, and expressions such as if (a) require only that a is convertible to bool, allowing a to be an int, or a pointer. C# disallows this \"integer meaning true or false\" approach, on the grounds that forcing programmers to use expressions that return exactly bool can prevent certain types of programming mistakes such as if (a = b) (use of assignment = instead of equality ==). C# is more type safe than C++. The only implicit conversions by default are those that are considered safe, such as widening of integers. This is enforced at compile-time, during JIT, and, in some cases, at runtime. No implicit conversions occur between Booleans and integers, nor between enumeration members and integers (except for literal 0, which can be implicitly converted to any enumerated type). Any user-defined conversion must be explicitly marked as explicit or implicit, unlike C++ copy constructors and conversion operators, which are both implicit by default. C# has explicit support for covariance and contravariance in generic types, unlike C++ which has some degree of support for contravariance simply through the semantics of return types on virtual methods. Enumeration members are placed in their own scope. The C# language does not allow for global variables or functions. All methods and members must be declared within classes. Static members of public classes can substitute for global variables and functions. Local variables cannot shadow variables of the enclosing block, unlike C and C++, but may shadow type-level names. === Metaprogramming === Metaprogramming can be achieved in several ways: Reflection is supported through .NET APIs, which enable scenarios such as type metadata inspection and dynamic method invocation. Expression trees represent code as an abstract syntax tree, where each node is an expression that can be inspected or executed. This enables dynamic modification of executable code at runtime. Expression trees introduce some homoiconicity to the language. Attributes, in C# parlance, are metadata that can be attached to types, members, or entire assemblies, equivalent to annotations in Java. Attributes are accessible both to the compiler and to code through reflection, allowing them to adjust their behaviour. Many of the native attributes duplicate the functionality of GCC's and VisualC++'s platform-dependent preprocessor directives. System.Reflection.Emit namespace, which contains classes that emit metadata and CIL (types, assemblies, etc.) at runtime. The .NET Compiler Platform (Roslyn) provides API access to language compilation services, allowing for the compilation of C# code from within .NET applications. It exposes APIs for syntactic (lexical) analysis of code, semantic analysis, dynamic compilation to CIL, and code emission. Source generators, a feature of the Roslyn C# compiler, enable compile time metaprogramming. During the compilation process, developers can inspect the code being compiled with the compiler's API and pass additional generated C# source code to be compiled. === Methods and functions === A method in C# is a member of a class that can be invoked as a function (a sequence of instructions), rather than the mere value-holding capability of a field (i.e. class or instance variable). As in other syntactically similar languages, such as C++ and ANSI C, the signature of a method is a declaration comprising in order: any optional accessibility keywords (such as private), the explicit specification of its return type (such as int, or the keyword void if no value is returned), the name of the method, and finally, a parenthesized sequence of comma-separated parameter specifications, each consisting of a parameter's type, its formal name and optionally, a default value to be used whenever none is provided. Different from most other languages, call-by-reference parameters have to be marked both at the function definition and at the calling site, and you can choose between ref and out, the latter allowing handing over an uninitialized variable which will have a definite value on return. Additionally, you can specify a variable-sized argument list by applying the params keyword to the last parameter. Certain specific kinds of methods, such as those that simply get or set a field's value by returning or assigning it, do not require an explicitly stated full signature, but in the general case, the definition of a class includes the full signature declaration of its methods. Like C++, and unlike Java, C# programmers must use the scope modifier keyword virtual to allow methods to be overridden by subclasses. Unlike C++, you have to explicitly specify the keyword override when doing so. This is supposed to avoid confusion between overriding and newly overloading a function (i.e. hiding the former implementation). To do the latter, you have to specify the new keyword. You can use the keyword sealed to disallow further overrides for individual methods or whole classes. Extension methods in C# allow programmers to use static methods as if they were methods from a class's method table, allowing programmers to virtually add instance methods to a class that they feel should exist on that kind of objects (and instances of the respective derived classes). The type dynamic allows for run-time method binding, allowing for JavaScript-like method calls and run-time object composition. C# has support for strongly-typed function pointers via the keyword delegate. Like the Qt framework's pseudo-C++ signal and slot, C# has semantics specifically surrounding publish-subscribe style events, though C# uses delegates to do so. Unlike fields, event variables can be part of an interface, because they technically consist of two default functions to add and remove to-be-called delegates. C# offers Java-like synchronized method calls, via the attribute [MethodImpl(MethodImplOptions.Synchronized)], and has support for mutually-exclusive locks via the keyword lock. === Properties === C# supports classes with properties. The properties can be simple accessor functions with a backing field, or implement arbitrary getter and setter functions. A property is read-only if there's no setter. Like with fields, there can be class and instance properties. The underlying methods can be virtual or abstract like any other method. Since C# 3.0 the syntactic sugar of auto-implemented properties is available, where the accessor (getter) and mutator (setter) encapsulate operations on a single field of a class. === Namespaces === A C# namespace provides the same level of code isolation as a Java package or a C++ namespace, with rules and features very similar to a package. Namespaces can be imported with the \"using\" syntax. === Memory access === In C#, memory address pointers can only be used within blocks specifically marked as unsafe, and programs with unsafe code need appropriate permissions to run. Most object access is done through safe object references, which always either point to a \"live\" object or have the well-defined null value; it is impossible to obtain a reference to a \"dead\" object (one that has been garbage collected), or to an arbitrary block of memory. An unsafe pointer can point to an instance of an unmanaged value type that does not contain any references to objects subject to garbage collections such as class instances, arrays or strings. Code that is not marked as unsafe can still store and manipulate pointers through the System.IntPtr type, but it cannot dereference them. Managed memory cannot be explicitly freed; instead, it is automatically garbage collected. Garbage collection addresses the problem of memory leaks by freeing the programmer of responsibility for releasing memory that is no longer needed in most cases. Code that retains references to objects longer than is required can still experience higher memory usage than necessary, however once the final reference to an object is released the memory is available for garbage collection. === Exceptions === A range of standard exceptions are available to programmers. Methods in standard libraries regularly throw system exceptions in some circumstances and the range of exceptions thrown is normally documented. Custom exception classes can be defined for classes allowing handling to be put in place for particular circumstances as needed. The syntax for handling exceptions is the following:Most of the time people call this a \"try-catch\" code block, because of the \"try\" and \"catch\" functions being used and accessible on all C# versions.Depending on your plans, the \"finally\" part can be left out. If inspecting the error details is not required, the (Exception ex) parameter can be omitted as well. Also, there can be several \"catch\" parts handling different kinds of exceptions. Checked exceptions are not present in C# (in contrast to Java). This has been a conscious decision based on the issues of scalability and version management. === Polymorphism === Unlike C++, C# does not support multiple inheritance, although a class can implement any number of \"interfaces\" (fully abstract classes). This was a design decision by the language's lead architect to avoid complications and to simplify architectural requirements throughout CLI. When implementing multiple interfaces that contain a method with the same name and taking parameters of the same types in the same order (i.e. the same signature), similar to Java, C# allows both a single method to cover all interfaces and if necessary specific methods for each interface. C# also offers function overloading (a.k.a. ad-hoc-polymorphism), i.e. methods with the same name, but distinguishable signatures. Unlike Java, C# additionally supports operator overloading. Since version 2.0, C# offers parametric polymorphism, i.e. classes with arbitrary or constrained type parameters, e.g. List , a variable-sized array which only can contain elements of type T. There are certain kinds of constraints you can specify for the type parameters: Has to be type X (or one derived from it), has to implement a certain interface, has to be a reference type, has to be a value type, has to implement a public parameterless constructor. Most of them can be combined, and you can specify any number of interfaces. === Language Integrated Query (LINQ) === C# has the ability to utilize LINQ through the .NET Framework. A developer can query a variety of data sources, provided the IEnumerable interface is implemented on the object. This includes XML documents, an ADO.NET dataset, and SQL databases. Using LINQ in C# brings advantages like IntelliSense support, strong filtering capabilities, type safety with compile error checking ability, and consistency for querying data over a variety of sources. There are several different language structures that can be utilized with C# and LINQ and they are query expressions, lambda expressions, anonymous types, implicitly typed variables, extension methods, and object initializers. LINQ has two syntaxes: query syntax and method syntax. However, the compiler always converts the query syntax to method syntax at compile time. === Functional programming === Though primarily an imperative language, C# always adds functional features over time, for example: Functions as first-class citizen – C# 1.0 delegates Higher-order functions – C# 1.0 together with delegates Anonymous functions – C# 2 anonymous delegates and C# 3 lambdas expressions Closures – C# 2 together with anonymous delegates and C# 3 together with lambdas expressions Type inference – C# 3 with implicitly typed local variables var and C# 9 target-typed new expressions new() List comprehension – C# 3 LINQ Tuples – .NET Framework 4.0 but it becomes popular when C# 7.0 introduced a new tuple type with language support Nested functions – C# 7.0 Pattern matching – C# 7.0 Immutability – C# 7.2 readonly struct C# 9 record types and Init only setters Type classes – C# 12 roles/extensions (in development) == Common type system == C# has a unified type system. This unified type system is called Common Type System (CTS). A unified type system implies that all types, including primitives such as integers, are subclasses of the System.Object class. For example, every type inherits a ToString() method. === Categories of data types === CTS separates data types into two categories: Reference types Value types Instances of value types neither have referential identity nor referential comparison semantics. Equality and inequality comparisons for value types compare the actual data values within the instances, unless the corresponding operators are overloaded. Value types are derived from System.ValueType, always have a default value, and can always be created and copied. Some other limitations on value types are that they cannot derive from each other (but can implement interfaces) and cannot have an explicit default (parameterless) constructor because they already have an implicit one which initializes all contained data to the type-dependent default value (0, null, or alike). Examples of value types are all primitive types, such as int (a signed 32-bit integer), float (a 32-bit IEEE floating-point number), char (a 16-bit Unicode code unit), decimal (fixed-point numbers useful for handling currency amounts), and System.DateTime (identifies a specific point in time with nanosecond precision). Other examples are enum (enumerations) and struct (user defined structures). In contrast, reference types have the notion of referential identity, meaning that each instance of a reference type is inherently distinct from every other instance, even if the data within both instances is the same. This is reflected in default equality and inequality comparisons for reference types, which test for referential rather than structural equality, unless the corresponding operators are overloaded (such as the case for System.String). Some operations are not always possible, such as creating an instance of a reference type, copying an existing instance, or performing a value comparison on two existing instances. Nevertheless, specific reference types can provide such services by exposing a public constructor or implementing a corresponding interface (such as ICloneable or IComparable). Examples of reference types are object (the ultimate base class for all other C# classes), System.String (a string of Unicode characters), and System.Array (a base class for all C# arrays). Both type categories are extensible with user-defined types. === Boxing and unboxing === Boxing is the operation of converting a value-type object into a value of a corresponding reference type. Boxing in C# is implicit. Unboxing is the operation of converting a value of a reference type (previously boxed) into a value of a value type. Unboxing in C# requires an explicit type cast. A boxed object of type T can only be unboxed to a T (or a nullable T). Example: == Libraries == The C# specification details a minimum set of types and class libraries that the compiler expects to have available. In practice, C# is most often used with some implementation of the Common Language Infrastructure (CLI), which is standardized as ECMA-335 Common Language Infrastructure (CLI). In addition to the standard CLI specifications, there are many commercial and community class libraries that build on top of the .NET framework libraries to provide additional functionality. C# can make calls to any library included in the List of .NET libraries and frameworks. == Examples == === Hello World === The following is a very simple C# program, a version of the classic \"Hello world\" example using the top-level statements feature introduced in C# 9: For code written as C# 8 or lower, the entry point logic of a program must be written in a Main method inside a type: This code will display this text in the console window: Hello, world! Each line has a purpose: The above line imports all types in the System namespace. For example, the Console class used later in the source code is defined in the System namespace, meaning it can be used without supplying the full name of the type (which includes the namespace). This line is a comment; it describes and documents the code for the programmer(s). Above is a class definition for the Program class. Everything that follows between the pair of braces describes that class.The curly brackets demarcate the boundaries of a code block. In this first instance, they are marking the start and end of the Program class. This declares the class member method where the program begins execution. The .NET runtime calls the Main method. Unlike in Java, the Main method does not need the public keyword, which tells the compiler that the method can be called from anywhere by any class. Writing static void Main(string[] args) is equivalent to writing private static void Main(string[] args). The static keyword makes the method accessible without an instance of Program. Each console application's Main entry point must be declared static otherwise the program would require an instance of Program, but any instance would require a program. To avoid that irresolvable circular dependency, C# compilers processing console applications (like that above) report an error if there is no static Main method. The void keyword declares that Main has no return value. (Note, however, that short programs can be written using Top Level Statements introduced in C# 9, as mentioned earlier.) This line writes the output. Console is a static class in the System namespace. It provides an interface to the standard input/output, and error streams for console applications. The program calls the Console method WriteLine, which displays on the console a line with the argument, the string \"Hello, world!\". === Generics === With .NET 2.0 and C# 2.0, the community got more flexible collections than those in .NET 1.x. In the absence of generics, developers had to use collections such as ArrayList to store elements as objects of unspecified kind, which incurred performance overhead when boxing/unboxing/type-checking the contained items. Generics introduced a massive new feature in .NET that allowed developers to create type-safe data structures. This shift is particularly important in the context of converting legacy systems, where updating to generics can significantly enhance performance and maintainability by replacing outdated data structures with more efficient, type-safe alternatives. Example == Standardization and licensing == In August 2001, Microsoft, Hewlett-Packard and Intel co-sponsored the submission of specifications for C# as well as the Common Language Infrastructure (CLI) to the standards organization Ecma International. In December 2001, ECMA released ECMA-334 C# Language Specification. C# became an ISO/IEC standard in 2003 (ISO/IEC 23270:2003 - Information technology — Programming languages — C#). ECMA had previously adopted equivalent specifications as the 2nd edition of C#, in December 2002. In June 2005, ECMA approved edition 3 of the C# specification, and updated ECMA-334. Additions included partial classes, anonymous methods, nullable types, and generics (somewhat similar to C++ templates). In July 2005, ECMA submitted to ISO/IEC JTC 1/SC 22, via the latter's Fast-Track process, the standards and related TRs. This process usually takes 6–9 months. The C# language definition and the CLI are standardized under ISO/IEC and Ecma standards that provide reasonable and non-discriminatory licensing protection from patent claims. Microsoft initially agreed not to sue open-source developers for violating patents in non-profit projects for the part of the framework that is covered by the Open Specification Promise. Microsoft has also agreed not to enforce patents relating to Novell products against Novell's paying customers with the exception of a list of products that do not explicitly mention C#, .NET or Novell's implementation of .NET (The Mono Project). However, Novell maintained that Mono does not infringe any Microsoft patents. Microsoft also made a specific agreement not to enforce patent rights related to the Moonlight browser plugin, which depends on Mono, provided it is obtained through Novell. A decade later, Microsoft began developing free, open-source, and cross-platform tooling for C#, namely Visual Studio Code, .NET Core, and Roslyn. Mono joined Microsoft as a project of Xamarin, a Microsoft subsidiary. == Implementations == Microsoft has developed open-source reference C# compilers and tools. The first compiler, Roslyn, compiles into intermediate language (IL), and the second one, RyuJIT, is a JIT (just-in-time) compiler, which is dynamic and does on-the-fly optimization and compiles the IL into native code for the front-end of the CPU. RyuJIT is open source and written in C++. Roslyn is entirely written in managed code (C#), has been opened up and functionality surfaced as APIs. It is thus enabling developers to create refactoring and diagnostics tools. Two branches of official implementation are .NET Framework (closed-source, Windows-only) and .NET Core (open-source, cross-platform); they eventually converged into one open-source implementation: .NET 5.0. At .NET Framework 4.6, a new JIT compiler replaced the former. Other C# compilers (some of which include an implementation of the Common Language Infrastructure and .NET class libraries): Mono, a Microsoft-sponsored project provides an open-source C# compiler, a complete open-source implementation of the CLI (including the required framework libraries as they appear in the ECMA specification,) and a nearly complete implementation of the NET class libraries up to .NET Framework 3.5. The Elements tool chain from RemObjects includes RemObjects C#, which compiles C# code to .NET's Common Intermediate Language, Java bytecode, Cocoa, Android bytecode, WebAssembly, and native machine code for Windows, macOS, and Linux. The DotGNU project (now discontinued) also provided an open-source C# compiler, a nearly complete implementation of the Common Language Infrastructure including the required framework libraries as they appear in the ECMA specification, and subset of some of the remaining Microsoft proprietary .NET class libraries up to .NET 2.0 (those not documented or included in the ECMA specification, but included in Microsoft's standard .NET Framework distribution). The Unity game engine uses C# as its primary scripting language. The Godot game engine has implemented an optional C# module due to a donation of $24,000 from Microsoft. == See also == == Notes == == References == === Citations === === Sources === Albahari, Joseph (2022). C# 10 in a Nutshell (First ed.). O'Reilly. ISBN 978-1-098-12195-2. Archer, Tom (2001). \"Part 2, Chapter 4: The Type System\". Inside C#. Redmond, Washington: Microsoft Press. ISBN 0-7356-1288-9. Novák, István; Velvart, Andras; Granicz, Adam; Balássy, György; Hajdrik, Attila; Sellers, Mitchel; Hillar, Gastón C.; Molnár, Ágnes; Kanjilal, Joydip (2010). Visual Studio 2010 and .NET 4 Six-in-One. Wrox Press. ISBN 978-0470499481. Skeet, Jon (2019). C# in Depth (Fourth ed.). Manning. ISBN 978-1617294532. == Further reading == Drayton, Peter; Albahari, Ben; Neward, Ted (2002). C# Language Pocket Reference. O'Reilly. ISBN 0-596-00429-X. Petzold, Charles (2002). Programming Microsoft Windows with C#. Microsoft Press. ISBN 0-7356-1370-2. == External links == C# Language Specification C# Programming Guide ISO C# Language Specification C# Compiler Platform (\"Roslyn\") source code"
  },
  "chunks": [
    {
      "id": "csharpprogramminglan_6d7f4886_c0000",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 952,
      "content": "C# ( see SHARP) is a general-purpose high-level programming language supporting multiple paradigms. C# encompasses static typing, strong typing, lexically scoped, imperative, declarative, functional, generic, object-oriented (class-based), and component-oriented programming disciplines. The principal inventors of the C# programming language were Anders Hejlsberg, Scott Wiltamuth, and Peter Golde from Microsoft. It was first widely distributed in July 2000 and was later approved as an international standard by Ecma (ECMA-334) in 2002 and ISO/IEC (ISO/IEC 23270 and 20619) in 2003. Microsoft introduced C# along with .NET Framework and Microsoft Visual Studio, both of which are technically speaking, closed-source. At the time, Microsoft had no open-source products. Four years later, in 2004, a free and open-source project called Microsoft Mono began, providing a cross-platform compiler and runtime environment for the C# programming language.",
      "char_count": 951,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0001",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 952,
      "end_char": 1337,
      "content": "A decade later, Microsoft released Visual Studio Code (code editor), Roslyn (compiler), and the unified .NET platform (software framework), all of which support C# and are free, open-source, and cross-platform. Mono also joined Microsoft but was not merged into .NET. As of January 2025, the most recent stable version of the language is C# 13.0, which was released in 2024 in .NET 9.0",
      "char_count": 385,
      "token_estimate": 96,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0002",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== Design goals ==",
      "heading_path": "== Design goals ==",
      "start_char": 1356,
      "end_char": 2134,
      "content": "== Design goals == The Ecma standard lists these design goals for C#: The language is intended to be a simple, modern, general-purpose, object-oriented programming language. The language, and implementations thereof, should provide support for software engineering principles such as strong type checking, array bounds checking, detection of attempts to use uninitialized variables, and automatic garbage collection. Software robustness, durability, and programmer productivity are important. The language is intended for use in developing software components suitable for deployment in distributed environments. Portability is very important for source code and programmers, especially those already familiar with C and C++. Support for internationalization is very important.",
      "char_count": 777,
      "token_estimate": 194,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0003",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== Design goals ==",
      "heading_path": "== Design goals ==",
      "start_char": 2134,
      "end_char": 2562,
      "content": "C# is intended to be suitable for writing applications for both hosted and embedded systems, ranging from the very large that use sophisticated operating systems, down to the very small having dedicated functions. Although C# applications are intended to be economical with regard to memory and processing power requirements, the language was not intended to compete directly on performance and size with C or assembly language.",
      "char_count": 428,
      "token_estimate": 107,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0004",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 2558,
      "end_char": 3477,
      "content": "== History == During the development of the .NET Framework, the class libraries were originally written using a managed code compiler system named Simple Managed C (SMC). In January 1999, Anders Hejlsberg formed a team to build a new language at the time called COOL, which stood for \"C-like Object Oriented Language\". Microsoft had considered keeping the name \"COOL(C-like Object Oriented Language)\" as the final name of the language, but chose not to do so for trademark reasons. By the time the .NET project was publicly announced at the July 2000 Professional Developers Conference, the language had been renamed C#, and the class libraries and ASP.NET runtime were ported to C#. Hejlsberg was C#'s principal designer and lead architect at Microsoft, and had been previously involved with the design of Turbo Pascal, Embarcadero Delphi (formerly CodeGear Delphi, Inprise Delphi and Borland Delphi), and Visual J++.",
      "char_count": 918,
      "token_estimate": 229,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0005",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 3477,
      "end_char": 4391,
      "content": "In interviews and technical papers, he has stated that flaws in most major programming languages (e.g. C++, Java, Delphi, and Smalltalk) drove the fundamentals of the Common Language Runtime (CLR), which, in turn, drove the design of the C# language. James Gosling, who created the Java programming language in 1994, and Bill Joy, a co-founder of Sun Microsystems, the originator of Java, called C# an \"imitation\" of Java; Gosling further said: \"[C# is] sort of Java with reliability, productivity and security deleted.\" In July 2000, Hejlsberg said that C# is \"not a Java clone\" and is \"much closer to C++\" in its design. Since the release of C# 2.0 in November 2005, the C# and Java languages have evolved on increasingly divergent trajectories, becoming two quite different languages. One of the first major departures came with the addition of generics to both languages, with vastly different implementations.",
      "char_count": 914,
      "token_estimate": 228,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0006",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 4392,
      "end_char": 5340,
      "content": "C# uses reification to provide \"first-class\" generic objects that can be used like any other class, with code generation performed at class-load time. C# has also added several major features to accommodate functional-style programming, culminating in the LINQ extensions released with C# 3.0 and its supporting framework of lambda expressions, extension methods, and anonymous types. These features enable C# programmers to use functional programming techniques, such as closures, when it is advantageous to their application. The LINQ extensions and the functional imports help developers reduce the amount of boilerplate code included in common tasks such as querying a database, parsing an XML file, or searching through a data structure, shifting the emphasis onto the actual program logic to help improve readability and maintainability. C# used to have a mascot called Andy (named after Anders Hejlsberg). It was retired on January 29, 2004.",
      "char_count": 948,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0007",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 5341,
      "end_char": 5585,
      "content": "C# was originally submitted to the ISO/IEC JTC 1 subcommittee SC 22 for review, under ISO/IEC 23270:2003, was withdrawn and was then approved under ISO/IEC 23270:2006. The 23270:2006 is withdrawn under 23270:2018 and approved with this version.",
      "char_count": 244,
      "token_estimate": 61,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0008",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = Name ==",
      "heading_path": "== = Name ==",
      "start_char": 5585,
      "end_char": 6501,
      "content": "== = Name === Microsoft first used the name C# in 1988 for a variant of the C language designed for incremental compilation. That project was not completed, and the name was later reused. The name \"C sharp\" was inspired by the musical notation whereby a sharp symbol indicates that the written note should be made a semitone higher in pitch. This is similar to the language name of C++, where \"++\" indicates that a variable should be incremented by 1 after being evaluated. The sharp symbol also resembles a ligature of four \"+\" symbols (in a two-by-two grid), further implying that the language is an increment of C++. Due to technical limits of display (standard fonts, browsers, etc.), and most keyboard layouts lacking a sharp symbol (U+266F ♯ MUSIC SHARP SIGN (&sharp;)), the number sign (U+0023 # NUMBER SIGN (&num;)) was chosen to approximate the sharp symbol in the written name of the programming language.",
      "char_count": 915,
      "token_estimate": 228,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0009",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = Name ==",
      "heading_path": "== = Name ==",
      "start_char": 6501,
      "end_char": 7135,
      "content": "This convention is reflected in the ECMA-334 C# Language Specification. The \"sharp\" suffix has been used by a number of other Microsoft .NET compatible/compliant languages that are variants of existing languages, including J# (a .NET language also designed by Microsoft that is derived from Java 1.1), A# (from Ada), and the functional programming language F#. The original implementation of Eiffel for .NET was called Eiffel#, a name retired since the full Eiffel language is now supported. The suffix has also been used for libraries, such as Gtk# (a .NET wrapper for GTK and other GNOME libraries) and Cocoa# (a wrapper for Cocoa).",
      "char_count": 634,
      "token_estimate": 158,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0010",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = Versions ==",
      "heading_path": "== = Versions ==",
      "start_char": 7140,
      "end_char": 7398,
      "content": "== = Versions === Development of the text for standards (beginning with C# 6) is done on GitHub. C# 7 was submitted to Ecma and approved in December 2023. As of January 2024, the standard for C# 8 is currently under development, referencing the approved language proposals.",
      "char_count": 273,
      "token_estimate": 68,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0011",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== Syntax ==",
      "heading_path": "== Syntax ==",
      "start_char": 7410,
      "end_char": 8118,
      "content": "== Syntax == The core syntax of the C# language is similar to that of other C-style languages such as C, Objective-C, C++ and Java, particularly: Semicolons are used to denote the end of a statement. Curly brackets are used to group statements. Statements are commonly grouped into methods (functions), methods into classes, and classes into namespaces. Variables are assigned using an equals sign, but compared using two consecutive equals signs. Square brackets are used with arrays, both to declare them and to get a value at a given index in one of them. \"class\", \"int\" and \"void\" are used to define large-scale (usually main) program functions in scripts most of the time in C-style computer programming languages.",
      "char_count": 719,
      "token_estimate": 179,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0012",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = Portability ==",
      "heading_path": "== = Portability ==",
      "start_char": 8255,
      "end_char": 8902,
      "content": "== = Portability === By design, C# is the programming language that most directly reflects the underlying Common Language Infrastructure (CLI). Most of its intrinsic types correspond to value-types implemented by the CLI (Common Language Infrastructure) framework. However, the language specification does not state the code generation requirements of the compiler: that is, it does not state that a C# compiler must target a Common Language Runtime (CLR), or generate Common Intermediate Language (CIL), or generate any other specific format. Some C# compilers can also generate machine code like traditional compilers of Objective-C, C, C++, Assembly and Fortran.",
      "char_count": 665,
      "token_estimate": 166,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0013",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = Typing ==",
      "heading_path": "== = Typing ==",
      "start_char": 8916,
      "end_char": 9856,
      "content": "== = Typing === C# supports strongly, implicitly typed variable declarations with the keyword var, and implicitly typed arrays with the keyword new[] followed by a collection initializer. Its type system is split into two families: Value types, like the built-in numeric types and user-defined structs, which are automatically handed over as copies when used as parameters, and reference types, including arrays, instances of classes, and strings, which only hand over a pointer to the respective object. Due to their special handling of the equality operator and their immutability, strings will nevertheless behave as if they were values, for all practical purposes. You can even use them as case labels. Where necessary, value types will be boxed automatically. C# supports a strict Boolean data type, bool. Statements that take conditions, such as while and if, require an expression of a type that evaluates to the true boolean value.",
      "char_count": 939,
      "token_estimate": 234,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0014",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = Typing ==",
      "heading_path": "== = Typing ==",
      "start_char": 9856,
      "end_char": 10307,
      "content": "While C++ also has a Boolean type, it can be freely converted to and from integers, and expressions such as if (a) require only that a is convertible to bool, allowing a to be an int, or a pointer. C# disallows this \"integer meaning true or false\" approach, on the grounds that forcing programmers to use expressions that return exactly bool can prevent certain types of programming mistakes such as if (a = b) (use of assignment = instead of equality",
      "char_count": 451,
      "token_estimate": 112,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0015",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== ). C# is more type safe than C++. The only implicit conversions by default are those that are considered safe, such as widening of integers. This is enforced at compile-time, during JIT, and, in some cases, at runtime. No implicit conversions occur between Booleans and integers, nor between enumeration members and integers (except for literal 0, which can be implicitly converted to any enumerated type). Any user-defined conversion must be explicitly marked as explicit or implicit, unlike C++ copy constructors and conversion operators, which are both implicit by default. C# has explicit support for covariance and contravariance in generic types, unlike C++ which has some degree of support for contravariance simply through the semantics of return types on virtual methods. Enumeration members are placed in their own scope. The C# language does not allow for global variables or functions. All methods and members must be declared within classes. Static members of public classes can substitute for global variables and functions. Local variables cannot shadow variables of the enclosing block, unlike C and C++, but may shadow type-level names. ==",
      "heading_path": "== ). C# is more type safe than C++. The only implicit conversions by default are those that are considered safe, such as widening of integers. This is enforced at compile-time, during JIT, and, in some cases, at runtime. No implicit conversions occur between Booleans and integers, nor between enumeration members and integers (except for literal 0, which can be implicitly converted to any enumerated type). Any user-defined conversion must be explicitly marked as explicit or implicit, unlike C++ copy constructors and conversion operators, which are both implicit by default. C# has explicit support for covariance and contravariance in generic types, unlike C++ which has some degree of support for contravariance simply through the semantics of return types on virtual methods. Enumeration members are placed in their own scope. The C# language does not allow for global variables or functions. All methods and members must be declared within classes. Static members of public classes can substitute for global variables and functions. Local variables cannot shadow variables of the enclosing block, unlike C and C++, but may shadow type-level names. ==",
      "start_char": 11453,
      "end_char": 12411,
      "content": "== ). C# is more type safe than C++. The only implicit conversions by default are those that are considered safe, such as widening of integers. This is enforced at compile-time, during JIT, and, in some cases, at runtime. No implicit conversions occur between Booleans and integers, nor between enumeration members and integers (except for literal 0, which can be implicitly converted to any enumerated type). Any user-defined conversion must be explicitly marked as explicit or implicit, unlike C++ copy constructors and conversion operators, which are both implicit by default. C# has explicit support for covariance and contravariance in generic types, unlike C++ which has some degree of support for contravariance simply through the semantics of return types on virtual methods. Enumeration members are placed in their own scope. The C# language does not allow for global variables or functions. All methods and members must be declared within classes.",
      "char_count": 957,
      "token_estimate": 239,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0016",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== ). C# is more type safe than C++. The only implicit conversions by default are those that are considered safe, such as widening of integers. This is enforced at compile-time, during JIT, and, in some cases, at runtime. No implicit conversions occur between Booleans and integers, nor between enumeration members and integers (except for literal 0, which can be implicitly converted to any enumerated type). Any user-defined conversion must be explicitly marked as explicit or implicit, unlike C++ copy constructors and conversion operators, which are both implicit by default. C# has explicit support for covariance and contravariance in generic types, unlike C++ which has some degree of support for contravariance simply through the semantics of return types on virtual methods. Enumeration members are placed in their own scope. The C# language does not allow for global variables or functions. All methods and members must be declared within classes. Static members of public classes can substitute for global variables and functions. Local variables cannot shadow variables of the enclosing block, unlike C and C++, but may shadow type-level names. ==",
      "heading_path": "== ). C# is more type safe than C++. The only implicit conversions by default are those that are considered safe, such as widening of integers. This is enforced at compile-time, during JIT, and, in some cases, at runtime. No implicit conversions occur between Booleans and integers, nor between enumeration members and integers (except for literal 0, which can be implicitly converted to any enumerated type). Any user-defined conversion must be explicitly marked as explicit or implicit, unlike C++ copy constructors and conversion operators, which are both implicit by default. C# has explicit support for covariance and contravariance in generic types, unlike C++ which has some degree of support for contravariance simply through the semantics of return types on virtual methods. Enumeration members are placed in their own scope. The C# language does not allow for global variables or functions. All methods and members must be declared within classes. Static members of public classes can substitute for global variables and functions. Local variables cannot shadow variables of the enclosing block, unlike C and C++, but may shadow type-level names. ==",
      "start_char": 12411,
      "end_char": 12629,
      "content": "Static members of public classes can substitute for global variables and functions. Local variables cannot shadow variables of the enclosing block, unlike C and C++, but may shadow type-level names. === Metaprogramming",
      "char_count": 218,
      "token_estimate": 54,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0017",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = C# supports classes with properties. The properties can be simple accessor functions with a backing field, or implement arbitrary getter and setter functions. A property is read-only if there's no setter. Like with fields, there can be class and instance properties. The underlying methods can be virtual or abstract like any other method. Since C# 3.0 the syntactic sugar of auto-implemented properties is available, where the accessor (getter) and mutator (setter) encapsulate operations on a single field of a class. ==",
      "heading_path": "== = C# supports classes with properties. The properties can be simple accessor functions with a backing field, or implement arbitrary getter and setter functions. A property is read-only if there's no setter. Like with fields, there can be class and instance properties. The underlying methods can be virtual or abstract like any other method. Since C# 3.0 the syntactic sugar of auto-implemented properties is available, where the accessor (getter) and mutator (setter) encapsulate operations on a single field of a class. ==",
      "start_char": 16420,
      "end_char": 16433,
      "content": "== = C# supports classes with properties. The properties can be simple accessor functions with a backing field, or implement arbitrary getter and setter functions. A property is read-only if there's no setter. Like with fields, there can be class and instance properties. The underlying methods can be virtual or abstract like any other method. Since C# 3.0 the syntactic sugar of auto-implemented properties is available, where the accessor (getter) and mutator (setter) encapsulate operations on a single field of a class. === Namespaces",
      "char_count": 539,
      "token_estimate": 134,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0018",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = A C# namespace provides the same level of code isolation as a Java package or a C++ namespace, with rules and features very similar to a package. Namespaces can be imported with the \"using\" syntax. ==",
      "heading_path": "== = A C# namespace provides the same level of code isolation as a Java package or a C++ namespace, with rules and features very similar to a package. Namespaces can be imported with the \"using\" syntax. ==",
      "start_char": 16638,
      "end_char": 16654,
      "content": "== = A C# namespace provides the same level of code isolation as a Java package or a C++ namespace, with rules and features very similar to a package. Namespaces can be imported with the \"using\" syntax. === Memory access",
      "char_count": 220,
      "token_estimate": 55,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0019",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = A range of standard exceptions are available to programmers. Methods in standard libraries regularly throw system exceptions in some circumstances and the range of exceptions thrown is normally documented. Custom exception classes can be defined for classes allowing handling to be put in place for particular circumstances as needed. The syntax for handling exceptions is the following:Most of the time people call this a \"try-catch\" code block, because of the \"try\" and \"catch\" functions being used and accessible on all C# versions.Depending on your plans, the \"finally\" part can be left out. If inspecting the error details is not required, the (Exception ex) parameter can be omitted as well. Also, there can be several \"catch\" parts handling different kinds of exceptions. Checked exceptions are not present in C# (in contrast to Java). This has been a conscious decision based on the issues of scalability and version management. ==",
      "heading_path": "== = A range of standard exceptions are available to programmers. Methods in standard libraries regularly throw system exceptions in some circumstances and the range of exceptions thrown is normally documented. Custom exception classes can be defined for classes allowing handling to be put in place for particular circumstances as needed. The syntax for handling exceptions is the following:Most of the time people call this a \"try-catch\" code block, because of the \"try\" and \"catch\" functions being used and accessible on all C# versions.Depending on your plans, the \"finally\" part can be left out. If inspecting the error details is not required, the (Exception ex) parameter can be omitted as well. Also, there can be several \"catch\" parts handling different kinds of exceptions. Checked exceptions are not present in C# (in contrast to Java). This has been a conscious decision based on the issues of scalability and version management. ==",
      "start_char": 18863,
      "end_char": 18878,
      "content": "== = A range of standard exceptions are available to programmers. Methods in standard libraries regularly throw system exceptions in some circumstances and the range of exceptions thrown is normally documented. Custom exception classes can be defined for classes allowing handling to be put in place for particular circumstances as needed. The syntax for handling exceptions is the following:Most of the time people call this a \"try-catch\" code block, because of the \"try\" and \"catch\" functions being used and accessible on all C# versions.Depending on your plans, the \"finally\" part can be left out. If inspecting the error details is not required, the (Exception ex) parameter can be omitted as well. Also, there can be several \"catch\" parts handling different kinds of exceptions. Checked exceptions are not present in C# (in contrast to Java). This has been a conscious decision based on the issues of scalability and version management. === Polymorphism",
      "char_count": 958,
      "token_estimate": 239,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0020",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = Though primarily an imperative language, C# always adds functional features over time, for example: Functions as first-class citizen – C# 1.0 delegates Higher-order functions – C# 1.0 together with delegates Anonymous functions – C# 2 anonymous delegates and C# 3 lambdas expressions Closures – C# 2 together with anonymous delegates and C# 3 together with lambdas expressions Type inference – C# 3 with implicitly typed local variables var and C# 9 target-typed new expressions new() List comprehension – C# 3 LINQ Tuples – .NET Framework 4.0 but it becomes popular when C# 7.0 introduced a new tuple type with language support Nested functions – C# 7.0 Pattern matching – C# 7.0 Immutability – C# 7.2 readonly struct C# 9 record types and Init only setters Type classes – C# 12 roles/extensions (in development) ==",
      "heading_path": "== = Though primarily an imperative language, C# always adds functional features over time, for example: Functions as first-class citizen – C# 1.0 delegates Higher-order functions – C# 1.0 together with delegates Anonymous functions – C# 2 anonymous delegates and C# 3 lambdas expressions Closures – C# 2 together with anonymous delegates and C# 3 together with lambdas expressions Type inference – C# 3 with implicitly typed local variables var and C# 9 target-typed new expressions new() List comprehension – C# 3 LINQ Tuples – .NET Framework 4.0 but it becomes popular when C# 7.0 introduced a new tuple type with language support Nested functions – C# 7.0 Pattern matching – C# 7.0 Immutability – C# 7.2 readonly struct C# 9 record types and Init only setters Type classes – C# 12 roles/extensions (in development) ==",
      "start_char": 21887,
      "end_char": 21907,
      "content": "== = Though primarily an imperative language, C# always adds functional features over time, for example: Functions as first-class citizen – C# 1.0 delegates Higher-order functions – C# 1.0 together with delegates Anonymous functions – C# 2 anonymous delegates and C# 3 lambdas expressions Closures – C# 2 together with anonymous delegates and C# 3 together with lambdas expressions Type inference – C# 3 with implicitly typed local variables var and C# 9 target-typed new expressions new() List comprehension – C# 3 LINQ Tuples – .NET Framework 4.0 but it becomes popular when C# 7.0 introduced a new tuple type with language support Nested functions – C# 7.0 Pattern matching – C# 7.0 Immutability – C# 7.2 readonly struct C# 9 record types and Init only setters Type classes – C# 12 roles/extensions (in development) == Common type system",
      "char_count": 840,
      "token_estimate": 210,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0021",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== C# has a unified type system. This unified type system is called Common Type System (CTS). A unified type system implies that all types, including primitives such as integers, are subclasses of the System.Object class. For example, every type inherits a ToString() method. ==",
      "heading_path": "== C# has a unified type system. This unified type system is called Common Type System (CTS). A unified type system implies that all types, including primitives such as integers, are subclasses of the System.Object class. For example, every type inherits a ToString() method. ==",
      "start_char": 22185,
      "end_char": 22212,
      "content": "== C# has a unified type system. This unified type system is called Common Type System (CTS). A unified type system implies that all types, including primitives such as integers, are subclasses of the System.Object class. For example, every type inherits a ToString() method. === Categories of data types",
      "char_count": 304,
      "token_estimate": 76,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0022",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = CTS separates data types into two categories: Reference types Value types Instances of value types neither have referential identity nor referential comparison semantics. Equality and inequality comparisons for value types compare the actual data values within the instances, unless the corresponding operators are overloaded. Value types are derived from System.ValueType, always have a default value, and can always be created and copied. Some other limitations on value types are that they cannot derive from each other (but can implement interfaces) and cannot have an explicit default (parameterless) constructor because they already have an implicit one which initializes all contained data to the type-dependent default value (0, null, or alike). Examples of value types are all primitive types, such as int (a signed 32-bit integer), float (a 32-bit IEEE floating-point number), char (a 16-bit Unicode code unit), decimal (fixed-point numbers useful for handling currency amounts), and System.DateTime (identifies a specific point in time with nanosecond precision). Other examples are enum (enumerations) and struct (user defined structures). In contrast, reference types have the notion of referential identity, meaning that each instance of a reference type is inherently distinct from every other instance, even if the data within both instances is the same. This is reflected in default equality and inequality comparisons for reference types, which test for referential rather than structural equality, unless the corresponding operators are overloaded (such as the case for System.String). Some operations are not always possible, such as creating an instance of a reference type, copying an existing instance, or performing a value comparison on two existing instances. Nevertheless, specific reference types can provide such services by exposing a public constructor or implementing a corresponding interface (such as ICloneable or IComparable). Examples of reference types are object (the ultimate base class for all other C# classes), System.String (a string of Unicode characters), and System.Array (a base class for all C# arrays). Both type categories are extensible with user-defined types. ==",
      "heading_path": "== = CTS separates data types into two categories: Reference types Value types Instances of value types neither have referential identity nor referential comparison semantics. Equality and inequality comparisons for value types compare the actual data values within the instances, unless the corresponding operators are overloaded. Value types are derived from System.ValueType, always have a default value, and can always be created and copied. Some other limitations on value types are that they cannot derive from each other (but can implement interfaces) and cannot have an explicit default (parameterless) constructor because they already have an implicit one which initializes all contained data to the type-dependent default value (0, null, or alike). Examples of value types are all primitive types, such as int (a signed 32-bit integer), float (a 32-bit IEEE floating-point number), char (a 16-bit Unicode code unit), decimal (fixed-point numbers useful for handling currency amounts), and System.DateTime (identifies a specific point in time with nanosecond precision). Other examples are enum (enumerations) and struct (user defined structures). In contrast, reference types have the notion of referential identity, meaning that each instance of a reference type is inherently distinct from every other instance, even if the data within both instances is the same. This is reflected in default equality and inequality comparisons for reference types, which test for referential rather than structural equality, unless the corresponding operators are overloaded (such as the case for System.String). Some operations are not always possible, such as creating an instance of a reference type, copying an existing instance, or performing a value comparison on two existing instances. Nevertheless, specific reference types can provide such services by exposing a public constructor or implementing a corresponding interface (such as ICloneable or IComparable). Examples of reference types are object (the ultimate base class for all other C# classes), System.String (a string of Unicode characters), and System.Array (a base class for all C# arrays). Both type categories are extensible with user-defined types. ==",
      "start_char": 24433,
      "end_char": 25192,
      "content": "== = CTS separates data types into two categories: Reference types Value types Instances of value types neither have referential identity nor referential comparison semantics. Equality and inequality comparisons for value types compare the actual data values within the instances, unless the corresponding operators are overloaded. Value types are derived from System.ValueType, always have a default value, and can always be created and copied. Some other limitations on value types are that they cannot derive from each other (but can implement interfaces) and cannot have an explicit default (parameterless) constructor because they already have an implicit one which initializes all contained data to the type-dependent default value (0, null, or alike).",
      "char_count": 758,
      "token_estimate": 189,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0023",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = CTS separates data types into two categories: Reference types Value types Instances of value types neither have referential identity nor referential comparison semantics. Equality and inequality comparisons for value types compare the actual data values within the instances, unless the corresponding operators are overloaded. Value types are derived from System.ValueType, always have a default value, and can always be created and copied. Some other limitations on value types are that they cannot derive from each other (but can implement interfaces) and cannot have an explicit default (parameterless) constructor because they already have an implicit one which initializes all contained data to the type-dependent default value (0, null, or alike). Examples of value types are all primitive types, such as int (a signed 32-bit integer), float (a 32-bit IEEE floating-point number), char (a 16-bit Unicode code unit), decimal (fixed-point numbers useful for handling currency amounts), and System.DateTime (identifies a specific point in time with nanosecond precision). Other examples are enum (enumerations) and struct (user defined structures). In contrast, reference types have the notion of referential identity, meaning that each instance of a reference type is inherently distinct from every other instance, even if the data within both instances is the same. This is reflected in default equality and inequality comparisons for reference types, which test for referential rather than structural equality, unless the corresponding operators are overloaded (such as the case for System.String). Some operations are not always possible, such as creating an instance of a reference type, copying an existing instance, or performing a value comparison on two existing instances. Nevertheless, specific reference types can provide such services by exposing a public constructor or implementing a corresponding interface (such as ICloneable or IComparable). Examples of reference types are object (the ultimate base class for all other C# classes), System.String (a string of Unicode characters), and System.Array (a base class for all C# arrays). Both type categories are extensible with user-defined types. ==",
      "heading_path": "== = CTS separates data types into two categories: Reference types Value types Instances of value types neither have referential identity nor referential comparison semantics. Equality and inequality comparisons for value types compare the actual data values within the instances, unless the corresponding operators are overloaded. Value types are derived from System.ValueType, always have a default value, and can always be created and copied. Some other limitations on value types are that they cannot derive from each other (but can implement interfaces) and cannot have an explicit default (parameterless) constructor because they already have an implicit one which initializes all contained data to the type-dependent default value (0, null, or alike). Examples of value types are all primitive types, such as int (a signed 32-bit integer), float (a 32-bit IEEE floating-point number), char (a 16-bit Unicode code unit), decimal (fixed-point numbers useful for handling currency amounts), and System.DateTime (identifies a specific point in time with nanosecond precision). Other examples are enum (enumerations) and struct (user defined structures). In contrast, reference types have the notion of referential identity, meaning that each instance of a reference type is inherently distinct from every other instance, even if the data within both instances is the same. This is reflected in default equality and inequality comparisons for reference types, which test for referential rather than structural equality, unless the corresponding operators are overloaded (such as the case for System.String). Some operations are not always possible, such as creating an instance of a reference type, copying an existing instance, or performing a value comparison on two existing instances. Nevertheless, specific reference types can provide such services by exposing a public constructor or implementing a corresponding interface (such as ICloneable or IComparable). Examples of reference types are object (the ultimate base class for all other C# classes), System.String (a string of Unicode characters), and System.Array (a base class for all C# arrays). Both type categories are extensible with user-defined types. ==",
      "start_char": 25192,
      "end_char": 26042,
      "content": "Examples of value types are all primitive types, such as int (a signed 32-bit integer), float (a 32-bit IEEE floating-point number), char (a 16-bit Unicode code unit), decimal (fixed-point numbers useful for handling currency amounts), and System.DateTime (identifies a specific point in time with nanosecond precision). Other examples are enum (enumerations) and struct (user defined structures). In contrast, reference types have the notion of referential identity, meaning that each instance of a reference type is inherently distinct from every other instance, even if the data within both instances is the same. This is reflected in default equality and inequality comparisons for reference types, which test for referential rather than structural equality, unless the corresponding operators are overloaded (such as the case for System.String).",
      "char_count": 850,
      "token_estimate": 212,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0024",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = CTS separates data types into two categories: Reference types Value types Instances of value types neither have referential identity nor referential comparison semantics. Equality and inequality comparisons for value types compare the actual data values within the instances, unless the corresponding operators are overloaded. Value types are derived from System.ValueType, always have a default value, and can always be created and copied. Some other limitations on value types are that they cannot derive from each other (but can implement interfaces) and cannot have an explicit default (parameterless) constructor because they already have an implicit one which initializes all contained data to the type-dependent default value (0, null, or alike). Examples of value types are all primitive types, such as int (a signed 32-bit integer), float (a 32-bit IEEE floating-point number), char (a 16-bit Unicode code unit), decimal (fixed-point numbers useful for handling currency amounts), and System.DateTime (identifies a specific point in time with nanosecond precision). Other examples are enum (enumerations) and struct (user defined structures). In contrast, reference types have the notion of referential identity, meaning that each instance of a reference type is inherently distinct from every other instance, even if the data within both instances is the same. This is reflected in default equality and inequality comparisons for reference types, which test for referential rather than structural equality, unless the corresponding operators are overloaded (such as the case for System.String). Some operations are not always possible, such as creating an instance of a reference type, copying an existing instance, or performing a value comparison on two existing instances. Nevertheless, specific reference types can provide such services by exposing a public constructor or implementing a corresponding interface (such as ICloneable or IComparable). Examples of reference types are object (the ultimate base class for all other C# classes), System.String (a string of Unicode characters), and System.Array (a base class for all C# arrays). Both type categories are extensible with user-defined types. ==",
      "heading_path": "== = CTS separates data types into two categories: Reference types Value types Instances of value types neither have referential identity nor referential comparison semantics. Equality and inequality comparisons for value types compare the actual data values within the instances, unless the corresponding operators are overloaded. Value types are derived from System.ValueType, always have a default value, and can always be created and copied. Some other limitations on value types are that they cannot derive from each other (but can implement interfaces) and cannot have an explicit default (parameterless) constructor because they already have an implicit one which initializes all contained data to the type-dependent default value (0, null, or alike). Examples of value types are all primitive types, such as int (a signed 32-bit integer), float (a 32-bit IEEE floating-point number), char (a 16-bit Unicode code unit), decimal (fixed-point numbers useful for handling currency amounts), and System.DateTime (identifies a specific point in time with nanosecond precision). Other examples are enum (enumerations) and struct (user defined structures). In contrast, reference types have the notion of referential identity, meaning that each instance of a reference type is inherently distinct from every other instance, even if the data within both instances is the same. This is reflected in default equality and inequality comparisons for reference types, which test for referential rather than structural equality, unless the corresponding operators are overloaded (such as the case for System.String). Some operations are not always possible, such as creating an instance of a reference type, copying an existing instance, or performing a value comparison on two existing instances. Nevertheless, specific reference types can provide such services by exposing a public constructor or implementing a corresponding interface (such as ICloneable or IComparable). Examples of reference types are object (the ultimate base class for all other C# classes), System.String (a string of Unicode characters), and System.Array (a base class for all C# arrays). Both type categories are extensible with user-defined types. ==",
      "start_char": 26043,
      "end_char": 26675,
      "content": "Some operations are not always possible, such as creating an instance of a reference type, copying an existing instance, or performing a value comparison on two existing instances. Nevertheless, specific reference types can provide such services by exposing a public constructor or implementing a corresponding interface (such as ICloneable or IComparable). Examples of reference types are object (the ultimate base class for all other C# classes), System.String (a string of Unicode characters), and System.Array (a base class for all C# arrays). Both type categories are extensible with user-defined types. === Boxing and unboxing",
      "char_count": 632,
      "token_estimate": 158,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0025",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = Boxing is the operation of converting a value-type object into a value of a corresponding reference type. Boxing in C# is implicit. Unboxing is the operation of converting a value of a reference type (previously boxed) into a value of a value type. Unboxing in C# requires an explicit type cast. A boxed object of type T can only be unboxed to a T (or a nullable T). Example: ==",
      "heading_path": "== = Boxing is the operation of converting a value-type object into a value of a corresponding reference type. Boxing in C# is implicit. Unboxing is the operation of converting a value of a reference type (previously boxed) into a value of a value type. Unboxing in C# requires an explicit type cast. A boxed object of type T can only be unboxed to a T (or a nullable T). Example: ==",
      "start_char": 24838,
      "end_char": 24849,
      "content": "== = Boxing is the operation of converting a value-type object into a value of a corresponding reference type. Boxing in C# is implicit. Unboxing is the operation of converting a value of a reference type (previously boxed) into a value of a value type. Unboxing in C# requires an explicit type cast. A boxed object of type T can only be unboxed to a T (or a nullable T). Example: == Libraries",
      "char_count": 393,
      "token_estimate": 98,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0026",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = The following is a very simple C# program, a version of the classic \"Hello world\" example using the top-level statements feature introduced in C# 9: For code written as C# 8 or lower, the entry point logic of a program must be written in a Main method inside a type: This code will display this text in the console window: Hello, world! Each line has a purpose: The above line imports all types in the System namespace. For example, the Console class used later in the source code is defined in the System namespace, meaning it can be used without supplying the full name of the type (which includes the namespace). This line is a comment; it describes and documents the code for the programmer(s). Above is a class definition for the Program class. Everything that follows between the pair of braces describes that class.The curly brackets demarcate the boundaries of a code block. In this first instance, they are marking the start and end of the Program class. This declares the class member method where the program begins execution. The .NET runtime calls the Main method. Unlike in Java, the Main method does not need the public keyword, which tells the compiler that the method can be called from anywhere by any class. Writing static void Main(string[] args) is equivalent to writing private static void Main(string[] args). The static keyword makes the method accessible without an instance of Program. Each console application's Main entry point must be declared static otherwise the program would require an instance of Program, but any instance would require a program. To avoid that irresolvable circular dependency, C# compilers processing console applications (like that above) report an error if there is no static Main method. The void keyword declares that Main has no return value. (Note, however, that short programs can be written using Top Level Statements introduced in C# 9, as mentioned earlier.) This line writes the output. Console is a static class in the System namespace. It provides an interface to the standard input/output, and error streams for console applications. The program calls the Console method WriteLine, which displays on the console a line with the argument, the string \"Hello, world!\". ==",
      "heading_path": "== = The following is a very simple C# program, a version of the classic \"Hello world\" example using the top-level statements feature introduced in C# 9: For code written as C# 8 or lower, the entry point logic of a program must be written in a Main method inside a type: This code will display this text in the console window: Hello, world! Each line has a purpose: The above line imports all types in the System namespace. For example, the Console class used later in the source code is defined in the System namespace, meaning it can be used without supplying the full name of the type (which includes the namespace). This line is a comment; it describes and documents the code for the programmer(s). Above is a class definition for the Program class. Everything that follows between the pair of braces describes that class.The curly brackets demarcate the boundaries of a code block. In this first instance, they are marking the start and end of the Program class. This declares the class member method where the program begins execution. The .NET runtime calls the Main method. Unlike in Java, the Main method does not need the public keyword, which tells the compiler that the method can be called from anywhere by any class. Writing static void Main(string[] args) is equivalent to writing private static void Main(string[] args). The static keyword makes the method accessible without an instance of Program. Each console application's Main entry point must be declared static otherwise the program would require an instance of Program, but any instance would require a program. To avoid that irresolvable circular dependency, C# compilers processing console applications (like that above) report an error if there is no static Main method. The void keyword declares that Main has no return value. (Note, however, that short programs can be written using Top Level Statements introduced in C# 9, as mentioned earlier.) This line writes the output. Console is a static class in the System namespace. It provides an interface to the standard input/output, and error streams for console applications. The program calls the Console method WriteLine, which displays on the console a line with the argument, the string \"Hello, world!\". ==",
      "start_char": 27677,
      "end_char": 28646,
      "content": "== = The following is a very simple C# program, a version of the classic \"Hello world\" example using the top-level statements feature introduced in C# 9: For code written as C# 8 or lower, the entry point logic of a program must be written in a Main method inside a type: This code will display this text in the console window: Hello, world! Each line has a purpose: The above line imports all types in the System namespace. For example, the Console class used later in the source code is defined in the System namespace, meaning it can be used without supplying the full name of the type (which includes the namespace). This line is a comment; it describes and documents the code for the programmer(s). Above is a class definition for the Program class. Everything that follows between the pair of braces describes that class.The curly brackets demarcate the boundaries of a code block. In this first instance, they are marking the start and end of the Program class.",
      "char_count": 968,
      "token_estimate": 242,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0027",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = The following is a very simple C# program, a version of the classic \"Hello world\" example using the top-level statements feature introduced in C# 9: For code written as C# 8 or lower, the entry point logic of a program must be written in a Main method inside a type: This code will display this text in the console window: Hello, world! Each line has a purpose: The above line imports all types in the System namespace. For example, the Console class used later in the source code is defined in the System namespace, meaning it can be used without supplying the full name of the type (which includes the namespace). This line is a comment; it describes and documents the code for the programmer(s). Above is a class definition for the Program class. Everything that follows between the pair of braces describes that class.The curly brackets demarcate the boundaries of a code block. In this first instance, they are marking the start and end of the Program class. This declares the class member method where the program begins execution. The .NET runtime calls the Main method. Unlike in Java, the Main method does not need the public keyword, which tells the compiler that the method can be called from anywhere by any class. Writing static void Main(string[] args) is equivalent to writing private static void Main(string[] args). The static keyword makes the method accessible without an instance of Program. Each console application's Main entry point must be declared static otherwise the program would require an instance of Program, but any instance would require a program. To avoid that irresolvable circular dependency, C# compilers processing console applications (like that above) report an error if there is no static Main method. The void keyword declares that Main has no return value. (Note, however, that short programs can be written using Top Level Statements introduced in C# 9, as mentioned earlier.) This line writes the output. Console is a static class in the System namespace. It provides an interface to the standard input/output, and error streams for console applications. The program calls the Console method WriteLine, which displays on the console a line with the argument, the string \"Hello, world!\". ==",
      "heading_path": "== = The following is a very simple C# program, a version of the classic \"Hello world\" example using the top-level statements feature introduced in C# 9: For code written as C# 8 or lower, the entry point logic of a program must be written in a Main method inside a type: This code will display this text in the console window: Hello, world! Each line has a purpose: The above line imports all types in the System namespace. For example, the Console class used later in the source code is defined in the System namespace, meaning it can be used without supplying the full name of the type (which includes the namespace). This line is a comment; it describes and documents the code for the programmer(s). Above is a class definition for the Program class. Everything that follows between the pair of braces describes that class.The curly brackets demarcate the boundaries of a code block. In this first instance, they are marking the start and end of the Program class. This declares the class member method where the program begins execution. The .NET runtime calls the Main method. Unlike in Java, the Main method does not need the public keyword, which tells the compiler that the method can be called from anywhere by any class. Writing static void Main(string[] args) is equivalent to writing private static void Main(string[] args). The static keyword makes the method accessible without an instance of Program. Each console application's Main entry point must be declared static otherwise the program would require an instance of Program, but any instance would require a program. To avoid that irresolvable circular dependency, C# compilers processing console applications (like that above) report an error if there is no static Main method. The void keyword declares that Main has no return value. (Note, however, that short programs can be written using Top Level Statements introduced in C# 9, as mentioned earlier.) This line writes the output. Console is a static class in the System namespace. It provides an interface to the standard input/output, and error streams for console applications. The program calls the Console method WriteLine, which displays on the console a line with the argument, the string \"Hello, world!\". ==",
      "start_char": 28646,
      "end_char": 29632,
      "content": "This declares the class member method where the program begins execution. The .NET runtime calls the Main method. Unlike in Java, the Main method does not need the public keyword, which tells the compiler that the method can be called from anywhere by any class. Writing static void Main(string[] args) is equivalent to writing private static void Main(string[] args). The static keyword makes the method accessible without an instance of Program. Each console application's Main entry point must be declared static otherwise the program would require an instance of Program, but any instance would require a program. To avoid that irresolvable circular dependency, C# compilers processing console applications (like that above) report an error if there is no static Main method. The void keyword declares that Main has no return value. (Note, however, that short programs can be written using Top Level Statements introduced in C# 9, as mentioned earlier.) This line writes the output.",
      "char_count": 986,
      "token_estimate": 246,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0028",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = The following is a very simple C# program, a version of the classic \"Hello world\" example using the top-level statements feature introduced in C# 9: For code written as C# 8 or lower, the entry point logic of a program must be written in a Main method inside a type: This code will display this text in the console window: Hello, world! Each line has a purpose: The above line imports all types in the System namespace. For example, the Console class used later in the source code is defined in the System namespace, meaning it can be used without supplying the full name of the type (which includes the namespace). This line is a comment; it describes and documents the code for the programmer(s). Above is a class definition for the Program class. Everything that follows between the pair of braces describes that class.The curly brackets demarcate the boundaries of a code block. In this first instance, they are marking the start and end of the Program class. This declares the class member method where the program begins execution. The .NET runtime calls the Main method. Unlike in Java, the Main method does not need the public keyword, which tells the compiler that the method can be called from anywhere by any class. Writing static void Main(string[] args) is equivalent to writing private static void Main(string[] args). The static keyword makes the method accessible without an instance of Program. Each console application's Main entry point must be declared static otherwise the program would require an instance of Program, but any instance would require a program. To avoid that irresolvable circular dependency, C# compilers processing console applications (like that above) report an error if there is no static Main method. The void keyword declares that Main has no return value. (Note, however, that short programs can be written using Top Level Statements introduced in C# 9, as mentioned earlier.) This line writes the output. Console is a static class in the System namespace. It provides an interface to the standard input/output, and error streams for console applications. The program calls the Console method WriteLine, which displays on the console a line with the argument, the string \"Hello, world!\". ==",
      "heading_path": "== = The following is a very simple C# program, a version of the classic \"Hello world\" example using the top-level statements feature introduced in C# 9: For code written as C# 8 or lower, the entry point logic of a program must be written in a Main method inside a type: This code will display this text in the console window: Hello, world! Each line has a purpose: The above line imports all types in the System namespace. For example, the Console class used later in the source code is defined in the System namespace, meaning it can be used without supplying the full name of the type (which includes the namespace). This line is a comment; it describes and documents the code for the programmer(s). Above is a class definition for the Program class. Everything that follows between the pair of braces describes that class.The curly brackets demarcate the boundaries of a code block. In this first instance, they are marking the start and end of the Program class. This declares the class member method where the program begins execution. The .NET runtime calls the Main method. Unlike in Java, the Main method does not need the public keyword, which tells the compiler that the method can be called from anywhere by any class. Writing static void Main(string[] args) is equivalent to writing private static void Main(string[] args). The static keyword makes the method accessible without an instance of Program. Each console application's Main entry point must be declared static otherwise the program would require an instance of Program, but any instance would require a program. To avoid that irresolvable circular dependency, C# compilers processing console applications (like that above) report an error if there is no static Main method. The void keyword declares that Main has no return value. (Note, however, that short programs can be written using Top Level Statements introduced in C# 9, as mentioned earlier.) This line writes the output. Console is a static class in the System namespace. It provides an interface to the standard input/output, and error streams for console applications. The program calls the Console method WriteLine, which displays on the console a line with the argument, the string \"Hello, world!\". ==",
      "start_char": 29633,
      "end_char": 29927,
      "content": "Console is a static class in the System namespace. It provides an interface to the standard input/output, and error streams for console applications. The program calls the Console method WriteLine, which displays on the console a line with the argument, the string \"Hello, world!\". === Generics",
      "char_count": 294,
      "token_estimate": 73,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0029",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = With .NET 2.0 and C# 2.0, the community got more flexible collections than those in .NET 1.x. In the absence of generics, developers had to use collections such as ArrayList to store elements as objects of unspecified kind, which incurred performance overhead when boxing/unboxing/type-checking the contained items. Generics introduced a massive new feature in .NET that allowed developers to create type-safe data structures. This shift is particularly important in the context of converting legacy systems, where updating to generics can significantly enhance performance and maintainability by replacing outdated data structures with more efficient, type-safe alternatives. Example ==",
      "heading_path": "== = With .NET 2.0 and C# 2.0, the community got more flexible collections than those in .NET 1.x. In the absence of generics, developers had to use collections such as ArrayList to store elements as objects of unspecified kind, which incurred performance overhead when boxing/unboxing/type-checking the contained items. Generics introduced a massive new feature in .NET that allowed developers to create type-safe data structures. This shift is particularly important in the context of converting legacy systems, where updating to generics can significantly enhance performance and maintainability by replacing outdated data structures with more efficient, type-safe alternatives. Example ==",
      "start_char": 28380,
      "end_char": 28411,
      "content": "== = With .NET 2.0 and C# 2.0, the community got more flexible collections than those in .NET 1.x. In the absence of generics, developers had to use collections such as ArrayList to store elements as objects of unspecified kind, which incurred performance overhead when boxing/unboxing/type-checking the contained items. Generics introduced a massive new feature in .NET that allowed developers to create type-safe data structures. This shift is particularly important in the context of converting legacy systems, where updating to generics can significantly enhance performance and maintainability by replacing outdated data structures with more efficient, type-safe alternatives. Example == Standardization and licensing",
      "char_count": 722,
      "token_estimate": 180,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0030",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== In August 2001, Microsoft, Hewlett-Packard and Intel co-sponsored the submission of specifications for C# as well as the Common Language Infrastructure (CLI) to the standards organization Ecma International. In December 2001, ECMA released ECMA-334 C# Language Specification. C# became an ISO/IEC standard in 2003 (ISO/IEC 23270:2003 - Information technology — Programming languages — C#). ECMA had previously adopted equivalent specifications as the 2nd edition of C#, in December 2002. In June 2005, ECMA approved edition 3 of the C# specification, and updated ECMA-334. Additions included partial classes, anonymous methods, nullable types, and generics (somewhat similar to C++ templates). In July 2005, ECMA submitted to ISO/IEC JTC 1/SC 22, via the latter's Fast-Track process, the standards and related TRs. This process usually takes 6–9 months. The C# language definition and the CLI are standardized under ISO/IEC and Ecma standards that provide reasonable and non-discriminatory licensing protection from patent claims. Microsoft initially agreed not to sue open-source developers for violating patents in non-profit projects for the part of the framework that is covered by the Open Specification Promise. Microsoft has also agreed not to enforce patents relating to Novell products against Novell's paying customers with the exception of a list of products that do not explicitly mention C#, .NET or Novell's implementation of .NET (The Mono Project). However, Novell maintained that Mono does not infringe any Microsoft patents. Microsoft also made a specific agreement not to enforce patent rights related to the Moonlight browser plugin, which depends on Mono, provided it is obtained through Novell. A decade later, Microsoft began developing free, open-source, and cross-platform tooling for C#, namely Visual Studio Code, .NET Core, and Roslyn. Mono joined Microsoft as a project of Xamarin, a Microsoft subsidiary. ==",
      "heading_path": "== In August 2001, Microsoft, Hewlett-Packard and Intel co-sponsored the submission of specifications for C# as well as the Common Language Infrastructure (CLI) to the standards organization Ecma International. In December 2001, ECMA released ECMA-334 C# Language Specification. C# became an ISO/IEC standard in 2003 (ISO/IEC 23270:2003 - Information technology — Programming languages — C#). ECMA had previously adopted equivalent specifications as the 2nd edition of C#, in December 2002. In June 2005, ECMA approved edition 3 of the C# specification, and updated ECMA-334. Additions included partial classes, anonymous methods, nullable types, and generics (somewhat similar to C++ templates). In July 2005, ECMA submitted to ISO/IEC JTC 1/SC 22, via the latter's Fast-Track process, the standards and related TRs. This process usually takes 6–9 months. The C# language definition and the CLI are standardized under ISO/IEC and Ecma standards that provide reasonable and non-discriminatory licensing protection from patent claims. Microsoft initially agreed not to sue open-source developers for violating patents in non-profit projects for the part of the framework that is covered by the Open Specification Promise. Microsoft has also agreed not to enforce patents relating to Novell products against Novell's paying customers with the exception of a list of products that do not explicitly mention C#, .NET or Novell's implementation of .NET (The Mono Project). However, Novell maintained that Mono does not infringe any Microsoft patents. Microsoft also made a specific agreement not to enforce patent rights related to the Moonlight browser plugin, which depends on Mono, provided it is obtained through Novell. A decade later, Microsoft began developing free, open-source, and cross-platform tooling for C#, namely Visual Studio Code, .NET Core, and Roslyn. Mono joined Microsoft as a project of Xamarin, a Microsoft subsidiary. ==",
      "start_char": 30351,
      "end_char": 31208,
      "content": "== In August 2001, Microsoft, Hewlett-Packard and Intel co-sponsored the submission of specifications for C# as well as the Common Language Infrastructure (CLI) to the standards organization Ecma International. In December 2001, ECMA released ECMA-334 C# Language Specification. C# became an ISO/IEC standard in 2003 (ISO/IEC 23270:2003 - Information technology — Programming languages — C#). ECMA had previously adopted equivalent specifications as the 2nd edition of C#, in December 2002. In June 2005, ECMA approved edition 3 of the C# specification, and updated ECMA-334. Additions included partial classes, anonymous methods, nullable types, and generics (somewhat similar to C++ templates). In July 2005, ECMA submitted to ISO/IEC JTC 1/SC 22, via the latter's Fast-Track process, the standards and related TRs. This process usually takes 6–9 months.",
      "char_count": 856,
      "token_estimate": 214,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0031",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== In August 2001, Microsoft, Hewlett-Packard and Intel co-sponsored the submission of specifications for C# as well as the Common Language Infrastructure (CLI) to the standards organization Ecma International. In December 2001, ECMA released ECMA-334 C# Language Specification. C# became an ISO/IEC standard in 2003 (ISO/IEC 23270:2003 - Information technology — Programming languages — C#). ECMA had previously adopted equivalent specifications as the 2nd edition of C#, in December 2002. In June 2005, ECMA approved edition 3 of the C# specification, and updated ECMA-334. Additions included partial classes, anonymous methods, nullable types, and generics (somewhat similar to C++ templates). In July 2005, ECMA submitted to ISO/IEC JTC 1/SC 22, via the latter's Fast-Track process, the standards and related TRs. This process usually takes 6–9 months. The C# language definition and the CLI are standardized under ISO/IEC and Ecma standards that provide reasonable and non-discriminatory licensing protection from patent claims. Microsoft initially agreed not to sue open-source developers for violating patents in non-profit projects for the part of the framework that is covered by the Open Specification Promise. Microsoft has also agreed not to enforce patents relating to Novell products against Novell's paying customers with the exception of a list of products that do not explicitly mention C#, .NET or Novell's implementation of .NET (The Mono Project). However, Novell maintained that Mono does not infringe any Microsoft patents. Microsoft also made a specific agreement not to enforce patent rights related to the Moonlight browser plugin, which depends on Mono, provided it is obtained through Novell. A decade later, Microsoft began developing free, open-source, and cross-platform tooling for C#, namely Visual Studio Code, .NET Core, and Roslyn. Mono joined Microsoft as a project of Xamarin, a Microsoft subsidiary. ==",
      "heading_path": "== In August 2001, Microsoft, Hewlett-Packard and Intel co-sponsored the submission of specifications for C# as well as the Common Language Infrastructure (CLI) to the standards organization Ecma International. In December 2001, ECMA released ECMA-334 C# Language Specification. C# became an ISO/IEC standard in 2003 (ISO/IEC 23270:2003 - Information technology — Programming languages — C#). ECMA had previously adopted equivalent specifications as the 2nd edition of C#, in December 2002. In June 2005, ECMA approved edition 3 of the C# specification, and updated ECMA-334. Additions included partial classes, anonymous methods, nullable types, and generics (somewhat similar to C++ templates). In July 2005, ECMA submitted to ISO/IEC JTC 1/SC 22, via the latter's Fast-Track process, the standards and related TRs. This process usually takes 6–9 months. The C# language definition and the CLI are standardized under ISO/IEC and Ecma standards that provide reasonable and non-discriminatory licensing protection from patent claims. Microsoft initially agreed not to sue open-source developers for violating patents in non-profit projects for the part of the framework that is covered by the Open Specification Promise. Microsoft has also agreed not to enforce patents relating to Novell products against Novell's paying customers with the exception of a list of products that do not explicitly mention C#, .NET or Novell's implementation of .NET (The Mono Project). However, Novell maintained that Mono does not infringe any Microsoft patents. Microsoft also made a specific agreement not to enforce patent rights related to the Moonlight browser plugin, which depends on Mono, provided it is obtained through Novell. A decade later, Microsoft began developing free, open-source, and cross-platform tooling for C#, namely Visual Studio Code, .NET Core, and Roslyn. Mono joined Microsoft as a project of Xamarin, a Microsoft subsidiary. ==",
      "start_char": 31208,
      "end_char": 32070,
      "content": "The C# language definition and the CLI are standardized under ISO/IEC and Ecma standards that provide reasonable and non-discriminatory licensing protection from patent claims. Microsoft initially agreed not to sue open-source developers for violating patents in non-profit projects for the part of the framework that is covered by the Open Specification Promise. Microsoft has also agreed not to enforce patents relating to Novell products against Novell's paying customers with the exception of a list of products that do not explicitly mention C#, .NET or Novell's implementation of .NET (The Mono Project). However, Novell maintained that Mono does not infringe any Microsoft patents. Microsoft also made a specific agreement not to enforce patent rights related to the Moonlight browser plugin, which depends on Mono, provided it is obtained through Novell.",
      "char_count": 862,
      "token_estimate": 215,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0032",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== In August 2001, Microsoft, Hewlett-Packard and Intel co-sponsored the submission of specifications for C# as well as the Common Language Infrastructure (CLI) to the standards organization Ecma International. In December 2001, ECMA released ECMA-334 C# Language Specification. C# became an ISO/IEC standard in 2003 (ISO/IEC 23270:2003 - Information technology — Programming languages — C#). ECMA had previously adopted equivalent specifications as the 2nd edition of C#, in December 2002. In June 2005, ECMA approved edition 3 of the C# specification, and updated ECMA-334. Additions included partial classes, anonymous methods, nullable types, and generics (somewhat similar to C++ templates). In July 2005, ECMA submitted to ISO/IEC JTC 1/SC 22, via the latter's Fast-Track process, the standards and related TRs. This process usually takes 6–9 months. The C# language definition and the CLI are standardized under ISO/IEC and Ecma standards that provide reasonable and non-discriminatory licensing protection from patent claims. Microsoft initially agreed not to sue open-source developers for violating patents in non-profit projects for the part of the framework that is covered by the Open Specification Promise. Microsoft has also agreed not to enforce patents relating to Novell products against Novell's paying customers with the exception of a list of products that do not explicitly mention C#, .NET or Novell's implementation of .NET (The Mono Project). However, Novell maintained that Mono does not infringe any Microsoft patents. Microsoft also made a specific agreement not to enforce patent rights related to the Moonlight browser plugin, which depends on Mono, provided it is obtained through Novell. A decade later, Microsoft began developing free, open-source, and cross-platform tooling for C#, namely Visual Studio Code, .NET Core, and Roslyn. Mono joined Microsoft as a project of Xamarin, a Microsoft subsidiary. ==",
      "heading_path": "== In August 2001, Microsoft, Hewlett-Packard and Intel co-sponsored the submission of specifications for C# as well as the Common Language Infrastructure (CLI) to the standards organization Ecma International. In December 2001, ECMA released ECMA-334 C# Language Specification. C# became an ISO/IEC standard in 2003 (ISO/IEC 23270:2003 - Information technology — Programming languages — C#). ECMA had previously adopted equivalent specifications as the 2nd edition of C#, in December 2002. In June 2005, ECMA approved edition 3 of the C# specification, and updated ECMA-334. Additions included partial classes, anonymous methods, nullable types, and generics (somewhat similar to C++ templates). In July 2005, ECMA submitted to ISO/IEC JTC 1/SC 22, via the latter's Fast-Track process, the standards and related TRs. This process usually takes 6–9 months. The C# language definition and the CLI are standardized under ISO/IEC and Ecma standards that provide reasonable and non-discriminatory licensing protection from patent claims. Microsoft initially agreed not to sue open-source developers for violating patents in non-profit projects for the part of the framework that is covered by the Open Specification Promise. Microsoft has also agreed not to enforce patents relating to Novell products against Novell's paying customers with the exception of a list of products that do not explicitly mention C#, .NET or Novell's implementation of .NET (The Mono Project). However, Novell maintained that Mono does not infringe any Microsoft patents. Microsoft also made a specific agreement not to enforce patent rights related to the Moonlight browser plugin, which depends on Mono, provided it is obtained through Novell. A decade later, Microsoft began developing free, open-source, and cross-platform tooling for C#, namely Visual Studio Code, .NET Core, and Roslyn. Mono joined Microsoft as a project of Xamarin, a Microsoft subsidiary. ==",
      "start_char": 32071,
      "end_char": 32307,
      "content": "A decade later, Microsoft began developing free, open-source, and cross-platform tooling for C#, namely Visual Studio Code, .NET Core, and Roslyn. Mono joined Microsoft as a project of Xamarin, a Microsoft subsidiary. == Implementations",
      "char_count": 236,
      "token_estimate": 59,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0033",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== Microsoft has developed open-source reference C# compilers and tools. The first compiler, Roslyn, compiles into intermediate language (IL), and the second one, RyuJIT, is a JIT (just-in-time) compiler, which is dynamic and does on-the-fly optimization and compiles the IL into native code for the front-end of the CPU. RyuJIT is open source and written in C++. Roslyn is entirely written in managed code (C#), has been opened up and functionality surfaced as APIs. It is thus enabling developers to create refactoring and diagnostics tools. Two branches of official implementation are .NET Framework (closed-source, Windows-only) and .NET Core (open-source, cross-platform); they eventually converged into one open-source implementation: .NET 5.0. At .NET Framework 4.6, a new JIT compiler replaced the former. Other C# compilers (some of which include an implementation of the Common Language Infrastructure and .NET class libraries): Mono, a Microsoft-sponsored project provides an open-source C# compiler, a complete open-source implementation of the CLI (including the required framework libraries as they appear in the ECMA specification,) and a nearly complete implementation of the NET class libraries up to .NET Framework 3.5. The Elements tool chain from RemObjects includes RemObjects C#, which compiles C# code to .NET's Common Intermediate Language, Java bytecode, Cocoa, Android bytecode, WebAssembly, and native machine code for Windows, macOS, and Linux. The DotGNU project (now discontinued) also provided an open-source C# compiler, a nearly complete implementation of the Common Language Infrastructure including the required framework libraries as they appear in the ECMA specification, and subset of some of the remaining Microsoft proprietary .NET class libraries up to .NET 2.0 (those not documented or included in the ECMA specification, but included in Microsoft's standard .NET Framework distribution). The Unity game engine uses C# as its primary scripting language. The Godot game engine has implemented an optional C# module due to a donation of $24,000 from Microsoft. ==",
      "heading_path": "== Microsoft has developed open-source reference C# compilers and tools. The first compiler, Roslyn, compiles into intermediate language (IL), and the second one, RyuJIT, is a JIT (just-in-time) compiler, which is dynamic and does on-the-fly optimization and compiles the IL into native code for the front-end of the CPU. RyuJIT is open source and written in C++. Roslyn is entirely written in managed code (C#), has been opened up and functionality surfaced as APIs. It is thus enabling developers to create refactoring and diagnostics tools. Two branches of official implementation are .NET Framework (closed-source, Windows-only) and .NET Core (open-source, cross-platform); they eventually converged into one open-source implementation: .NET 5.0. At .NET Framework 4.6, a new JIT compiler replaced the former. Other C# compilers (some of which include an implementation of the Common Language Infrastructure and .NET class libraries): Mono, a Microsoft-sponsored project provides an open-source C# compiler, a complete open-source implementation of the CLI (including the required framework libraries as they appear in the ECMA specification,) and a nearly complete implementation of the NET class libraries up to .NET Framework 3.5. The Elements tool chain from RemObjects includes RemObjects C#, which compiles C# code to .NET's Common Intermediate Language, Java bytecode, Cocoa, Android bytecode, WebAssembly, and native machine code for Windows, macOS, and Linux. The DotGNU project (now discontinued) also provided an open-source C# compiler, a nearly complete implementation of the Common Language Infrastructure including the required framework libraries as they appear in the ECMA specification, and subset of some of the remaining Microsoft proprietary .NET class libraries up to .NET 2.0 (those not documented or included in the ECMA specification, but included in Microsoft's standard .NET Framework distribution). The Unity game engine uses C# as its primary scripting language. The Godot game engine has implemented an optional C# module due to a donation of $24,000 from Microsoft. ==",
      "start_char": 32471,
      "end_char": 33285,
      "content": "== Microsoft has developed open-source reference C# compilers and tools. The first compiler, Roslyn, compiles into intermediate language (IL), and the second one, RyuJIT, is a JIT (just-in-time) compiler, which is dynamic and does on-the-fly optimization and compiles the IL into native code for the front-end of the CPU. RyuJIT is open source and written in C++. Roslyn is entirely written in managed code (C#), has been opened up and functionality surfaced as APIs. It is thus enabling developers to create refactoring and diagnostics tools. Two branches of official implementation are .NET Framework (closed-source, Windows-only) and .NET Core (open-source, cross-platform); they eventually converged into one open-source implementation: .NET 5.0. At .NET Framework 4.6, a new JIT compiler replaced the former.",
      "char_count": 813,
      "token_estimate": 203,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0034",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== Microsoft has developed open-source reference C# compilers and tools. The first compiler, Roslyn, compiles into intermediate language (IL), and the second one, RyuJIT, is a JIT (just-in-time) compiler, which is dynamic and does on-the-fly optimization and compiles the IL into native code for the front-end of the CPU. RyuJIT is open source and written in C++. Roslyn is entirely written in managed code (C#), has been opened up and functionality surfaced as APIs. It is thus enabling developers to create refactoring and diagnostics tools. Two branches of official implementation are .NET Framework (closed-source, Windows-only) and .NET Core (open-source, cross-platform); they eventually converged into one open-source implementation: .NET 5.0. At .NET Framework 4.6, a new JIT compiler replaced the former. Other C# compilers (some of which include an implementation of the Common Language Infrastructure and .NET class libraries): Mono, a Microsoft-sponsored project provides an open-source C# compiler, a complete open-source implementation of the CLI (including the required framework libraries as they appear in the ECMA specification,) and a nearly complete implementation of the NET class libraries up to .NET Framework 3.5. The Elements tool chain from RemObjects includes RemObjects C#, which compiles C# code to .NET's Common Intermediate Language, Java bytecode, Cocoa, Android bytecode, WebAssembly, and native machine code for Windows, macOS, and Linux. The DotGNU project (now discontinued) also provided an open-source C# compiler, a nearly complete implementation of the Common Language Infrastructure including the required framework libraries as they appear in the ECMA specification, and subset of some of the remaining Microsoft proprietary .NET class libraries up to .NET 2.0 (those not documented or included in the ECMA specification, but included in Microsoft's standard .NET Framework distribution). The Unity game engine uses C# as its primary scripting language. The Godot game engine has implemented an optional C# module due to a donation of $24,000 from Microsoft. ==",
      "heading_path": "== Microsoft has developed open-source reference C# compilers and tools. The first compiler, Roslyn, compiles into intermediate language (IL), and the second one, RyuJIT, is a JIT (just-in-time) compiler, which is dynamic and does on-the-fly optimization and compiles the IL into native code for the front-end of the CPU. RyuJIT is open source and written in C++. Roslyn is entirely written in managed code (C#), has been opened up and functionality surfaced as APIs. It is thus enabling developers to create refactoring and diagnostics tools. Two branches of official implementation are .NET Framework (closed-source, Windows-only) and .NET Core (open-source, cross-platform); they eventually converged into one open-source implementation: .NET 5.0. At .NET Framework 4.6, a new JIT compiler replaced the former. Other C# compilers (some of which include an implementation of the Common Language Infrastructure and .NET class libraries): Mono, a Microsoft-sponsored project provides an open-source C# compiler, a complete open-source implementation of the CLI (including the required framework libraries as they appear in the ECMA specification,) and a nearly complete implementation of the NET class libraries up to .NET Framework 3.5. The Elements tool chain from RemObjects includes RemObjects C#, which compiles C# code to .NET's Common Intermediate Language, Java bytecode, Cocoa, Android bytecode, WebAssembly, and native machine code for Windows, macOS, and Linux. The DotGNU project (now discontinued) also provided an open-source C# compiler, a nearly complete implementation of the Common Language Infrastructure including the required framework libraries as they appear in the ECMA specification, and subset of some of the remaining Microsoft proprietary .NET class libraries up to .NET 2.0 (those not documented or included in the ECMA specification, but included in Microsoft's standard .NET Framework distribution). The Unity game engine uses C# as its primary scripting language. The Godot game engine has implemented an optional C# module due to a donation of $24,000 from Microsoft. ==",
      "start_char": 33285,
      "end_char": 33943,
      "content": "Other C# compilers (some of which include an implementation of the Common Language Infrastructure and .NET class libraries): Mono, a Microsoft-sponsored project provides an open-source C# compiler, a complete open-source implementation of the CLI (including the required framework libraries as they appear in the ECMA specification,) and a nearly complete implementation of the NET class libraries up to .NET Framework 3.5. The Elements tool chain from RemObjects includes RemObjects C#, which compiles C# code to .NET's Common Intermediate Language, Java bytecode, Cocoa, Android bytecode, WebAssembly, and native machine code for Windows, macOS, and Linux.",
      "char_count": 658,
      "token_estimate": 164,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0035",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== Microsoft has developed open-source reference C# compilers and tools. The first compiler, Roslyn, compiles into intermediate language (IL), and the second one, RyuJIT, is a JIT (just-in-time) compiler, which is dynamic and does on-the-fly optimization and compiles the IL into native code for the front-end of the CPU. RyuJIT is open source and written in C++. Roslyn is entirely written in managed code (C#), has been opened up and functionality surfaced as APIs. It is thus enabling developers to create refactoring and diagnostics tools. Two branches of official implementation are .NET Framework (closed-source, Windows-only) and .NET Core (open-source, cross-platform); they eventually converged into one open-source implementation: .NET 5.0. At .NET Framework 4.6, a new JIT compiler replaced the former. Other C# compilers (some of which include an implementation of the Common Language Infrastructure and .NET class libraries): Mono, a Microsoft-sponsored project provides an open-source C# compiler, a complete open-source implementation of the CLI (including the required framework libraries as they appear in the ECMA specification,) and a nearly complete implementation of the NET class libraries up to .NET Framework 3.5. The Elements tool chain from RemObjects includes RemObjects C#, which compiles C# code to .NET's Common Intermediate Language, Java bytecode, Cocoa, Android bytecode, WebAssembly, and native machine code for Windows, macOS, and Linux. The DotGNU project (now discontinued) also provided an open-source C# compiler, a nearly complete implementation of the Common Language Infrastructure including the required framework libraries as they appear in the ECMA specification, and subset of some of the remaining Microsoft proprietary .NET class libraries up to .NET 2.0 (those not documented or included in the ECMA specification, but included in Microsoft's standard .NET Framework distribution). The Unity game engine uses C# as its primary scripting language. The Godot game engine has implemented an optional C# module due to a donation of $24,000 from Microsoft. ==",
      "heading_path": "== Microsoft has developed open-source reference C# compilers and tools. The first compiler, Roslyn, compiles into intermediate language (IL), and the second one, RyuJIT, is a JIT (just-in-time) compiler, which is dynamic and does on-the-fly optimization and compiles the IL into native code for the front-end of the CPU. RyuJIT is open source and written in C++. Roslyn is entirely written in managed code (C#), has been opened up and functionality surfaced as APIs. It is thus enabling developers to create refactoring and diagnostics tools. Two branches of official implementation are .NET Framework (closed-source, Windows-only) and .NET Core (open-source, cross-platform); they eventually converged into one open-source implementation: .NET 5.0. At .NET Framework 4.6, a new JIT compiler replaced the former. Other C# compilers (some of which include an implementation of the Common Language Infrastructure and .NET class libraries): Mono, a Microsoft-sponsored project provides an open-source C# compiler, a complete open-source implementation of the CLI (including the required framework libraries as they appear in the ECMA specification,) and a nearly complete implementation of the NET class libraries up to .NET Framework 3.5. The Elements tool chain from RemObjects includes RemObjects C#, which compiles C# code to .NET's Common Intermediate Language, Java bytecode, Cocoa, Android bytecode, WebAssembly, and native machine code for Windows, macOS, and Linux. The DotGNU project (now discontinued) also provided an open-source C# compiler, a nearly complete implementation of the Common Language Infrastructure including the required framework libraries as they appear in the ECMA specification, and subset of some of the remaining Microsoft proprietary .NET class libraries up to .NET 2.0 (those not documented or included in the ECMA specification, but included in Microsoft's standard .NET Framework distribution). The Unity game engine uses C# as its primary scripting language. The Godot game engine has implemented an optional C# module due to a donation of $24,000 from Microsoft. ==",
      "start_char": 33944,
      "end_char": 34583,
      "content": "The DotGNU project (now discontinued) also provided an open-source C# compiler, a nearly complete implementation of the Common Language Infrastructure including the required framework libraries as they appear in the ECMA specification, and subset of some of the remaining Microsoft proprietary .NET class libraries up to .NET 2.0 (those not documented or included in the ECMA specification, but included in Microsoft's standard .NET Framework distribution). The Unity game engine uses C# as its primary scripting language. The Godot game engine has implemented an optional C# module due to a donation of $24,000 from Microsoft. == See also",
      "char_count": 639,
      "token_estimate": 159,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0036",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== = Albahari, Joseph (2022). C# 10 in a Nutshell (First ed.). O'Reilly. ISBN 978-1-098-12195-2. Archer, Tom (2001). \"Part 2, Chapter 4: The Type System\". Inside C#. Redmond, Washington: Microsoft Press. ISBN 0-7356-1288-9. Novák, István; Velvart, Andras; Granicz, Adam; Balássy, György; Hajdrik, Attila; Sellers, Mitchel; Hillar, Gastón C.; Molnár, Ágnes; Kanjilal, Joydip (2010). Visual Studio 2010 and .NET 4 Six-in-One. Wrox Press. ISBN 978-0470499481. Skeet, Jon (2019). C# in Depth (Fourth ed.). Manning. ISBN 978-1617294532. ==",
      "heading_path": "== = Albahari, Joseph (2022). C# 10 in a Nutshell (First ed.). O'Reilly. ISBN 978-1-098-12195-2. Archer, Tom (2001). \"Part 2, Chapter 4: The Type System\". Inside C#. Redmond, Washington: Microsoft Press. ISBN 0-7356-1288-9. Novák, István; Velvart, Andras; Granicz, Adam; Balássy, György; Hajdrik, Attila; Sellers, Mitchel; Hillar, Gastón C.; Molnár, Ágnes; Kanjilal, Joydip (2010). Visual Studio 2010 and .NET 4 Six-in-One. Wrox Press. ISBN 978-0470499481. Skeet, Jon (2019). C# in Depth (Fourth ed.). Manning. ISBN 978-1617294532. ==",
      "start_char": 33032,
      "end_char": 33049,
      "content": "== = Albahari, Joseph (2022). C# 10 in a Nutshell (First ed.). O'Reilly. ISBN 978-1-098-12195-2. Archer, Tom (2001). \"Part 2, Chapter 4: The Type System\". Inside C#. Redmond, Washington: Microsoft Press. ISBN 0-7356-1288-9. Novák, István; Velvart, Andras; Granicz, Adam; Balássy, György; Hajdrik, Attila; Sellers, Mitchel; Hillar, Gastón C.; Molnár, Ágnes; Kanjilal, Joydip (2010). Visual Studio 2010 and .NET 4 Six-in-One. Wrox Press. ISBN 978-0470499481. Skeet, Jon (2019). C# in Depth (Fourth ed.). Manning. ISBN 978-1617294532. == Further reading",
      "char_count": 550,
      "token_estimate": 137,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "csharpprogramminglan_6d7f4886_c0037",
      "article_id": "csharpprogramminglan_6d7f4886",
      "section": "== Drayton, Peter; Albahari, Ben; Neward, Ted (2002). C# Language Pocket Reference. O'Reilly. ISBN 0-596-00429-X. Petzold, Charles (2002). Programming Microsoft Windows with C#. Microsoft Press. ISBN 0-7356-1370-2. ==",
      "heading_path": "== Drayton, Peter; Albahari, Ben; Neward, Ted (2002). C# Language Pocket Reference. O'Reilly. ISBN 0-596-00429-X. Petzold, Charles (2002). Programming Microsoft Windows with C#. Microsoft Press. ISBN 0-7356-1370-2. ==",
      "start_char": 33266,
      "end_char": 33282,
      "content": "== Drayton, Peter; Albahari, Ben; Neward, Ted (2002). C# Language Pocket Reference. O'Reilly. ISBN 0-596-00429-X. Petzold, Charles (2002). Programming Microsoft Windows with C#. Microsoft Press. ISBN 0-7356-1370-2. == External links",
      "char_count": 232,
      "token_estimate": 58,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 10,
    "items": [
      {
        "question": "Why must the Main entry point in a C# console application be declared as static?",
        "answer": "The Main method must be declared static to avoid an irresolvable circular dependency. If it were not static, the program would require an instance of the Program class to be called, but creating an instance would require a program to already be running. Making the method static allows it to be accessed without an instance of the Program class.",
        "related_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0027"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0027"
        ]
      },
      {
        "question": "For what reasons does C# not include checked exceptions?",
        "answer": "The decision to not include checked exceptions in C# was a conscious one based on issues of scalability and version management.",
        "related_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0019"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0019"
        ]
      },
      {
        "question": "Does the C# language allow for global variables or functions?",
        "answer": "No, the C# language does not allow for global variables or functions. All methods and members must be declared within classes.",
        "related_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0015"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0015"
        ]
      },
      {
        "question": "How has the C# ecosystem evolved since its initial release to better align with its design goal of portability?",
        "answer": "Initially, C# was introduced in 2000 with the closed-source .NET Framework and Visual Studio. While a key design goal was portability, this was first addressed by the separate, open-source Mono project in 2004. A decade later, Microsoft itself significantly advanced this goal by releasing core components like the Roslyn compiler and the unified .NET platform as free, open-source, and cross-platform, making it much easier to develop and deploy C# applications in diverse environments.",
        "related_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0000",
          "csharpprogramminglan_6d7f4886_c0001",
          "csharpprogramminglan_6d7f4886_c0002"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0002",
          "csharpprogramminglan_6d7f4886_c0000",
          "csharpprogramminglan_6d7f4886_c0001"
        ]
      },
      {
        "question": "How did lead architect Anders Hejlsberg's stated design influences for C# relate to the language's intended purpose and performance targets?",
        "answer": "Anders Hejlsberg, C#'s lead architect, stated that the language's design was driven by flaws in languages like C++ and Java, and that C# is \"much closer to C++\" than a \"Java clone\". This aligns with C#'s stated design goals, which specify that while the language should be economical with memory and processing power for a wide range of applications, it was not intended to compete directly with C or assembly language on performance and size. This indicates a design that balances high-level, managed features with a C++-like design philosophy, rather than aiming for the absolute performance of lower-level languages.",
        "related_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0003",
          "csharpprogramminglan_6d7f4886_c0004",
          "csharpprogramminglan_6d7f4886_c0005"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0004",
          "csharpprogramminglan_6d7f4886_c0005",
          "csharpprogramminglan_6d7f4886_c0003"
        ]
      },
      {
        "question": "Provide a brief history of the C# language, including the origin of its name, its standardization process, and a retired element from its early days.",
        "answer": "The name \"C#\" was first used by Microsoft in 1988 for an uncompleted project and was later reused. The name was inspired by musical notation, where a sharp symbol indicates a higher pitch, similar to how \"++\" in C++ increments a variable. The language was submitted for standardization to the ISO/IEC JTC 1 subcommittee SC 22, and after a withdrawn submission, was approved under ISO/IEC 23270:2006, which was later superseded by the 23270:2018 version. In its early history, C# also had a mascot named Andy, which was officially retired on January 29, 2004.",
        "related_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0006",
          "csharpprogramminglan_6d7f4886_c0007",
          "csharpprogramminglan_6d7f4886_c0008"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0007",
          "csharpprogramminglan_6d7f4886_c0008",
          "csharpprogramminglan_6d7f4886_c0006"
        ]
      },
      {
        "question": "How did the open-source status of C# and its associated Microsoft tools evolve over time?",
        "answer": "When C# was first introduced by Microsoft in July 2000, it was accompanied by closed-source tools like the .NET Framework and Visual Studio. The first major open-source initiative was the Microsoft Mono project in 2004, which provided a cross-platform compiler and runtime. A decade later, Microsoft itself fully embraced open-source by releasing key tools like Visual Studio Code, the Roslyn compiler, and the unified .NET platform as free, open-source, and cross-platform.",
        "related_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0000",
          "csharpprogramminglan_6d7f4886_c0001"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0000",
          "csharpprogramminglan_6d7f4886_c0001"
        ]
      },
      {
        "question": "How does C#'s design philosophy balance programmer productivity and portability with its performance targets?",
        "answer": "C# is designed to prioritize programmer productivity, software robustness, and portability for developers. However, these goals come with a trade-off, as the language was not intended to compete directly with C or assembly language in terms of performance and size, despite being suitable for a wide range of applications from large hosted systems to small embedded ones.",
        "related_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0002",
          "csharpprogramminglan_6d7f4886_c0003"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0002",
          "csharpprogramminglan_6d7f4886_c0003"
        ]
      },
      {
        "question": "Trace the historical development of C#, including its origins, its relationship with Java, and the major features that contributed to its evolution.",
        "answer": "C# originated in January 1999 when Anders Hejlsberg formed a team to build a new language initially called COOL (C-like Object Oriented Language), which was renamed C# by July 2000. Its design was influenced by perceived flaws in languages like C++, Java, and Delphi. This led to a contentious relationship with Java, whose creator James Gosling called C# an \"imitation,\" though Hejlsberg stated C# was \"much closer to C++.\" From C# 2.0 (November 2005) onwards, the languages diverged, notably in their implementation of generics, with C# using reification. C# further distinguished itself by adding functional programming features like LINQ extensions, lambda expressions, and anonymous types with C# 3.0. The language was also formally standardized under ISO/IEC, with its first approval in 2003.",
        "related_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0004",
          "csharpprogramminglan_6d7f4886_c0005",
          "csharpprogramminglan_6d7f4886_c0006",
          "csharpprogramminglan_6d7f4886_c0007"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0005",
          "csharpprogramminglan_6d7f4886_c0004",
          "csharpprogramminglan_6d7f4886_c0006",
          "csharpprogramminglan_6d7f4886_c0007"
        ]
      },
      {
        "question": "How has the naming convention established with C#, which signifies an increment or enhancement of a base language, been extended to other software in the .NET ecosystem?",
        "answer": "The \"sharp\" suffix, inspired by musical notation and the idea of incrementing a language like C++, has been applied to other .NET languages that are variants of existing ones. Examples include J# (derived from Java 1.1), A# (from Ada), and the functional language F#. The naming convention has also been used for libraries, such as Gtk# and Cocoa#, which serve as .NET wrappers for other toolkits.",
        "related_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0008",
          "csharpprogramminglan_6d7f4886_c0009"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "csharpprogramminglan_6d7f4886_c0009",
          "csharpprogramminglan_6d7f4886_c0008"
        ]
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-30T10:37:33.824Z",
    "content_format": "markdown",
    "total_chunks": 38,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}