{
  "article": {
    "id": "kerneloperatingsyste_beac728d",
    "title": "Kernel (operating system)",
    "url": "https://en.wikipedia.org/wiki/Kernel_(operating_system)",
    "lang": "en",
    "created_at": "2025-07-30T10:34:20.601853",
    "content": "---\nid: kerneloperatingsyste_beac728d\nurl: https://en.wikipedia.org/wiki/Kernel_(operating_system)\ntitle: Kernel (operating system)\nlang: en\ncreated_at: '2025-07-30T10:31:03.386996'\nchecksum: b0bb1fd3975bb9e9bd66df9875bfb8417bc41606b524d42affce4d879338798c\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 7903\n  char_count: 50651\n  num_chunks: 61\n  original_chunks: 69\n  filtered_out: 8\n  num_sections: 0\n---\nA kernel is a computer program at the core of a computer's operating system that always has complete control over everything in the system. The kernel is also responsible for preventing and mitigating conflicts between different processes. It is the portion of the operating system code that is always resident in memory and facilitates interactions between hardware and software components. A full kernel controls all hardware resources (e.g. I/O, memory, cryptography) via device drivers, arbitrates conflicts between processes concerning such resources, and optimizes the use of common resources, such as CPU, cache, file systems, and network sockets. On most systems, the kernel is one of the first programs loaded on startup (after the bootloader). It handles the rest of startup as well as memory, peripherals, and input/output (I/O) requests from software, translating them into data-processing instructions for the central processing unit. The critical code of the kernel is usually loaded into a separate area of memory, which is protected from access by application software or other less critical parts of the operating system. The kernel performs its tasks, such as running processes, managing hardware devices such as the hard disk, and handling interrupts, in this protected kernel space. In contrast, application programs such as browsers, word processors, or audio or video players use a separate area of memory, user space. This prevents user data and kernel data from interfering with each other and causing instability and slowness, as well as preventing malfunctioning applications from affecting other applications or crashing the entire operating system. Even in systems where the kernel is included in application address spaces, memory protection is used to prevent unauthorized applications from modifying the kernel. The kernel's interface is a low-level abstraction layer. When a process requests a service from the kernel, it must invoke a system call, usually through a wrapper function. There are different kernel architecture designs. Monolithic kernels run entirely in a single address space with the CPU executing in supervisor mode, mainly for speed. Microkernels run most but not all of their services in user space, like user processes do, mainly for resilience and modularity. MINIX 3 is a notable example of microkernel design. Some kernels, such as the Linux kernel, are both monolithic and modular, since they can insert and remove loadable kernel modules at runtime. This central component of a computer system is responsible for executing programs. The kernel takes responsibility for deciding at any time which of the many running programs should be allocated to the processor or processors. == Random-access memory == Random-access memory (RAM) is used to store both program instructions and data. Typically, both need to be present in memory for a program to execute. Often, multiple programs will want memory access, frequently demanding more memory than the computer has available. The kernel is responsible for deciding which memory each process can use, and determining what to do when insufficient memory is available. == Input/output devices == I/O devices include, but are not limited to, peripherals such as keyboards, mice, disk drives, printers, USB devices, network adapters, and display devices. The kernel provides convenient methods for applications to use these devices which are typically abstracted by the kernel so that applications do not need to know their implementation details. == Resource management == Key aspects necessary in resource management are defining the execution domain (address space) and the protection mechanism used to mediate access to the resources within a domain. Kernels also provide methods for synchronization and inter-process communication (IPC). These implementations may be located within the kernel itself or the kernel can also rely on other processes it is running. Although the kernel must provide IPC in order to provide access to the facilities provided by each other, kernels must also provide running programs with a method to make requests to access these facilities. The kernel is also responsible for context switching between processes or threads. == Memory management == The kernel has full access to the system's memory and must allow processes to safely access this memory as they require it. Often the first step in doing this is virtual addressing, usually achieved by paging and/or segmentation. Virtual addressing allows the kernel to make a given physical address appear to be another address, the virtual address. Virtual address spaces may be different for different processes; the memory that one process accesses at a particular (virtual) address may be different memory from what another process accesses at the same address. This allows every program to behave as if it is the only one (apart from the kernel) running and thus prevents applications from crashing each other. On many systems, a program's virtual address may refer to data which is not currently in memory. The layer of indirection provided by virtual addressing allows the operating system to use other data stores, like a hard drive, to store what would otherwise have to remain in main memory (RAM). As a result, operating systems can allow programs to use more memory than the system has physically available. When a program needs data which is not currently in RAM, the CPU signals to the kernel that this has happened, and the kernel responds by writing the contents of an inactive memory block to disk (if necessary) and replacing it with the data requested by the program. The program can then be resumed from the point where it was stopped. This scheme is generally known as demand paging. Virtual addressing also allows creation of virtual partitions of memory in two disjoint areas, one being reserved for the kernel (kernel space) and the other for the applications (user space). The applications are not permitted by the processor to address kernel memory, thus preventing an application from damaging the running kernel. This fundamental partition of memory space has contributed much to the current designs of actual general-purpose kernels and is almost universal in such systems, although some research kernels (e.g., Singularity) take other approaches. == Device management == To perform useful functions, processes need access to the peripherals connected to the computer, which are controlled by the kernel through device drivers. A device driver is a computer program encapsulating, monitoring and controlling a hardware device (via its hardware/software interface (HSI)) on behalf of the OS. It provides the operating system with an API, procedures and information about how to control and communicate with a certain piece of hardware. Device drivers are an important and vital dependency for all OS and their applications. The design goal of a driver is abstraction; the function of the driver is to translate the OS-mandated abstract function calls (programming calls) into device-specific calls. In theory, a device should work correctly with a suitable driver. Device drivers are used for e.g. video cards, sound cards, printers, scanners, modems, and Network cards. At the hardware level, common abstractions of device drivers include: Interfacing directly Using a high-level interface (Video BIOS) Using a lower-level device driver (file drivers using disk drivers) Simulating work with hardware, while doing something entirely different And at the software level, device driver abstractions include: Allowing the operating system direct access to hardware resources Only implementing primitives Implementing an interface for non-driver software such as TWAIN Implementing a language (often a high-level language such as PostScript) For example, to show the user something on the screen, an application would make a request to the kernel, which would forward the request to its display driver, which is then responsible for actually plotting the character/pixel. A kernel must maintain a list of available devices. This list may be known in advance (e.g., on an embedded system where the kernel will be rewritten if the available hardware changes), configured by the user (typical on older PCs and on systems that are not designed for personal use) or detected by the operating system at run time (normally called plug and play). In plug-and-play systems, a device manager first performs a scan on different peripheral buses, such as Peripheral Component Interconnect (PCI) or Universal Serial Bus (USB), to detect installed devices, then searches for the appropriate drivers. As device management is a very OS-specific topic, these drivers are handled differently by each kind of kernel design, but in every case, the kernel has to provide the I/O to allow drivers to physically access their devices through some port or memory location. Important decisions have to be made when designing the device management system, as in some designs accesses may involve context switches, making the operation very CPU-intensive and easily causing a significant performance overhead. == System calls == In computing, a system call is how a process requests a service from an operating system's kernel that it does not normally have permission to run. System calls provide the interface between a process and the operating system. Most operations interacting with the system require permissions not available to a user-level process, e.g., I/O performed with a device present on the system, or any form of communication with other processes requires the use of system calls. A system call is a mechanism that is used by the application program to request a service from the operating system. They use a machine-code instruction that causes the processor to change mode. An example would be from supervisor mode to protected mode. This is where the operating system performs actions like accessing hardware devices or the memory management unit. Generally the operating system provides a library that sits between the operating system and normal user programs. Usually it is a C library such as Glibc or Windows API. The library handles the low-level details of passing information to the kernel and switching to supervisor mode. System calls include close, open, read, wait and write. To actually perform useful work, a process must be able to access the services provided by the kernel. This is implemented differently by each kernel, but most provide a C library or an API, which in turn invokes the related kernel functions. The method of invoking the kernel function varies from kernel to kernel. If memory isolation is in use, it is impossible for a user process to call the kernel directly, because that would be a violation of the processor's access control rules. A few possibilities are: Using a software-simulated interrupt. This method is available on most hardware, and is therefore very common. Using a call gate. A call gate is a special address stored by the kernel in a list in kernel memory at a location known to the processor. When the processor detects a call to that address, it instead redirects to the target location without causing an access violation. This requires hardware support, but the hardware for it is quite common. Using a special system call instruction. This technique requires special hardware support, which common architectures (notably, x86) may lack. System call instructions have been added to recent models of x86 processors, however, and some operating systems for PCs make use of them when available. Using a memory-based queue. An application that makes large numbers of requests but does not need to wait for the result of each may add details of requests to an area of memory that the kernel periodically scans to find requests. == Kernel design decisions == === Protection === An important consideration in the design of a kernel is the support it provides for protection from faults (fault tolerance) and from malicious behaviours (security). These two aspects are usually not clearly distinguished, and the adoption of this distinction in the kernel design leads to the rejection of a hierarchical structure for protection. The mechanisms or policies provided by the kernel can be classified according to several criteria, including: static (enforced at compile time) or dynamic (enforced at run time); pre-emptive or post-detection; according to the protection principles they satisfy (e.g., Denning); whether they are hardware supported or language based; whether they are more an open mechanism or a binding policy; and many more. Support for hierarchical protection domains is typically implemented using CPU modes. Many kernels implement \"capabilities\", i.e., objects provided to user code that allow limited access to an underlying object managed by the kernel. A common example is file handling: a file is a representation of information stored on a permanent storage device. The kernel may be able to perform many different operations, including read, write, delete or execute, but a user-level application may only be permitted to perform some of these operations (e.g., it may only be allowed to read the file). A common implementation of this is for the kernel to provide an object to the application (typically so called a \"file handle\") which the application may then invoke operations on, the validity of which the kernel checks at the time the operation is requested. Such a system may be extended to cover all objects that the kernel manages, and indeed to objects provided by other user applications. An efficient and simple way to provide hardware support of capabilities is to delegate to the memory management unit (MMU) the responsibility of checking access-rights for every memory access, a mechanism called capability-based addressing. Most commercial computer architectures lack such MMU support for capabilities. An alternative approach is to simulate capabilities using commonly supported hierarchical domains. In this approach, each protected object must reside in an address space that the application does not have access to; the kernel also maintains a list of capabilities in such memory. When an application needs to access an object protected by a capability, it performs a system call and the kernel then checks whether the application's capability grants it permission to perform the requested action, and if it is permitted performs the access for it (either directly, or by delegating the request to another user-level process). The performance cost of address space switching limits the practicality of this approach in systems with complex interactions between objects, but it is used in current operating systems for objects that are not accessed frequently or which are not expected to perform quickly. If the firmware does not support protection mechanisms, it is possible to simulate protection at a higher level, for example by simulating capabilities by manipulating page tables, but there are performance implications. Lack of hardware support may not be an issue, however, for systems that choose to use language-based protection. An important kernel design decision is the choice of the abstraction levels where the security mechanisms and policies should be implemented. Kernel security mechanisms play a critical role in supporting security at higher levels. One approach is to use firmware and kernel support for fault tolerance (see above), and build the security policy for malicious behavior on top of that (adding features such as cryptography mechanisms where necessary), delegating some responsibility to the compiler. Approaches that delegate enforcement of security policy to the compiler and/or the application level are often called language-based security. The lack of many critical security mechanisms in current mainstream operating systems impedes the implementation of adequate security policies at the application abstraction level. In fact, a common misconception in computer security is that any security policy can be implemented in an application regardless of kernel support. According to Mars Research Group developers, a lack of isolation is one of the main factors undermining kernel security. They propose their driver isolation framework for protection, primarily in the Linux kernel. ==== Hardware- or language-based protection ==== Typical computer systems today use hardware-enforced rules about what programs are allowed to access what data. The processor monitors the execution and stops a program that violates a rule, such as a user process that tries to write to kernel memory. In systems that lack support for capabilities, processes are isolated from each other by using separate address spaces. Calls from user processes into the kernel are regulated by requiring them to use one of the above-described system call methods. An alternative approach is to use language-based protection. In a language-based protection system, the kernel will only allow code to execute that has been produced by a trusted language compiler. The language may then be designed such that it is impossible for the programmer to instruct it to do something that will violate a security requirement. Advantages of this approach include: No need for separate address spaces. Switching between address spaces is a slow operation that causes a great deal of overhead, and a lot of optimization work is currently performed in order to prevent unnecessary switches in current operating systems. Switching is completely unnecessary in a language-based protection system, as all code can safely operate in the same address space. Flexibility. Any protection scheme that can be designed to be expressed via a programming language can be implemented using this method. Changes to the protection scheme (e.g. from a hierarchical system to a capability-based one) do not require new hardware. Disadvantages include: Longer application startup time. Applications must be verified when they are started to ensure they have been compiled by the correct compiler, or may need recompiling either from source code or from bytecode. Inflexible type systems. On traditional systems, applications frequently perform operations that are not type safe. Such operations cannot be permitted in a language-based protection system, which means that applications may need to be rewritten and may, in some cases, lose performance. Examples of systems with language-based protection include JX and Microsoft's Singularity. === Process cooperation === Edsger Dijkstra proved that from a logical point of view, atomic lock and unlock operations operating on binary semaphores are sufficient primitives to express any functionality of process cooperation. However this approach is generally held to be lacking in terms of safety and efficiency, whereas a message passing approach is more flexible. A number of other approaches (either lower- or higher-level) are available as well, with many modern kernels providing support for systems such as shared memory and remote procedure calls. === I/O device management === The idea of a kernel where I/O devices are handled uniformly with other processes, as parallel co-operating processes, was first proposed and implemented by Brinch Hansen (although similar ideas were suggested in 1967). In Hansen's description of this, the \"common\" processes are called internal processes, while the I/O devices are called external processes. Similar to physical memory, allowing applications direct access to controller ports and registers can cause the controller to malfunction, or system to crash. With this, depending on the complexity of the device, some devices can get surprisingly complex to program, and use several different controllers. Because of this, providing a more abstract interface to manage the device is important. This interface is normally done by a device driver or hardware abstraction layer. Frequently, applications will require access to these devices. The kernel must maintain the list of these devices by querying the system for them in some way. This can be done through the BIOS, or through one of the various system buses (such as PCI/PCIE, or USB). Using an example of a video driver, when an application requests an operation on a device, such as displaying a character, the kernel needs to send this request to the current active video driver. The video driver, in turn, needs to carry out this request. This is an example of inter-process communication (IPC). == Kernel-wide design approaches == The above listed tasks and features can be provided in many ways that differ from each other in design and implementation. The principle of separation of mechanism and policy is the substantial difference between the two main philosophies of microkernels and monolithic kernels. Here a mechanism is the support that allows the implementation of many different policies, while a policy is a particular \"mode of operation\". Example: Mechanism: User login attempts are routed to an authorization server Policy: Authorization server requires a password which is verified against stored passwords in a database Because the mechanism and policy are separated, the policy can be easily changed to, e.g., require the use of a security token. In a minimal microkernel just some very basic policies are included, and its mechanisms allow what is running on top of the kernel (the remaining part of the operating system and the other applications) to decide which policies to adopt (such as for memory management, high level process scheduling, file system management, etc.). A monolithic kernel instead tends to include many policies, therefore restricting the rest of the system to rely on them. Computer scientist Per Brinch Hansen argued in favour of separation of mechanism and policy. The failure to properly fulfill this separation is one of the major causes of the lack of substantial innovation in existing operating systems, a problem common in computer architecture. The monolithic design is induced by the \"kernel mode\"/\"user mode\" architectural approach to protection (technically called hierarchical protection domains), which is common in conventional commercial systems; in fact, every module needing protection is therefore preferably included into the kernel. This link between monolithic design and \"privileged mode\" can be reconducted to the key issue of mechanism-policy separation; in fact the \"privileged mode\" architectural approach melds together the protection mechanism with the security policies, while the major alternative architectural approach, capability-based addressing, clearly distinguishes between the two, leading naturally to a microkernel design. While monolithic kernels execute all of their code in the same address space (kernel space), microkernels try to run most of their services in user space, aiming to improve maintainability and modularity of their codebase. Most kernels do not fit exactly into one of these categories, but are rather found in between these two designs. These are called hybrid kernels. More exotic designs such as nanokernels and exokernels are available, but are seldom used for production systems. The Xen hypervisor, for example, is an exokernel. === Monolithic kernels === In a monolithic kernel, all OS services are part of the kernel and run in kernel mode, thus also residing in the same memory area. This approach provides rich and powerful hardware access. UNIX developer Ken Thompson stated that \"it is in [his] opinion easier to implement a monolithic kernel\". The main disadvantages of monolithic kernels are the dependencies between system components – a bug in a device driver might crash the entire system, for example – and the fact that large kernels can become very difficult to maintain. Thompson also stated that \"It is also easier for [a monolithic kernel] to turn into a mess in a hurry as it is modified\". Monolithic kernels, which have traditionally been used by Unix-like operating systems, contain all the operating system core functions and the device drivers. A monolithic kernel is one single program that contains all of the code necessary to perform every kernel-related task. Every part which is to be accessed by a program which cannot be put in a library is in the kernel space, including drivers, schedulers, memory management, file systems, and network stacks. Many system calls are provided to applications, to allow them to access all those services. A monolithic kernel, while initially loaded with subsystems that may not be needed, can be tuned to a point where it is as fast as or faster than one that was specifically designed for the hardware, although more relevant in a general sense. Modern monolithic kernels, such as the Linux kernel, the FreeBSD kernel, the AIX kernel, the HP-UX kernel, and the Solaris kernel, all of which fall into the category of Unix-like operating systems, support loadable kernel modules, allowing modules to be loaded into the kernel at runtime, permitting easy extension of the kernel's capabilities as required, while helping to minimize the amount of code running in kernel space. Most work in the monolithic kernel is done via system calls. These are interfaces, usually kept in a tabular structure, that access some subsystem within the kernel, such as disk operations. Essentially, calls are made within programs and a checked copy of the request is passed through the system call. Hence, not far to travel at all. The monolithic Linux kernel can be made extremely small not only because of its ability to dynamically load modules but also because of its ease of customization. In fact, there are some versions that are small enough to fit together with a large number of utilities and other programs on a single floppy disk and still provide a fully functional operating system (one of the most popular of which is muLinux). This ability to miniaturize its kernel has also led to a rapid growth in the use of Linux in embedded systems. These types of kernels consist of the core functions of the operating system and the device drivers with the ability to load modules at runtime. They provide rich and powerful abstractions of the underlying hardware. They provide a small set of simple hardware abstractions and use applications called servers to provide more functionality. This particular approach defines a high-level virtual interface over the hardware, with a set of system calls to implement operating system services such as process management, concurrency and memory management in several modules that run in supervisor mode. This design has several flaws and limitations: Coding in kernel can be challenging, in part because one cannot use common libraries (like a full-featured libc), and because one needs to use a source-level debugger like gdb. Rebooting the computer is often required. This is not just a problem of convenience to the developers. When debugging is harder, and as difficulties become stronger, it becomes more likely that code will be \"buggier\". Bugs in one part of the kernel have strong side effects; since every function in the kernel has all the privileges, a bug in one function can corrupt data structures of another, totally unrelated part of the kernel, or of any running program. Kernels often become very large and difficult to maintain. Even if the modules servicing these operations are separate from the whole, the code integration is tight and difficult to do correctly. Since the modules run in the same address space, a bug can bring down the entire system. === Microkernels === Microkernel (also abbreviated μK or uK) is the term describing an approach to operating system design by which the functionality of the system is moved out of the traditional \"kernel\", into a set of \"servers\" that communicate through a \"minimal\" kernel, leaving as little as possible in \"system space\" and as much as possible in \"user space\". A microkernel that is designed for a specific platform or device is only ever going to have what it needs to operate. The microkernel approach consists of defining a simple abstraction over the hardware, with a set of primitives or system calls to implement minimal OS services such as memory management, multitasking, and inter-process communication. Other services, including those normally provided by the kernel, such as networking, are implemented in user-space programs, referred to as servers. Microkernels are easier to maintain than monolithic kernels, but the large number of system calls and context switches might slow down the system because they typically generate more overhead than plain function calls. Only parts which really require being in a privileged mode are in kernel space, such as IPC (Inter-Process Communication), a basic scheduler or scheduling primitives, basic memory handling, and basic I/O primitives. Many critical parts are now running in user space, including the complete scheduler, memory handling, file systems, and network stacks. Microkernels were invented as a reaction to traditional \"monolithic\" kernel design, whereby all system functionality was put in one static program running in a special \"system\" mode of the processor. In the microkernel, only the most fundamental of tasks are performed at this level, such as being able to access some (not necessarily all) of the hardware, manage memory and coordinate message passing between the processes. Some systems that use microkernels are QNX and GNU Hurd. In the case of QNX and GNU Hurd, user sessions can be entire snapshots of the system itself, or \"views\" as it is referred to. The very essence of the microkernel architecture illustrates some of its advantages: Easier to maintain Patches can be tested in a separate instance, and then swapped in to take over a production instance. Rapid development time and new software can be tested without having to reboot the kernel. More persistence in general: if one instance goes haywire, it is often possible to substitute it with an operational mirror. Most microkernels use a message passing system to handle requests from one server to another. The message passing system generally operates on a port basis with the microkernel. As an example, if a request for more memory is sent, a port is opened with the microkernel and the request sent through. Once within the microkernel, the steps are similar to system calls. The rationale was that it would bring modularity in the system architecture, which would entail a cleaner system that is easier to debug or dynamically modify, customizable to users' needs, and higher performing. Microkernels are part of operating systems like GNU Hurd, MINIX, MkLinux, QNX and Redox OS. Although microkernels are very small by themselves, in combination with all their required auxiliary code they are, in fact, often larger than monolithic kernels. Advocates of monolithic kernels also point out that the two-tiered structure of microkernel systems, in which most of the operating system does not interact directly with the hardware, creates a not-insignificant cost in terms of system efficiency. These types of kernels normally provide only the minimal services such as defining memory address spaces, inter-process communication (IPC) and process management. Other functions, such as running hardware processes, are not handled directly by microkernels. Proponents of microkernels point out those monolithic kernels have the disadvantage that an error in the kernel can cause the entire system to crash. However, with a microkernel, if a kernel process crashes, it is still possible to prevent a crash of the system as a whole by merely restarting the service that caused the error. Other services provided by the kernel such as networking are implemented in user-space programs referred to as servers. Servers allow the operating system to be modified by simply starting and stopping programs. For a machine without networking support, for instance, the networking server is not started. The task of moving in and out of the kernel to move data between the various applications and servers creates overhead which is detrimental to the efficiency of microkernels in comparison with monolithic kernels. Disadvantages in the microkernel exist however. Some are: Larger running memory footprint More software for interfacing is required, so there is a potential for performance loss. Messaging bugs can be harder to fix due to the longer trip they have to take, versus the one-off copy in a monolithic kernel. Process management in general can be very complicated. The disadvantages for microkernels are extremely context-based. As an example, they work well for small single-purpose (and critical) systems because if not many processes need to run, then the complications of process management are effectively mitigated. A microkernel allows the implementation of the remaining part of the operating system as programs running in user mode, and the use of different operating systems on top of the same unchanged kernel. It is also possible to dynamically switch among operating systems and to have more than one active simultaneously. === Monolithic kernels vs. microkernels === As the computer kernel grows, so grows the size and vulnerability of its trusted computing base, in addition to its memory footprint. This is mitigated to some degree by perfecting a virtual memory system, but not all computer architectures have virtual memory support. To reduce the kernel's footprint, extensive editing has to be performed to carefully remove unneeded code, which can be very difficult with non-obvious interdependencies between parts of a kernel with millions of lines of code. By the early 1990s, due to the various shortcomings of monolithic kernels versus microkernels, monolithic kernels were considered obsolete by virtually all operating system researchers. As a result, the design of Linux as a monolithic kernel rather than a microkernel was the topic of a famous debate between Linus Torvalds and Andrew Tanenbaum. There is merit on both sides of the argument presented in the Tanenbaum–Torvalds debate. ==== Performance ==== Monolithic kernels are designed to have all of their code in the same address space (kernel space), which some developers argue is necessary to increase the performance of the system. Some developers also maintain that monolithic systems are extremely efficient if well written. The monolithic model tends to be more efficient through the use of shared kernel memory, rather than the slower IPC system of microkernel designs, which is typically based on message passing. The performance of microkernels was poor in both the 1980s and early 1990s. However, studies that empirically measured the performance of these microkernels did not analyze the reasons of such inefficiency. The explanations of this data were left to \"folklore\", with the assumption that they were due to the increased frequency of switches from \"kernel-mode\" to \"user-mode\", to the increased frequency of inter-process communication and to the increased frequency of context switches. In fact, as guessed in 1995, the reasons for the poor performance of microkernels might as well have been: (1) an actual inefficiency of the whole microkernel approach, (2) the particular concepts implemented in those microkernels, and (3) the particular implementation of those concepts. Therefore it remained to be studied if the solution to build an efficient microkernel was, unlike previous attempts, to apply the correct construction techniques. On the other end, the hierarchical protection domains architecture that leads to the design of a monolithic kernel has a significant performance drawback each time there's an interaction between different levels of protection (i.e., when a process has to manipulate a data structure both in \"user mode\" and \"supervisor mode\"), since this requires message copying by value. === Hybrid (or modular) kernels === Hybrid kernels are used in some commercial operating systems, including most versions of Microsoft Windows to date (NT 3.1, NT 3.5, NT 3.51, NT 4.0, 2000, XP, Vista, 7, 8, 8.1, 10 and 11). Apple's macOS uses a hybrid kernel called XNU, which is based upon code from OSF/1's Mach kernel (OSFMK 7.3) and FreeBSD's monolithic kernel. Hybrid kernels are similar to microkernels, except they include some additional code in kernel-space to increase performance. These kernels represent a compromise that was implemented by some developers to accommodate the major advantages of both monolithic and microkernels. These types of kernels are extensions of microkernels with some properties of monolithic kernels. Unlike monolithic kernels, these types of kernels are unable to load modules at runtime on their own. This implies running some services (such as the network stack or the filesystem) in kernel space to reduce the performance overhead of a traditional microkernel, but still running kernel code (such as device drivers) as servers in user space. Many traditionally monolithic kernels support loadable kernel modules. The most well known of these kernels is the Linux kernel. The modular kernel essentially can have parts of it that are built into the core kernel binary or binaries that load into memory on demand. A code-tainted module has the potential to destabilize a running kernel. By contrast, it is possible to write a driver for a microkernel in a completely separate memory space and test it before \"going\" live. When a kernel module is loaded, it accesses the monolithic portion's memory space by adding to it what it needs, therefore opening the doorway to possible pollution. A few advantages to the modular (or) hybrid kernel are: Faster development time for drivers that can operate from within modules. No reboot required for testing (provided the kernel is not destabilized). On demand capability versus spending time recompiling a whole kernel for things like new drivers or subsystems. Faster integration of third party technology (related to development but pertinent unto itself nonetheless). Modules, generally, communicate with the kernel using a module interface of some sort. The interface is generalized (although particular to a given operating system) so it is not always possible to use modules. Often the device drivers may need more flexibility than the module interface affords. Essentially, it is two system calls and often the safety checks that only have to be done once in the monolithic kernel now may be done twice. Some of the disadvantages of the modular approach are: With more interfaces to pass through, the possibility of increased bugs exists (which implies more security holes). Maintaining modules can be confusing for some administrators when dealing with problems like symbol differences. === Nanokernels === A nanokernel delegates virtually all services – including even the most basic ones like interrupt controllers or the timer – to device drivers to make the kernel memory requirement even smaller than a traditional microkernel. === Exokernels === Exokernels are a still-experimental approach to operating system design. They differ from other types of kernels in limiting their functionality to the protection of and multiplexing of access to the raw hardware, providing no hardware abstractions on top of which to develop applications. This separation of hardware protection from hardware management enables application developers to determine how to make the most efficient use of the available hardware for each specific program. Exokernels in themselves are extremely small. However, they are accompanied by library operating systems (see also unikernel), providing application developers with the functionalities of a conventional operating system. A major advantage of exokernel-based systems is that they can incorporate multiple library operating systems, each exporting a different API, for example one for high level UI development and one for real-time control. === Multikernels === A multikernel operating system treats a multi-core machine as a network of independent cores, as if it were a distributed system. It does not assume shared memory but rather implements inter-process communications as message passing. Barrelfish was the first operating system to be described as a multikernel. == History of kernel development == === Early operating system kernels === Strictly speaking, an operating system (and thus, a kernel) is not required to run a computer. Programs can be directly loaded and executed on the \"bare metal\" machine, provided that the authors of those programs are willing to work without any hardware abstraction or operating system support. Most early computers operated this way during the 1950s and early 1960s, which were reset and reloaded between the execution of different programs. Eventually, small ancillary programs such as program loaders and debuggers were left in memory between runs, or loaded from ROM. As these were developed, they formed the basis of what became early operating system kernels. The \"bare metal\" approach is still used today on some video game consoles and embedded systems, but in general, newer computers use modern operating systems and kernels. In 1969, the RC 4000 Multiprogramming System introduced the system design philosophy of a small nucleus \"upon which operating systems for different purposes could be built in an orderly manner\", what would be called the microkernel approach. === Time-sharing operating systems === In the decade preceding Unix, computers had grown enormously in power – to the point where computer operators were looking for new ways to get people to use their spare time on their machines. One of the major developments during this era was time-sharing, whereby a number of users would get small slices of computer time, at a rate at which it appeared they were each connected to their own, slower, machine. The development of time-sharing systems led to a number of problems. One was that users, particularly at universities where the systems were being developed, seemed to want to hack the system to get more CPU time. For this reason, security and access control became a major focus of the Multics project in 1965. Another ongoing issue was properly handling computing resources: users spent most of their time staring at the terminal and thinking about what to input instead of actually using the resources of the computer, and a time-sharing system should give the CPU time to an active user during these periods. Finally, the systems typically offered a memory hierarchy several layers deep, and partitioning this expensive resource led to major developments in virtual memory systems. === Amiga === The Commodore Amiga was released in 1985, and was among the first – and certainly most successful – home computers to feature an advanced kernel architecture. The AmigaOS kernel's executive component, exec.library, uses a microkernel message-passing design, but there are other kernel components, like graphics.library, that have direct access to the hardware. There is no memory protection, and the kernel is almost always running in user mode. Only special actions are executed in kernel mode, and user-mode applications can ask the operating system to execute their code in kernel mode. === Unix === During the design phase of Unix, programmers decided to model every high-level device as a file, because they believed the purpose of computation was data transformation. For instance, printers were represented as a \"file\" at a known location – when data was copied to the file, it printed out. Other systems, to provide a similar functionality, tended to virtualize devices at a lower level – that is, both devices and files would be instances of some lower level concept. Virtualizing the system at the file level allowed users to manipulate the entire system using their existing file management utilities and concepts, dramatically simplifying operation. As an extension of the same paradigm, Unix allows programmers to manipulate files using a series of small programs, using the concept of pipes, which allowed users to complete operations in stages, feeding a file through a chain of single-purpose tools. Although the end result was the same, using smaller programs in this way dramatically increased flexibility as well as ease of development and use, allowing the user to modify their workflow by adding or removing a program from the chain. In the Unix model, the operating system consists of two parts: first, the huge collection of utility programs that drive most operations; second, the kernel that runs the programs. Under Unix, from a programming standpoint, the distinction between the two is fairly thin; the kernel is a program, running in supervisor mode, that acts as a program loader and supervisor for the small utility programs making up the rest of the system, and to provide locking and I/O services for these programs; beyond that, the kernel didn't intervene at all in user space. Over the years the computing model changed, and Unix's treatment of everything as a file or byte stream no longer was as universally applicable as it was before. Although a terminal could be treated as a file or a byte stream, which is printed to or read from, the same did not seem to be true for a graphical user interface. Networking posed another problem. Even if network communication can be compared to file access, the low-level packet-oriented architecture dealt with discrete chunks of data and not with whole files. As the capability of computers grew, Unix became increasingly cluttered with code. It is also because the modularity of the Unix kernel is extensively scalable. While kernels might have had 100,000 lines of code in the seventies and eighties, kernels like Linux, of modern Unix successors like GNU, have more than 13 million lines. Modern Unix-derivatives are generally based on module-loading monolithic kernels. Examples of this are the Linux kernel in the many distributions of GNU, IBM AIX, as well as the Berkeley Software Distribution variant kernels such as FreeBSD, DragonFly BSD, OpenBSD, NetBSD, and macOS. Apart from these alternatives, amateur developers maintain an active operating system development community, populated by self-written hobby kernels which mostly end up sharing many features with Linux, FreeBSD, DragonflyBSD, OpenBSD or NetBSD kernels and/or being compatible with them. === Classic Mac OS and macOS === Apple first launched its classic Mac OS in 1984, bundled with its Macintosh personal computer. Apple moved to a nanokernel design in Mac OS 8.6. Against this, the modern macOS (originally named Mac OS X) is based on Darwin, which uses a hybrid kernel called XNU, which was created by combining the 4.3BSD kernel and the Mach kernel. === Microsoft Windows === Microsoft Windows was first released in 1985 as an add-on to MS-DOS. Because of its dependence on another operating system, initial releases of Windows, prior to Windows 95, were considered an operating environment (not to be confused with an operating system). This product line continued to evolve through the 1980s and 1990s, with the Windows 9x series adding 32-bit addressing and pre-emptive multitasking; but ended with the release of Windows Me in 2000. Microsoft also developed Windows NT, an operating system with a very similar interface, but intended for high-end and business users. This line started with the release of Windows NT 3.1 in 1993, and was introduced to general users with the release of Windows XP in October 2001—replacing Windows 9x with a completely different, much more sophisticated operating system. This is the line that continues with Windows 11. The architecture of Windows NT's kernel is considered a hybrid kernel because the kernel itself contains tasks such as the Window Manager and the IPC Managers, with a client/server layered subsystem model. It was designed as a modified microkernel, as the Windows NT kernel was influenced by the Mach microkernel but does not meet all of the criteria of a pure microkernel. === IBM Supervisor === Supervisory program or supervisor is a computer program, usually part of an operating system, that controls the execution of other routines and regulates work scheduling, input/output operations, error actions, and similar functions and regulates the flow of work in a data processing system. Historically, this term was essentially associated with IBM's line of mainframe operating systems starting with OS/360. In other operating systems, the supervisor is generally called the kernel. In the 1970s, IBM further abstracted the supervisor state from the hardware, resulting in a hypervisor that enabled full virtualization, i.e. the capacity to run multiple operating systems on the same machine totally independently from each other. Hence the first such system was called Virtual Machine or VM. === Development of microkernels === Although Mach, developed by Richard Rashid at Carnegie Mellon University, is the best-known general-purpose microkernel, other microkernels have been developed with more specific aims. The L4 microkernel family (mainly the L3 and the L4 kernel) was created to demonstrate that microkernels are not necessarily slow. Newer implementations such as Fiasco and Pistachio are able to run Linux next to other L4 processes in separate address spaces. Additionally, QNX is a microkernel which is principally used in embedded systems, and the open-source software MINIX, while originally created for educational purposes, is now focused on being a highly reliable and self-healing microkernel OS. == See also == Comparison of operating system kernels Inter-process communication Operating system Virtual memory == Notes == == References == == Sources == == Further reading == Andrew S. Tanenbaum, Albert S. Woodhull, Operating Systems: Design and Implementation (Third edition); Andrew S. Tanenbaum, Herbert Bos, Modern Operating Systems (Fourth edition); Daniel P. Bovet, Marco Cesati, Understanding the Linux Kernel (Third edition); David A. Patterson, John L. Hennessy, Computer Organization and Design (Sixth edition), Morgan Kaufmann (ISBN 978-0-12-820109-1); B.S. Chalk, A.T. Carter, R.W. Hind, Computer Organisation and Architecture: An Introduction (Second edition), Palgrave Macmillan (ISBN 978-1-4039-0164-4). == External links == Detailed comparison between most popular operating system kernels The Barrelfish Operating System"
  },
  "chunks": [
    {
      "id": "kerneloperatingsyste_beac728d_c0000",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 948,
      "content": "A kernel is a computer program at the core of a computer's operating system that always has complete control over everything in the system. The kernel is also responsible for preventing and mitigating conflicts between different processes. It is the portion of the operating system code that is always resident in memory and facilitates interactions between hardware and software components. A full kernel controls all hardware resources (e.g. I/O, memory, cryptography) via device drivers, arbitrates conflicts between processes concerning such resources, and optimizes the use of common resources, such as CPU, cache, file systems, and network sockets. On most systems, the kernel is one of the first programs loaded on startup (after the bootloader). It handles the rest of startup as well as memory, peripherals, and input/output (I/O) requests from software, translating them into data-processing instructions for the central processing unit.",
      "char_count": 947,
      "token_estimate": 236,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0001",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 948,
      "end_char": 1899,
      "content": "The critical code of the kernel is usually loaded into a separate area of memory, which is protected from access by application software or other less critical parts of the operating system. The kernel performs its tasks, such as running processes, managing hardware devices such as the hard disk, and handling interrupts, in this protected kernel space. In contrast, application programs such as browsers, word processors, or audio or video players use a separate area of memory, user space. This prevents user data and kernel data from interfering with each other and causing instability and slowness, as well as preventing malfunctioning applications from affecting other applications or crashing the entire operating system. Even in systems where the kernel is included in application address spaces, memory protection is used to prevent unauthorized applications from modifying the kernel. The kernel's interface is a low-level abstraction layer.",
      "char_count": 951,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0002",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 1900,
      "end_char": 2734,
      "content": "When a process requests a service from the kernel, it must invoke a system call, usually through a wrapper function. There are different kernel architecture designs. Monolithic kernels run entirely in a single address space with the CPU executing in supervisor mode, mainly for speed. Microkernels run most but not all of their services in user space, like user processes do, mainly for resilience and modularity. MINIX 3 is a notable example of microkernel design. Some kernels, such as the Linux kernel, are both monolithic and modular, since they can insert and remove loadable kernel modules at runtime. This central component of a computer system is responsible for executing programs. The kernel takes responsibility for deciding at any time which of the many running programs should be allocated to the processor or processors.",
      "char_count": 834,
      "token_estimate": 208,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0003",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Random-access memory ==",
      "heading_path": "== Random-access memory ==",
      "start_char": 2761,
      "end_char": 3169,
      "content": "== Random-access memory == Random-access memory (RAM) is used to store both program instructions and data. Typically, both need to be present in memory for a program to execute. Often, multiple programs will want memory access, frequently demanding more memory than the computer has available. The kernel is responsible for deciding which memory each process can use, and determining what to do when insufficient memory is available.",
      "char_count": 433,
      "token_estimate": 108,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0004",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Input/output devices ==",
      "heading_path": "== Input/output devices ==",
      "start_char": 3195,
      "end_char": 3546,
      "content": "== Input/output devices == I/O devices include, but are not limited to, peripherals such as keyboards, mice, disk drives, printers, USB devices, network adapters, and display devices. The kernel provides convenient methods for applications to use these devices which are typically abstracted by the kernel so that applications do not need to know their implementation details.",
      "char_count": 376,
      "token_estimate": 94,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0005",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Resource management ==",
      "heading_path": "== Resource management ==",
      "start_char": 3571,
      "end_char": 4256,
      "content": "== Resource management == Key aspects necessary in resource management are defining the execution domain (address space) and the protection mechanism used to mediate access to the resources within a domain. Kernels also provide methods for synchronization and inter-process communication (IPC). These implementations may be located within the kernel itself or the kernel can also rely on other processes it is running. Although the kernel must provide IPC in order to provide access to the facilities provided by each other, kernels must also provide running programs with a method to make requests to access these facilities. The kernel is also responsible for context switching between processes or threads.",
      "char_count": 709,
      "token_estimate": 177,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0006",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Memory management ==",
      "heading_path": "== Memory management ==",
      "start_char": 4279,
      "end_char": 5117,
      "content": "== Memory management == The kernel has full access to the system's memory and must allow processes to safely access this memory as they require it. Often the first step in doing this is virtual addressing, usually achieved by paging and/or segmentation. Virtual addressing allows the kernel to make a given physical address appear to be another address, the virtual address. Virtual address spaces may be different for different processes; the memory that one process accesses at a particular (virtual) address may be different memory from what another process accesses at the same address. This allows every program to behave as if it is the only one (apart from the kernel) running and thus prevents applications from crashing each other. On many systems, a program's virtual address may refer to data which is not currently in memory.",
      "char_count": 837,
      "token_estimate": 209,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0007",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Memory management ==",
      "heading_path": "== Memory management ==",
      "start_char": 5117,
      "end_char": 6001,
      "content": "The layer of indirection provided by virtual addressing allows the operating system to use other data stores, like a hard drive, to store what would otherwise have to remain in main memory (RAM). As a result, operating systems can allow programs to use more memory than the system has physically available. When a program needs data which is not currently in RAM, the CPU signals to the kernel that this has happened, and the kernel responds by writing the contents of an inactive memory block to disk (if necessary) and replacing it with the data requested by the program. The program can then be resumed from the point where it was stopped. This scheme is generally known as demand paging. Virtual addressing also allows creation of virtual partitions of memory in two disjoint areas, one being reserved for the kernel (kernel space) and the other for the applications (user space).",
      "char_count": 884,
      "token_estimate": 221,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0008",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Memory management ==",
      "heading_path": "== Memory management ==",
      "start_char": 6002,
      "end_char": 6380,
      "content": "The applications are not permitted by the processor to address kernel memory, thus preventing an application from damaging the running kernel. This fundamental partition of memory space has contributed much to the current designs of actual general-purpose kernels and is almost universal in such systems, although some research kernels (e.g., Singularity) take other approaches.",
      "char_count": 378,
      "token_estimate": 94,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0009",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Device management ==",
      "heading_path": "== Device management ==",
      "start_char": 6381,
      "end_char": 7303,
      "content": "== Device management == To perform useful functions, processes need access to the peripherals connected to the computer, which are controlled by the kernel through device drivers. A device driver is a computer program encapsulating, monitoring and controlling a hardware device (via its hardware/software interface (HSI)) on behalf of the OS. It provides the operating system with an API, procedures and information about how to control and communicate with a certain piece of hardware. Device drivers are an important and vital dependency for all OS and their applications. The design goal of a driver is abstraction; the function of the driver is to translate the OS-mandated abstract function calls (programming calls) into device-specific calls. In theory, a device should work correctly with a suitable driver. Device drivers are used for e.g. video cards, sound cards, printers, scanners, modems, and Network cards.",
      "char_count": 921,
      "token_estimate": 230,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0010",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Device management ==",
      "heading_path": "== Device management ==",
      "start_char": 7303,
      "end_char": 8152,
      "content": "At the hardware level, common abstractions of device drivers include: Interfacing directly Using a high-level interface (Video BIOS) Using a lower-level device driver (file drivers using disk drivers) Simulating work with hardware, while doing something entirely different And at the software level, device driver abstractions include: Allowing the operating system direct access to hardware resources Only implementing primitives Implementing an interface for non-driver software such as TWAIN Implementing a language (often a high-level language such as PostScript) For example, to show the user something on the screen, an application would make a request to the kernel, which would forward the request to its display driver, which is then responsible for actually plotting the character/pixel. A kernel must maintain a list of available devices.",
      "char_count": 849,
      "token_estimate": 212,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0011",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Device management ==",
      "heading_path": "== Device management ==",
      "start_char": 8153,
      "end_char": 8976,
      "content": "This list may be known in advance (e.g., on an embedded system where the kernel will be rewritten if the available hardware changes), configured by the user (typical on older PCs and on systems that are not designed for personal use) or detected by the operating system at run time (normally called plug and play). In plug-and-play systems, a device manager first performs a scan on different peripheral buses, such as Peripheral Component Interconnect (PCI) or Universal Serial Bus (USB), to detect installed devices, then searches for the appropriate drivers. As device management is a very OS-specific topic, these drivers are handled differently by each kind of kernel design, but in every case, the kernel has to provide the I/O to allow drivers to physically access their devices through some port or memory location.",
      "char_count": 823,
      "token_estimate": 205,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0012",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Device management ==",
      "heading_path": "== Device management ==",
      "start_char": 8977,
      "end_char": 9210,
      "content": "Important decisions have to be made when designing the device management system, as in some designs accesses may involve context switches, making the operation very CPU-intensive and easily causing a significant performance overhead.",
      "char_count": 233,
      "token_estimate": 58,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0013",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== System calls ==",
      "heading_path": "== System calls ==",
      "start_char": 9206,
      "end_char": 10181,
      "content": "== System calls == In computing, a system call is how a process requests a service from an operating system's kernel that it does not normally have permission to run. System calls provide the interface between a process and the operating system. Most operations interacting with the system require permissions not available to a user-level process, e.g., I/O performed with a device present on the system, or any form of communication with other processes requires the use of system calls. A system call is a mechanism that is used by the application program to request a service from the operating system. They use a machine-code instruction that causes the processor to change mode. An example would be from supervisor mode to protected mode. This is where the operating system performs actions like accessing hardware devices or the memory management unit. Generally the operating system provides a library that sits between the operating system and normal user programs.",
      "char_count": 974,
      "token_estimate": 243,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0014",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== System calls ==",
      "heading_path": "== System calls ==",
      "start_char": 10181,
      "end_char": 11166,
      "content": "Usually it is a C library such as Glibc or Windows API. The library handles the low-level details of passing information to the kernel and switching to supervisor mode. System calls include close, open, read, wait and write. To actually perform useful work, a process must be able to access the services provided by the kernel. This is implemented differently by each kernel, but most provide a C library or an API, which in turn invokes the related kernel functions. The method of invoking the kernel function varies from kernel to kernel. If memory isolation is in use, it is impossible for a user process to call the kernel directly, because that would be a violation of the processor's access control rules. A few possibilities are: Using a software-simulated interrupt. This method is available on most hardware, and is therefore very common. Using a call gate. A call gate is a special address stored by the kernel in a list in kernel memory at a location known to the processor.",
      "char_count": 985,
      "token_estimate": 246,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0015",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== System calls ==",
      "heading_path": "== System calls ==",
      "start_char": 11167,
      "end_char": 11899,
      "content": "When the processor detects a call to that address, it instead redirects to the target location without causing an access violation. This requires hardware support, but the hardware for it is quite common. Using a special system call instruction. This technique requires special hardware support, which common architectures (notably, x86) may lack. System call instructions have been added to recent models of x86 processors, however, and some operating systems for PCs make use of them when available. Using a memory-based queue. An application that makes large numbers of requests but does not need to wait for the result of each may add details of requests to an area of memory that the kernel periodically scans to find requests.",
      "char_count": 732,
      "token_estimate": 183,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0016",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Protection ==",
      "heading_path": "== = Protection ==",
      "start_char": 11930,
      "end_char": 12795,
      "content": "== = Protection === An important consideration in the design of a kernel is the support it provides for protection from faults (fault tolerance) and from malicious behaviours (security). These two aspects are usually not clearly distinguished, and the adoption of this distinction in the kernel design leads to the rejection of a hierarchical structure for protection. The mechanisms or policies provided by the kernel can be classified according to several criteria, including: static (enforced at compile time) or dynamic (enforced at run time); pre-emptive or post-detection; according to the protection principles they satisfy (e.g., Denning); whether they are hardware supported or language based; whether they are more an open mechanism or a binding policy; and many more. Support for hierarchical protection domains is typically implemented using CPU modes.",
      "char_count": 864,
      "token_estimate": 216,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0017",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Protection ==",
      "heading_path": "== = Protection ==",
      "start_char": 12795,
      "end_char": 13692,
      "content": "Many kernels implement \"capabilities\", i.e., objects provided to user code that allow limited access to an underlying object managed by the kernel. A common example is file handling: a file is a representation of information stored on a permanent storage device. The kernel may be able to perform many different operations, including read, write, delete or execute, but a user-level application may only be permitted to perform some of these operations (e.g., it may only be allowed to read the file). A common implementation of this is for the kernel to provide an object to the application (typically so called a \"file handle\") which the application may then invoke operations on, the validity of which the kernel checks at the time the operation is requested. Such a system may be extended to cover all objects that the kernel manages, and indeed to objects provided by other user applications.",
      "char_count": 897,
      "token_estimate": 224,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0018",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Protection ==",
      "heading_path": "== = Protection ==",
      "start_char": 13693,
      "end_char": 14640,
      "content": "An efficient and simple way to provide hardware support of capabilities is to delegate to the memory management unit (MMU) the responsibility of checking access-rights for every memory access, a mechanism called capability-based addressing. Most commercial computer architectures lack such MMU support for capabilities. An alternative approach is to simulate capabilities using commonly supported hierarchical domains. In this approach, each protected object must reside in an address space that the application does not have access to; the kernel also maintains a list of capabilities in such memory. When an application needs to access an object protected by a capability, it performs a system call and the kernel then checks whether the application's capability grants it permission to perform the requested action, and if it is permitted performs the access for it (either directly, or by delegating the request to another user-level process).",
      "char_count": 947,
      "token_estimate": 236,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0019",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Protection ==",
      "heading_path": "== = Protection ==",
      "start_char": 14641,
      "end_char": 15483,
      "content": "The performance cost of address space switching limits the practicality of this approach in systems with complex interactions between objects, but it is used in current operating systems for objects that are not accessed frequently or which are not expected to perform quickly. If the firmware does not support protection mechanisms, it is possible to simulate protection at a higher level, for example by simulating capabilities by manipulating page tables, but there are performance implications. Lack of hardware support may not be an issue, however, for systems that choose to use language-based protection. An important kernel design decision is the choice of the abstraction levels where the security mechanisms and policies should be implemented. Kernel security mechanisms play a critical role in supporting security at higher levels.",
      "char_count": 842,
      "token_estimate": 210,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0020",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Protection ==",
      "heading_path": "== = Protection ==",
      "start_char": 15484,
      "end_char": 16436,
      "content": "One approach is to use firmware and kernel support for fault tolerance (see above), and build the security policy for malicious behavior on top of that (adding features such as cryptography mechanisms where necessary), delegating some responsibility to the compiler. Approaches that delegate enforcement of security policy to the compiler and/or the application level are often called language-based security. The lack of many critical security mechanisms in current mainstream operating systems impedes the implementation of adequate security policies at the application abstraction level. In fact, a common misconception in computer security is that any security policy can be implemented in an application regardless of kernel support. According to Mars Research Group developers, a lack of isolation is one of the main factors undermining kernel security. They propose their driver isolation framework for protection, primarily in the Linux kernel.",
      "char_count": 952,
      "token_estimate": 238,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0021",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Process cooperation ==",
      "heading_path": "== = Process cooperation ==",
      "start_char": 16446,
      "end_char": 16981,
      "content": "== = Process cooperation === Edsger Dijkstra proved that from a logical point of view, atomic lock and unlock operations operating on binary semaphores are sufficient primitives to express any functionality of process cooperation. However this approach is generally held to be lacking in terms of safety and efficiency, whereas a message passing approach is more flexible. A number of other approaches (either lower- or higher-level) are available as well, with many modern kernels providing support for systems such as shared memory and remote procedure calls.",
      "char_count": 561,
      "token_estimate": 140,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0022",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = I/O device management ==",
      "heading_path": "== = I/O device management ==",
      "start_char": 17010,
      "end_char": 17940,
      "content": "== = I/O device management === The idea of a kernel where I/O devices are handled uniformly with other processes, as parallel co-operating processes, was first proposed and implemented by Brinch Hansen (although similar ideas were suggested in 1967). In Hansen's description of this, the \"common\" processes are called internal processes, while the I/O devices are called external processes. Similar to physical memory, allowing applications direct access to controller ports and registers can cause the controller to malfunction, or system to crash. With this, depending on the complexity of the device, some devices can get surprisingly complex to program, and use several different controllers. Because of this, providing a more abstract interface to manage the device is important. This interface is normally done by a device driver or hardware abstraction layer. Frequently, applications will require access to these devices.",
      "char_count": 929,
      "token_estimate": 232,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0023",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = I/O device management ==",
      "heading_path": "== = I/O device management ==",
      "start_char": 17940,
      "end_char": 18455,
      "content": "The kernel must maintain the list of these devices by querying the system for them in some way. This can be done through the BIOS, or through one of the various system buses (such as PCI/PCIE, or USB). Using an example of a video driver, when an application requests an operation on a device, such as displaying a character, the kernel needs to send this request to the current active video driver. The video driver, in turn, needs to carry out this request. This is an example of inter-process communication (IPC).",
      "char_count": 515,
      "token_estimate": 128,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0024",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Kernel-wide design approaches ==",
      "heading_path": "== Kernel-wide design approaches ==",
      "start_char": 18462,
      "end_char": 19232,
      "content": "== Kernel-wide design approaches == The above listed tasks and features can be provided in many ways that differ from each other in design and implementation. The principle of separation of mechanism and policy is the substantial difference between the two main philosophies of microkernels and monolithic kernels. Here a mechanism is the support that allows the implementation of many different policies, while a policy is a particular \"mode of operation\". Example: Mechanism: User login attempts are routed to an authorization server Policy: Authorization server requires a password which is verified against stored passwords in a database Because the mechanism and policy are separated, the policy can be easily changed to, e.g., require the use of a security token.",
      "char_count": 769,
      "token_estimate": 192,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0025",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Kernel-wide design approaches ==",
      "heading_path": "== Kernel-wide design approaches ==",
      "start_char": 19232,
      "end_char": 19964,
      "content": "In a minimal microkernel just some very basic policies are included, and its mechanisms allow what is running on top of the kernel (the remaining part of the operating system and the other applications) to decide which policies to adopt (such as for memory management, high level process scheduling, file system management, etc.). A monolithic kernel instead tends to include many policies, therefore restricting the rest of the system to rely on them. Computer scientist Per Brinch Hansen argued in favour of separation of mechanism and policy. The failure to properly fulfill this separation is one of the major causes of the lack of substantial innovation in existing operating systems, a problem common in computer architecture.",
      "char_count": 732,
      "token_estimate": 183,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0026",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Kernel-wide design approaches ==",
      "heading_path": "== Kernel-wide design approaches ==",
      "start_char": 19965,
      "end_char": 20897,
      "content": "The monolithic design is induced by the \"kernel mode\"/\"user mode\" architectural approach to protection (technically called hierarchical protection domains), which is common in conventional commercial systems; in fact, every module needing protection is therefore preferably included into the kernel. This link between monolithic design and \"privileged mode\" can be reconducted to the key issue of mechanism-policy separation; in fact the \"privileged mode\" architectural approach melds together the protection mechanism with the security policies, while the major alternative architectural approach, capability-based addressing, clearly distinguishes between the two, leading naturally to a microkernel design. While monolithic kernels execute all of their code in the same address space (kernel space), microkernels try to run most of their services in user space, aiming to improve maintainability and modularity of their codebase.",
      "char_count": 932,
      "token_estimate": 233,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0027",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== Kernel-wide design approaches ==",
      "heading_path": "== Kernel-wide design approaches ==",
      "start_char": 20898,
      "end_char": 21207,
      "content": "Most kernels do not fit exactly into one of these categories, but are rather found in between these two designs. These are called hybrid kernels. More exotic designs such as nanokernels and exokernels are available, but are seldom used for production systems. The Xen hypervisor, for example, is an exokernel.",
      "char_count": 309,
      "token_estimate": 77,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0028",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Monolithic kernels ==",
      "heading_path": "== = Monolithic kernels ==",
      "start_char": 21199,
      "end_char": 22158,
      "content": "== = Monolithic kernels === In a monolithic kernel, all OS services are part of the kernel and run in kernel mode, thus also residing in the same memory area. This approach provides rich and powerful hardware access. UNIX developer Ken Thompson stated that \"it is in [his] opinion easier to implement a monolithic kernel\". The main disadvantages of monolithic kernels are the dependencies between system components – a bug in a device driver might crash the entire system, for example – and the fact that large kernels can become very difficult to maintain. Thompson also stated that \"It is also easier for [a monolithic kernel] to turn into a mess in a hurry as it is modified\". Monolithic kernels, which have traditionally been used by Unix-like operating systems, contain all the operating system core functions and the device drivers. A monolithic kernel is one single program that contains all of the code necessary to perform every kernel-related task.",
      "char_count": 958,
      "token_estimate": 239,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0029",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Monolithic kernels ==",
      "heading_path": "== = Monolithic kernels ==",
      "start_char": 22158,
      "end_char": 23108,
      "content": "Every part which is to be accessed by a program which cannot be put in a library is in the kernel space, including drivers, schedulers, memory management, file systems, and network stacks. Many system calls are provided to applications, to allow them to access all those services. A monolithic kernel, while initially loaded with subsystems that may not be needed, can be tuned to a point where it is as fast as or faster than one that was specifically designed for the hardware, although more relevant in a general sense. Modern monolithic kernels, such as the Linux kernel, the FreeBSD kernel, the AIX kernel, the HP-UX kernel, and the Solaris kernel, all of which fall into the category of Unix-like operating systems, support loadable kernel modules, allowing modules to be loaded into the kernel at runtime, permitting easy extension of the kernel's capabilities as required, while helping to minimize the amount of code running in kernel space.",
      "char_count": 950,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0030",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Monolithic kernels ==",
      "heading_path": "== = Monolithic kernels ==",
      "start_char": 23109,
      "end_char": 23967,
      "content": "Most work in the monolithic kernel is done via system calls. These are interfaces, usually kept in a tabular structure, that access some subsystem within the kernel, such as disk operations. Essentially, calls are made within programs and a checked copy of the request is passed through the system call. Hence, not far to travel at all. The monolithic Linux kernel can be made extremely small not only because of its ability to dynamically load modules but also because of its ease of customization. In fact, there are some versions that are small enough to fit together with a large number of utilities and other programs on a single floppy disk and still provide a fully functional operating system (one of the most popular of which is muLinux). This ability to miniaturize its kernel has also led to a rapid growth in the use of Linux in embedded systems.",
      "char_count": 858,
      "token_estimate": 214,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0031",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Monolithic kernels ==",
      "heading_path": "== = Monolithic kernels ==",
      "start_char": 23968,
      "end_char": 24894,
      "content": "These types of kernels consist of the core functions of the operating system and the device drivers with the ability to load modules at runtime. They provide rich and powerful abstractions of the underlying hardware. They provide a small set of simple hardware abstractions and use applications called servers to provide more functionality. This particular approach defines a high-level virtual interface over the hardware, with a set of system calls to implement operating system services such as process management, concurrency and memory management in several modules that run in supervisor mode. This design has several flaws and limitations: Coding in kernel can be challenging, in part because one cannot use common libraries (like a full-featured libc), and because one needs to use a source-level debugger like gdb. Rebooting the computer is often required. This is not just a problem of convenience to the developers.",
      "char_count": 926,
      "token_estimate": 231,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0032",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Monolithic kernels ==",
      "heading_path": "== = Monolithic kernels ==",
      "start_char": 24895,
      "end_char": 25537,
      "content": "When debugging is harder, and as difficulties become stronger, it becomes more likely that code will be \"buggier\". Bugs in one part of the kernel have strong side effects; since every function in the kernel has all the privileges, a bug in one function can corrupt data structures of another, totally unrelated part of the kernel, or of any running program. Kernels often become very large and difficult to maintain. Even if the modules servicing these operations are separate from the whole, the code integration is tight and difficult to do correctly. Since the modules run in the same address space, a bug can bring down the entire system.",
      "char_count": 642,
      "token_estimate": 160,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0033",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Microkernels ==",
      "heading_path": "== = Microkernels ==",
      "start_char": 25532,
      "end_char": 26398,
      "content": "== = Microkernels === Microkernel (also abbreviated μK or uK) is the term describing an approach to operating system design by which the functionality of the system is moved out of the traditional \"kernel\", into a set of \"servers\" that communicate through a \"minimal\" kernel, leaving as little as possible in \"system space\" and as much as possible in \"user space\". A microkernel that is designed for a specific platform or device is only ever going to have what it needs to operate. The microkernel approach consists of defining a simple abstraction over the hardware, with a set of primitives or system calls to implement minimal OS services such as memory management, multitasking, and inter-process communication. Other services, including those normally provided by the kernel, such as networking, are implemented in user-space programs, referred to as servers.",
      "char_count": 865,
      "token_estimate": 216,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0034",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Microkernels ==",
      "heading_path": "== = Microkernels ==",
      "start_char": 26398,
      "end_char": 27393,
      "content": "Microkernels are easier to maintain than monolithic kernels, but the large number of system calls and context switches might slow down the system because they typically generate more overhead than plain function calls. Only parts which really require being in a privileged mode are in kernel space, such as IPC (Inter-Process Communication), a basic scheduler or scheduling primitives, basic memory handling, and basic I/O primitives. Many critical parts are now running in user space, including the complete scheduler, memory handling, file systems, and network stacks. Microkernels were invented as a reaction to traditional \"monolithic\" kernel design, whereby all system functionality was put in one static program running in a special \"system\" mode of the processor. In the microkernel, only the most fundamental of tasks are performed at this level, such as being able to access some (not necessarily all) of the hardware, manage memory and coordinate message passing between the processes.",
      "char_count": 995,
      "token_estimate": 248,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0035",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Microkernels ==",
      "heading_path": "== = Microkernels ==",
      "start_char": 27394,
      "end_char": 28365,
      "content": "Some systems that use microkernels are QNX and GNU Hurd. In the case of QNX and GNU Hurd, user sessions can be entire snapshots of the system itself, or \"views\" as it is referred to. The very essence of the microkernel architecture illustrates some of its advantages: Easier to maintain Patches can be tested in a separate instance, and then swapped in to take over a production instance. Rapid development time and new software can be tested without having to reboot the kernel. More persistence in general: if one instance goes haywire, it is often possible to substitute it with an operational mirror. Most microkernels use a message passing system to handle requests from one server to another. The message passing system generally operates on a port basis with the microkernel. As an example, if a request for more memory is sent, a port is opened with the microkernel and the request sent through. Once within the microkernel, the steps are similar to system calls.",
      "char_count": 971,
      "token_estimate": 242,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0036",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Microkernels ==",
      "heading_path": "== = Microkernels ==",
      "start_char": 28366,
      "end_char": 29341,
      "content": "The rationale was that it would bring modularity in the system architecture, which would entail a cleaner system that is easier to debug or dynamically modify, customizable to users' needs, and higher performing. Microkernels are part of operating systems like GNU Hurd, MINIX, MkLinux, QNX and Redox OS. Although microkernels are very small by themselves, in combination with all their required auxiliary code they are, in fact, often larger than monolithic kernels. Advocates of monolithic kernels also point out that the two-tiered structure of microkernel systems, in which most of the operating system does not interact directly with the hardware, creates a not-insignificant cost in terms of system efficiency. These types of kernels normally provide only the minimal services such as defining memory address spaces, inter-process communication (IPC) and process management. Other functions, such as running hardware processes, are not handled directly by microkernels.",
      "char_count": 975,
      "token_estimate": 243,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0037",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Microkernels ==",
      "heading_path": "== = Microkernels ==",
      "start_char": 29342,
      "end_char": 30237,
      "content": "Proponents of microkernels point out those monolithic kernels have the disadvantage that an error in the kernel can cause the entire system to crash. However, with a microkernel, if a kernel process crashes, it is still possible to prevent a crash of the system as a whole by merely restarting the service that caused the error. Other services provided by the kernel such as networking are implemented in user-space programs referred to as servers. Servers allow the operating system to be modified by simply starting and stopping programs. For a machine without networking support, for instance, the networking server is not started. The task of moving in and out of the kernel to move data between the various applications and servers creates overhead which is detrimental to the efficiency of microkernels in comparison with monolithic kernels. Disadvantages in the microkernel exist however.",
      "char_count": 895,
      "token_estimate": 223,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0038",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Microkernels ==",
      "heading_path": "== = Microkernels ==",
      "start_char": 30238,
      "end_char": 31121,
      "content": "Some are: Larger running memory footprint More software for interfacing is required, so there is a potential for performance loss. Messaging bugs can be harder to fix due to the longer trip they have to take, versus the one-off copy in a monolithic kernel. Process management in general can be very complicated. The disadvantages for microkernels are extremely context-based. As an example, they work well for small single-purpose (and critical) systems because if not many processes need to run, then the complications of process management are effectively mitigated. A microkernel allows the implementation of the remaining part of the operating system as programs running in user mode, and the use of different operating systems on top of the same unchanged kernel. It is also possible to dynamically switch among operating systems and to have more than one active simultaneously.",
      "char_count": 883,
      "token_estimate": 220,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0039",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Monolithic kernels vs. microkernels ==",
      "heading_path": "== = Monolithic kernels vs. microkernels ==",
      "start_char": 31145,
      "end_char": 32080,
      "content": "== = Monolithic kernels vs. microkernels === As the computer kernel grows, so grows the size and vulnerability of its trusted computing base, in addition to its memory footprint. This is mitigated to some degree by perfecting a virtual memory system, but not all computer architectures have virtual memory support. To reduce the kernel's footprint, extensive editing has to be performed to carefully remove unneeded code, which can be very difficult with non-obvious interdependencies between parts of a kernel with millions of lines of code. By the early 1990s, due to the various shortcomings of monolithic kernels versus microkernels, monolithic kernels were considered obsolete by virtually all operating system researchers. As a result, the design of Linux as a monolithic kernel rather than a microkernel was the topic of a famous debate between Linus Torvalds and Andrew Tanenbaum. There is merit on both sides of the argument presented in the Tanenbaum–Torvalds debate.",
      "char_count": 977,
      "token_estimate": 244,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0040",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Hybrid (or modular) kernels ==",
      "heading_path": "== = Hybrid (or modular) kernels ==",
      "start_char": 32115,
      "end_char": 32959,
      "content": "== = Hybrid (or modular) kernels === Hybrid kernels are used in some commercial operating systems, including most versions of Microsoft Windows to date (NT 3.1, NT 3.5, NT 3.51, NT 4.0, 2000, XP, Vista, 7, 8, 8.1, 10 and 11). Apple's macOS uses a hybrid kernel called XNU, which is based upon code from OSF/1's Mach kernel (OSFMK 7.3) and FreeBSD's monolithic kernel. Hybrid kernels are similar to microkernels, except they include some additional code in kernel-space to increase performance. These kernels represent a compromise that was implemented by some developers to accommodate the major advantages of both monolithic and microkernels. These types of kernels are extensions of microkernels with some properties of monolithic kernels. Unlike monolithic kernels, these types of kernels are unable to load modules at runtime on their own.",
      "char_count": 843,
      "token_estimate": 210,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0041",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Hybrid (or modular) kernels ==",
      "heading_path": "== = Hybrid (or modular) kernels ==",
      "start_char": 32959,
      "end_char": 33844,
      "content": "This implies running some services (such as the network stack or the filesystem) in kernel space to reduce the performance overhead of a traditional microkernel, but still running kernel code (such as device drivers) as servers in user space. Many traditionally monolithic kernels support loadable kernel modules. The most well known of these kernels is the Linux kernel. The modular kernel essentially can have parts of it that are built into the core kernel binary or binaries that load into memory on demand. A code-tainted module has the potential to destabilize a running kernel. By contrast, it is possible to write a driver for a microkernel in a completely separate memory space and test it before \"going\" live. When a kernel module is loaded, it accesses the monolithic portion's memory space by adding to it what it needs, therefore opening the doorway to possible pollution.",
      "char_count": 885,
      "token_estimate": 221,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0042",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Hybrid (or modular) kernels ==",
      "heading_path": "== = Hybrid (or modular) kernels ==",
      "start_char": 33845,
      "end_char": 34709,
      "content": "A few advantages to the modular (or) hybrid kernel are: Faster development time for drivers that can operate from within modules. No reboot required for testing (provided the kernel is not destabilized). On demand capability versus spending time recompiling a whole kernel for things like new drivers or subsystems. Faster integration of third party technology (related to development but pertinent unto itself nonetheless). Modules, generally, communicate with the kernel using a module interface of some sort. The interface is generalized (although particular to a given operating system) so it is not always possible to use modules. Often the device drivers may need more flexibility than the module interface affords. Essentially, it is two system calls and often the safety checks that only have to be done once in the monolithic kernel now may be done twice.",
      "char_count": 864,
      "token_estimate": 216,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0043",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Hybrid (or modular) kernels ==",
      "heading_path": "== = Hybrid (or modular) kernels ==",
      "start_char": 34710,
      "end_char": 34993,
      "content": "Some of the disadvantages of the modular approach are: With more interfaces to pass through, the possibility of increased bugs exists (which implies more security holes). Maintaining modules can be confusing for some administrators when dealing with problems like symbol differences.",
      "char_count": 283,
      "token_estimate": 70,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0044",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Nanokernels ==",
      "heading_path": "== = Nanokernels ==",
      "start_char": 34978,
      "end_char": 35206,
      "content": "== = Nanokernels === A nanokernel delegates virtually all services – including even the most basic ones like interrupt controllers or the timer – to device drivers to make the kernel memory requirement even smaller than a traditional microkernel.",
      "char_count": 246,
      "token_estimate": 61,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0045",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Exokernels ==",
      "heading_path": "== = Exokernels ==",
      "start_char": 35224,
      "end_char": 36152,
      "content": "== = Exokernels === Exokernels are a still-experimental approach to operating system design. They differ from other types of kernels in limiting their functionality to the protection of and multiplexing of access to the raw hardware, providing no hardware abstractions on top of which to develop applications. This separation of hardware protection from hardware management enables application developers to determine how to make the most efficient use of the available hardware for each specific program. Exokernels in themselves are extremely small. However, they are accompanied by library operating systems (see also unikernel), providing application developers with the functionalities of a conventional operating system. A major advantage of exokernel-based systems is that they can incorporate multiple library operating systems, each exporting a different API, for example one for high level UI development and one for real-time control.",
      "char_count": 945,
      "token_estimate": 236,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0046",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Multikernels ==",
      "heading_path": "== = Multikernels ==",
      "start_char": 36172,
      "end_char": 36484,
      "content": "== = Multikernels === A multikernel operating system treats a multi-core machine as a network of independent cores, as if it were a distributed system. It does not assume shared memory but rather implements inter-process communications as message passing. Barrelfish was the first operating system to be described as a multikernel.",
      "char_count": 331,
      "token_estimate": 82,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0047",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Early operating system kernels ==",
      "heading_path": "== = Early operating system kernels ==",
      "start_char": 36558,
      "end_char": 37434,
      "content": "== = Early operating system kernels === Strictly speaking, an operating system (and thus, a kernel) is not required to run a computer. Programs can be directly loaded and executed on the \"bare metal\" machine, provided that the authors of those programs are willing to work without any hardware abstraction or operating system support. Most early computers operated this way during the 1950s and early 1960s, which were reset and reloaded between the execution of different programs. Eventually, small ancillary programs such as program loaders and debuggers were left in memory between runs, or loaded from ROM. As these were developed, they formed the basis of what became early operating system kernels. The \"bare metal\" approach is still used today on some video game consoles and embedded systems, but in general, newer computers use modern operating systems and kernels.",
      "char_count": 875,
      "token_estimate": 218,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0048",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Early operating system kernels ==",
      "heading_path": "== = Early operating system kernels ==",
      "start_char": 37434,
      "end_char": 37675,
      "content": "In 1969, the RC 4000 Multiprogramming System introduced the system design philosophy of a small nucleus \"upon which operating systems for different purposes could be built in an orderly manner\", what would be called the microkernel approach.",
      "char_count": 241,
      "token_estimate": 60,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0049",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Time-sharing operating systems ==",
      "heading_path": "== = Time-sharing operating systems ==",
      "start_char": 37676,
      "end_char": 38439,
      "content": "== = Time-sharing operating systems === In the decade preceding Unix, computers had grown enormously in power – to the point where computer operators were looking for new ways to get people to use their spare time on their machines. One of the major developments during this era was time-sharing, whereby a number of users would get small slices of computer time, at a rate at which it appeared they were each connected to their own, slower, machine. The development of time-sharing systems led to a number of problems. One was that users, particularly at universities where the systems were being developed, seemed to want to hack the system to get more CPU time. For this reason, security and access control became a major focus of the Multics project in 1965.",
      "char_count": 762,
      "token_estimate": 190,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0050",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Time-sharing operating systems ==",
      "heading_path": "== = Time-sharing operating systems ==",
      "start_char": 38439,
      "end_char": 38912,
      "content": "Another ongoing issue was properly handling computing resources: users spent most of their time staring at the terminal and thinking about what to input instead of actually using the resources of the computer, and a time-sharing system should give the CPU time to an active user during these periods. Finally, the systems typically offered a memory hierarchy several layers deep, and partitioning this expensive resource led to major developments in virtual memory systems.",
      "char_count": 473,
      "token_estimate": 118,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0051",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Amiga ==",
      "heading_path": "== = Amiga ==",
      "start_char": 38888,
      "end_char": 39480,
      "content": "== = Amiga === The Commodore Amiga was released in 1985, and was among the first – and certainly most successful – home computers to feature an advanced kernel architecture. The AmigaOS kernel's executive component, exec.library, uses a microkernel message-passing design, but there are other kernel components, like graphics.library, that have direct access to the hardware. There is no memory protection, and the kernel is almost always running in user mode. Only special actions are executed in kernel mode, and user-mode applications can ask the operating system to execute their code in kernel mode.",
      "char_count": 604,
      "token_estimate": 151,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0052",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Unix ==",
      "heading_path": "== = Unix ==",
      "start_char": 39492,
      "end_char": 40419,
      "content": "== = Unix === During the design phase of Unix, programmers decided to model every high-level device as a file, because they believed the purpose of computation was data transformation. For instance, printers were represented as a \"file\" at a known location – when data was copied to the file, it printed out. Other systems, to provide a similar functionality, tended to virtualize devices at a lower level – that is, both devices and files would be instances of some lower level concept. Virtualizing the system at the file level allowed users to manipulate the entire system using their existing file management utilities and concepts, dramatically simplifying operation. As an extension of the same paradigm, Unix allows programmers to manipulate files using a series of small programs, using the concept of pipes, which allowed users to complete operations in stages, feeding a file through a chain of single-purpose tools.",
      "char_count": 926,
      "token_estimate": 231,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0053",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Unix ==",
      "heading_path": "== = Unix ==",
      "start_char": 40419,
      "end_char": 41377,
      "content": "Although the end result was the same, using smaller programs in this way dramatically increased flexibility as well as ease of development and use, allowing the user to modify their workflow by adding or removing a program from the chain. In the Unix model, the operating system consists of two parts: first, the huge collection of utility programs that drive most operations; second, the kernel that runs the programs. Under Unix, from a programming standpoint, the distinction between the two is fairly thin; the kernel is a program, running in supervisor mode, that acts as a program loader and supervisor for the small utility programs making up the rest of the system, and to provide locking and I/O services for these programs; beyond that, the kernel didn't intervene at all in user space. Over the years the computing model changed, and Unix's treatment of everything as a file or byte stream no longer was as universally applicable as it was before.",
      "char_count": 958,
      "token_estimate": 239,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0054",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Unix ==",
      "heading_path": "== = Unix ==",
      "start_char": 41378,
      "end_char": 42358,
      "content": "Although a terminal could be treated as a file or a byte stream, which is printed to or read from, the same did not seem to be true for a graphical user interface. Networking posed another problem. Even if network communication can be compared to file access, the low-level packet-oriented architecture dealt with discrete chunks of data and not with whole files. As the capability of computers grew, Unix became increasingly cluttered with code. It is also because the modularity of the Unix kernel is extensively scalable. While kernels might have had 100,000 lines of code in the seventies and eighties, kernels like Linux, of modern Unix successors like GNU, have more than 13 million lines. Modern Unix-derivatives are generally based on module-loading monolithic kernels. Examples of this are the Linux kernel in the many distributions of GNU, IBM AIX, as well as the Berkeley Software Distribution variant kernels such as FreeBSD, DragonFly BSD, OpenBSD, NetBSD, and macOS.",
      "char_count": 980,
      "token_estimate": 245,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0055",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Unix ==",
      "heading_path": "== = Unix ==",
      "start_char": 42359,
      "end_char": 42645,
      "content": "Apart from these alternatives, amateur developers maintain an active operating system development community, populated by self-written hobby kernels which mostly end up sharing many features with Linux, FreeBSD, DragonflyBSD, OpenBSD or NetBSD kernels and/or being compatible with them.",
      "char_count": 286,
      "token_estimate": 71,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0056",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Classic Mac OS and macOS ==",
      "heading_path": "== = Classic Mac OS and macOS ==",
      "start_char": 42666,
      "end_char": 43001,
      "content": "== = Classic Mac OS and macOS === Apple first launched its classic Mac OS in 1984, bundled with its Macintosh personal computer. Apple moved to a nanokernel design in Mac OS 8.6. Against this, the modern macOS (originally named Mac OS X) is based on Darwin, which uses a hybrid kernel called XNU, which was created by combining the 4.3BSD kernel and the Mach kernel.",
      "char_count": 366,
      "token_estimate": 91,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0057",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Microsoft Windows ==",
      "heading_path": "== = Microsoft Windows ==",
      "start_char": 43026,
      "end_char": 43934,
      "content": "== = Microsoft Windows === Microsoft Windows was first released in 1985 as an add-on to MS-DOS. Because of its dependence on another operating system, initial releases of Windows, prior to Windows 95, were considered an operating environment (not to be confused with an operating system). This product line continued to evolve through the 1980s and 1990s, with the Windows 9x series adding 32-bit addressing and pre-emptive multitasking; but ended with the release of Windows Me in 2000. Microsoft also developed Windows NT, an operating system with a very similar interface, but intended for high-end and business users. This line started with the release of Windows NT 3.1 in 1993, and was introduced to general users with the release of Windows XP in October 2001—replacing Windows 9x with a completely different, much more sophisticated operating system. This is the line that continues with Windows 11.",
      "char_count": 907,
      "token_estimate": 226,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0058",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Microsoft Windows ==",
      "heading_path": "== = Microsoft Windows ==",
      "start_char": 43934,
      "end_char": 44307,
      "content": "The architecture of Windows NT's kernel is considered a hybrid kernel because the kernel itself contains tasks such as the Window Manager and the IPC Managers, with a client/server layered subsystem model. It was designed as a modified microkernel, as the Windows NT kernel was influenced by the Mach microkernel but does not meet all of the criteria of a pure microkernel.",
      "char_count": 373,
      "token_estimate": 93,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0059",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = IBM Supervisor ==",
      "heading_path": "== = IBM Supervisor ==",
      "start_char": 44305,
      "end_char": 45105,
      "content": "== = IBM Supervisor === Supervisory program or supervisor is a computer program, usually part of an operating system, that controls the execution of other routines and regulates work scheduling, input/output operations, error actions, and similar functions and regulates the flow of work in a data processing system. Historically, this term was essentially associated with IBM's line of mainframe operating systems starting with OS/360. In other operating systems, the supervisor is generally called the kernel. In the 1970s, IBM further abstracted the supervisor state from the hardware, resulting in a hypervisor that enabled full virtualization, i.e. the capacity to run multiple operating systems on the same machine totally independently from each other. Hence the first such system was called Virtual Machine or VM.",
      "char_count": 821,
      "token_estimate": 205,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "kerneloperatingsyste_beac728d_c0060",
      "article_id": "kerneloperatingsyste_beac728d",
      "section": "== = Development of microkernels ==",
      "heading_path": "== = Development of microkernels ==",
      "start_char": 45140,
      "end_char": 45830,
      "content": "== = Development of microkernels === Although Mach, developed by Richard Rashid at Carnegie Mellon University, is the best-known general-purpose microkernel, other microkernels have been developed with more specific aims. The L4 microkernel family (mainly the L3 and the L4 kernel) was created to demonstrate that microkernels are not necessarily slow. Newer implementations such as Fiasco and Pistachio are able to run Linux next to other L4 processes in separate address spaces. Additionally, QNX is a microkernel which is principally used in embedded systems, and the open-source software MINIX, while originally created for educational purposes, is now focused on being a highly reliable and self-healing microkernel OS.",
      "char_count": 724,
      "token_estimate": 181,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 10,
    "items": [
      {
        "question": "Why might a microkernel-based system be slower than one with a monolithic kernel?",
        "answer": "A microkernel-based system might be slower because the large number of system calls and context switches it requires can generate more overhead than the plain function calls used in monolithic designs, potentially slowing down the system.",
        "related_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0034"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0034"
        ]
      },
      {
        "question": "What are two methods for a user process to invoke a kernel function when memory isolation is in use?",
        "answer": "Two methods for a user process to invoke a kernel function when memory isolation is in use are: using a software-simulated interrupt or using a call gate.",
        "related_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0014"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0014"
        ]
      },
      {
        "question": "What are some examples of modern Unix-derivatives that are based on module-loading monolithic kernels?",
        "answer": "Examples of modern Unix-derivatives based on module-loading monolithic kernels include the Linux kernel, IBM AIX, and Berkeley Software Distribution variants such as FreeBSD, DragonFly BSD, OpenBSD, NetBSD, and macOS.",
        "related_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0054"
        ],
        "category": "FACTUAL",
        "reranked_relative_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0054"
        ]
      },
      {
        "question": "Explain how the kernel manages interactions between software and hardware while ensuring system stability, referencing its memory management and architectural design.",
        "answer": "The kernel acts as the core of the operating system, managing all hardware resources and arbitrating conflicts between processes. It facilitates interactions by translating software requests, made via system calls, into data-processing instructions for the CPU. To ensure system stability, the kernel's critical code is loaded into a protected memory area called kernel space, which is separate from the user space where applications run. This separation prevents malfunctioning applications from interfering with the kernel and crashing the system. Different kernel architectures, such as monolithic kernels that run in a single address space for speed or microkernels that run services in user space for resilience, represent different approaches to these tasks.",
        "related_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0000",
          "kerneloperatingsyste_beac728d_c0001",
          "kerneloperatingsyste_beac728d_c0002"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0000",
          "kerneloperatingsyste_beac728d_c0001",
          "kerneloperatingsyste_beac728d_c0002"
        ]
      },
      {
        "question": "What are the kernel's primary responsibilities regarding the management of system resources like memory, I/O devices, and processes?",
        "answer": "The kernel's primary responsibilities in resource management are extensive. It manages Random-access memory (RAM) by deciding which memory each process can use and handling situations of insufficient memory. For I/O devices such as keyboards and printers, it provides abstracted methods for applications to use them without knowing their implementation details. More generally, the kernel defines execution domains and protection mechanisms to mediate access to all resources, and it is also responsible for context switching between processes, synchronization, and inter-process communication (IPC).",
        "related_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0003",
          "kerneloperatingsyste_beac728d_c0004",
          "kerneloperatingsyste_beac728d_c0005"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0005",
          "kerneloperatingsyste_beac728d_c0003",
          "kerneloperatingsyste_beac728d_c0004"
        ]
      },
      {
        "question": "How does virtual addressing allow an operating system to let programs use more memory than is physically available on the system?",
        "answer": "Virtual addressing creates a layer of indirection where a program's virtual address may refer to data not currently in main memory (RAM). This allows the operating system to use other data stores, like a hard drive, to store data. When a program needs data that is not in RAM, the kernel can write an inactive memory block to the disk and replace it with the requested data, a scheme known as demand paging. This process enables programs to use more memory than the system physically has.",
        "related_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0006",
          "kerneloperatingsyste_beac728d_c0007"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0007",
          "kerneloperatingsyste_beac728d_c0006"
        ]
      },
      {
        "question": "How does the kernel's architectural design relate to its use of protected memory spaces to manage system stability and performance?",
        "answer": "The kernel uses protected memory to separate its critical code (in kernel space) from application programs (in user space), which prevents malfunctioning applications from crashing the entire system. This memory protection strategy is implemented differently depending on the kernel's architecture. Monolithic kernels run entirely in the protected kernel space for speed. In contrast, microkernels run most of their services in the less-protected user space, prioritizing resilience and modularity over speed. Therefore, the architectural choice between monolithic and microkernel represents a trade-off between performance and system stability, which is fundamentally linked to how these memory spaces are utilized.",
        "related_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0000",
          "kerneloperatingsyste_beac728d_c0001",
          "kerneloperatingsyste_beac728d_c0002"
        ],
        "category": "INTERPRETATION",
        "reranked_relative_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0001",
          "kerneloperatingsyste_beac728d_c0002",
          "kerneloperatingsyste_beac728d_c0000"
        ]
      },
      {
        "question": "Explain how the kernel uses virtual addressing to manage memory, including its benefits for application processes and the protection of the kernel itself.",
        "answer": "The kernel utilizes virtual addressing, typically through paging and/or segmentation, to provide each process with its own distinct virtual address space. This isolates processes, preventing them from crashing each other. This layer of indirection also enables demand paging, where a hard drive is used to supplement RAM, allowing programs to use more memory than is physically available. Furthermore, virtual addressing allows for the creation of separate kernel and user spaces. This partition is crucial for kernel protection, as it prevents applications from addressing and potentially damaging the kernel's memory, a design that is nearly universal in general-purpose systems.",
        "related_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0006",
          "kerneloperatingsyste_beac728d_c0007",
          "kerneloperatingsyste_beac728d_c0008"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0006",
          "kerneloperatingsyste_beac728d_c0007",
          "kerneloperatingsyste_beac728d_c0008"
        ]
      },
      {
        "question": "Summarize the process of device management, from how an OS identifies hardware to how an application uses it, and include a key performance consideration in its design.",
        "answer": "An operating system's kernel manages devices through device drivers. First, the kernel must identify available devices, which can be done in three ways: being known in advance (embedded systems), configured by the user (older PCs), or detected at runtime via plug-and-play, which scans buses like PCI or USB. Once a device is identified, its corresponding driver provides an abstraction layer, translating abstract OS function calls into device-specific commands. When an application needs to use a device, it sends a request to the kernel, which then forwards it to the correct driver to control the hardware. A key design consideration in this system is that device access may involve context switches, which are CPU-intensive and can create significant performance overhead.",
        "related_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0009",
          "kerneloperatingsyste_beac728d_c0010",
          "kerneloperatingsyste_beac728d_c0011",
          "kerneloperatingsyste_beac728d_c0012"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0009",
          "kerneloperatingsyste_beac728d_c0012",
          "kerneloperatingsyste_beac728d_c0011",
          "kerneloperatingsyste_beac728d_c0010"
        ]
      },
      {
        "question": "Explain the complete process by which an application program requests a service from the operating system's kernel, including the role of libraries and the various mechanisms for invoking kernel functions.",
        "answer": "An application program requests a service from the operating system's kernel via a system call, which serves as the interface between the process and the OS. This is often done through a C library like Glibc or the Windows API, which handles the low-level details of passing information and causing the processor to change mode. Because memory isolation prevents a user process from calling the kernel directly, several mechanisms are used to invoke the kernel function. These methods include using a software-simulated interrupt, a call gate, a special system call instruction supported by the hardware, or a memory-based queue for applications making many requests.",
        "related_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0013",
          "kerneloperatingsyste_beac728d_c0014",
          "kerneloperatingsyste_beac728d_c0015"
        ],
        "category": "LONG_ANSWER",
        "reranked_relative_chunk_ids": [
          "kerneloperatingsyste_beac728d_c0013",
          "kerneloperatingsyste_beac728d_c0014",
          "kerneloperatingsyste_beac728d_c0015"
        ]
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-30T10:37:31.279Z",
    "content_format": "markdown",
    "total_chunks": 61,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}