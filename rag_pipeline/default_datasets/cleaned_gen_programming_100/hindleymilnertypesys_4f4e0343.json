{
  "article": {
    "id": "hindleymilnertypesys_4f4e0343",
    "title": "Hindley–Milner type system",
    "url": "https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system",
    "lang": "en",
    "created_at": "2025-07-30T10:37:13.290261",
    "content": "---\nid: hindleymilnertypesys_4f4e0343\nurl: https://en.wikipedia.org/wiki/Hindley%E2%80%93Milner_type_system\ntitle: Hindley–Milner type system\nlang: en\ncreated_at: '2025-07-30T10:36:40.882236'\nchecksum: 437db4398b8f7577b49b103420212281378fa5ef15971839f1be583b788acfed\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 2\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 8329\n  char_count: 48676\n  num_chunks: 47\n  original_chunks: 53\n  filtered_out: 6\n  num_sections: 0\n---\nA Hindley–Milner (HM) type system is a classical type system for the lambda calculus with parametric polymorphism. It is also known as Damas–Milner or Damas–Hindley–Milner. It was first described by J. Roger Hindley and later rediscovered by Robin Milner. Luis Damas contributed a close formal analysis and proof of the method in his PhD thesis. Among HM's more notable properties are its completeness and its ability to infer the most general type of a given program without programmer-supplied type annotations or other hints. Algorithm W is an efficient type inference method in practice and has been successfully applied on large code bases, although it has a high theoretical complexity. HM is preferably used for functional languages. It was first implemented as part of the type system of the programming language ML. Since then, HM has been extended in various ways, most notably with type class constraints like those in Haskell. == Introduction == As a type inference method, Hindley–Milner is able to deduce the types of variables, expressions and functions from programs written in an entirely untyped style. Being scope sensitive, it is not limited to deriving the types only from a small portion of source code, but rather from complete programs or modules. Being able to cope with parametric types, too, it is core to the type systems of many functional programming languages. It was first applied in this manner in the ML programming language. The origin is the type inference algorithm for the simply typed lambda calculus that was devised by Haskell Curry and Robert Feys in 1958. In 1969, J. Roger Hindley extended this work and proved that their algorithm always inferred the most general type. In 1978, Robin Milner, independently of Hindley's work, provided an equivalent algorithm, Algorithm W. In 1982, Luis Damas finally proved that Milner's algorithm is complete and extended it to support systems with polymorphic references. === Monomorphism vs. polymorphism === In the simply typed lambda calculus, types T are either atomic type constants or function types of form T → T {\\displaystyle T\\rightarrow T} . Such types are monomorphic. Typical examples are the types used in arithmetic values: 3 : Number add 3 4 : Number add : Number -> Number -> Number Contrary to this, the untyped lambda calculus is neutral to typing at all, and many of its functions can be meaningfully applied to all type of arguments. The trivial example is the identity function id ≡ λ x . x which simply returns whatever value it is applied to. Less trivial examples include parametric types like lists. While polymorphism in general means that operations accept values of more than one type, the polymorphism used here is parametric. One finds the notation of type schemes in the literature, too, emphasizing the parametric nature of the polymorphism. Additionally, constants may be typed with (quantified) type variables. E.g.: cons : forall a . a -> List a -> List a nil : forall a . List a id : forall a . a -> a Polymorphic types can become monomorphic by consistent substitution of their variables. Examples of monomorphic instances are: id' : String -> String nil' : List Number More generally, types are polymorphic when they contain type variables, while types without them are monomorphic. Contrary to the type systems used for example in Pascal (1970) or C (1972), which only support monomorphic types, HM is designed with emphasis on parametric polymorphism. The successors of the languages mentioned, like C++ (1985), focused on different types of polymorphism, namely subtyping in connection with object-oriented programming and overloading. While subtyping is incompatible with HM, a variant of systematic overloading is available in the HM-based type system of Haskell. === Let-polymorphism === When extending the type inference for the simply-typed lambda calculus towards polymorphism, one has to decide whether assigning a polymorphic type not only as type of an expression, but also as the type of a λ-bound variable is admissible. This would allow the generic identity type to be assigned to the variable 'id' in: (λ id . ... (id 3) ... (id \"text\") ... ) (λ x . x) Allowing this gives rise to the polymorphic lambda calculus; however, unfortunately, type inference in this system is not decidable. Instead, HM distinguishes variables that are immediately bound to an expression from more general λ-bound variables, calling the former let-bound variables, and allows polymorphic types to be assigned only to these. This leads to let-polymorphism where the above example takes the form let id = λ x . x in ... (id 3) ... (id \"text\") ... which can be typed with a polymorphic type for 'id'. As indicated, the expression syntax is extended to make the let-bound variables explicit, and by restricting the type system to allow only let-bound variable to have polymorphic types, while the parameters in lambda-abstractions must get a monomorphic type, type inference becomes decidable. == Overview == The remainder of this article proceeds as follows: The HM type system is defined. This is done by describing a deduction system that makes precise what expressions have what type, if any. From there, it works towards an implementation of the type inference method. After introducing a syntax-driven variant of the above deductive system, it sketches an efficient implementation (algorithm J), appealing mostly to the reader's metalogical intuition. Because it remains open whether algorithm J indeed realises the initial deduction system, a less efficient implementation (algorithm W), is introduced and its use in a proof is hinted. Finally, further topics related to the algorithm are discussed. The same description of the deduction system is used throughout, even for the two algorithms, to make the various forms in which the HM method is presented directly comparable. == The Hindley–Milner type system == The type system can be formally described by syntax rules that fix a language for the expressions, types, etc. The presentation here of such a syntax is not too formal, in that it is written down not to study the surface grammar, but rather the depth grammar, and leaves some syntactical details open. This form of presentation is usual. Building on this, typing rules are used to define how expressions and types are related. As before, the form used is a bit liberal. === Syntax === The expressions to be typed are exactly those of the lambda calculus extended with a let-expression as shown in the adjacent table. Parentheses can be used to disambiguate an expression. The application is left-binding and binds stronger than abstraction or the let-in construct. Types are syntactically split into two groups, monotypes and polytypes. ==== Monotypes ==== Monotypes always designate a particular type. Monotypes τ {\\displaystyle \\tau } are syntactically represented as terms. Examples of monotypes include type constants like i n t {\\displaystyle {\\mathtt {int}}} or s t r i n g {\\displaystyle {\\mathtt {string}}} , and parametric types like M a p ( S e t s t r i n g ) i n t {\\displaystyle {\\mathtt {Map\\ (Set\\ string)\\ int}}} . The latter types are examples of applications of type functions, for example, from the set { M a p 2 , S e t 1 , s t r i n g 0 , i n t 0 , → 2 } {\\displaystyle \\{{\\mathtt {Map^{2},\\ Set^{1},\\ string^{0},\\ int^{0}}},\\ \\rightarrow ^{2}\\}} , where the superscript indicates the number of type parameters. The complete set of type functions C {\\displaystyle C} is arbitrary in HM, except that it must contain at least → 2 {\\displaystyle \\rightarrow ^{2}} , the type of functions. It is often written in infix notation for convenience. For example, a function mapping integers to strings has type i n t → s t r i n g {\\displaystyle {\\mathtt {int}}\\rightarrow {\\mathtt {string}}} . Again, parentheses can be used to disambiguate a type expression. The application binds stronger than the infix arrow, which is right-binding. Type variables are admitted as monotypes. Monotypes are not to be confused with monomorphic types, which exclude variables and allow only ground terms. Two monotypes are equal if they have identical terms. ==== Polytypes ==== Polytypes (or type schemes) are types containing variables bound by zero or more for-all quantifiers, e.g. ∀ α . α → α {\\displaystyle \\forall \\alpha .\\alpha \\rightarrow \\alpha } . A function with polytype ∀ α . α → α {\\displaystyle \\forall \\alpha .\\alpha \\rightarrow \\alpha } can map any value of the same type to itself, and the identity function is a value for this type. As another example, ∀ α . ( S e t α ) → i n t {\\displaystyle \\forall \\alpha .({\\mathtt {Set}}\\ \\alpha )\\rightarrow {\\mathtt {int}}} is the type of a function mapping all finite sets to integers. A function which returns the cardinality of a set would be a value of this type. Quantifiers can only appear top level. For instance, a type ∀ α . α → ∀ α . α {\\displaystyle \\forall \\alpha .\\alpha \\rightarrow \\forall \\alpha .\\alpha } is excluded by the syntax of types. Also monotypes are included in the polytypes, thus a type has the general form ∀ α 1 … ∀ α n . τ {\\displaystyle \\forall \\alpha _{1}\\dots \\forall \\alpha _{n}.\\tau } , where n ≥ 0 {\\displaystyle n\\geq 0} and τ {\\displaystyle \\tau } is a monotype. Equality of polytypes is up to reordering the quantification and renaming the quantified variables ( α {\\displaystyle \\alpha } -conversion). Further, quantified variables not occurring in the monotype can be dropped. ==== Context and typing ==== To meaningfully bring together the still disjoint parts (syntax expressions and types) a third part is needed: context. Syntactically, a context is a list of pairs x : σ {\\displaystyle x:\\sigma } , called assignments, assumptions or bindings, each pair stating that value variable x i {\\displaystyle x_{i}} has type σ i . {\\displaystyle \\sigma _{i}.} All three parts combined give a typing judgment of the form Γ ⊢ e : σ {\\displaystyle \\Gamma \\ \\vdash \\ e:\\sigma } , stating that under assumptions Γ {\\displaystyle \\Gamma } , the expression e {\\displaystyle e} has type σ {\\displaystyle \\sigma } . ==== Free type variables ==== In a type ∀ α 1 … ∀ α n . τ {\\displaystyle \\forall \\alpha _{1}\\dots \\forall \\alpha _{n}.\\tau } , the symbol ∀ {\\displaystyle \\forall } is the quantifier binding the type variables α i {\\displaystyle \\alpha _{i}} in the monotype τ {\\displaystyle \\tau } . The variables α i {\\displaystyle \\alpha _{i}} are called quantified and any occurrence of a quantified type variable in τ {\\displaystyle \\tau } is called bound and all unbound type variables in τ {\\displaystyle \\tau } are called free. Additionally to the quantification ∀ {\\displaystyle \\forall } in polytypes, type variables can also be bound by occurring in the context, but with the inverse effect on the right hand side of the ⊢ {\\displaystyle \\vdash } . Such variables then behave like type constants there. Finally, a type variable may legally occur unbound in a typing, in which case they are implicitly all-quantified. The presence of both bound and unbound type variables is a bit uncommon in programming languages. Often, all type variables are implicitly treated all-quantified. For instance, one does not have clauses with free variables in Prolog. Likewise in Haskell, where all type variables implicitly occur quantified, i.e. a Haskell type a -> a means ∀ α . α → α {\\displaystyle \\forall \\alpha .\\alpha \\rightarrow \\alpha } here. Related and also very uncommon is the binding effect of the right hand side σ {\\displaystyle \\sigma } of the assignments. Typically, the mixture of both bound and unbound type variables originate from the use of free variables in an expression. The constant function K = λ x . λ y . x {\\displaystyle \\lambda x.\\lambda y.x} provides an example. It has the monotype α → β → α {\\displaystyle \\alpha \\rightarrow \\beta \\rightarrow \\alpha } . One can force polymorphism by l e t k = λ x . ( l e t f = λ y . x i n f ) i n k {\\displaystyle \\mathbf {let} \\ k=\\lambda x.(\\mathbf {let} \\ f=\\lambda y.x\\ \\mathbf {in} \\ f)\\ \\mathbf {in} \\ k} . Herein, f {\\displaystyle f} has the type ∀ γ . γ → α {\\displaystyle \\forall \\gamma .\\gamma \\rightarrow \\alpha } . The free monotype variable α {\\displaystyle \\alpha } originates from the type of the variable x {\\displaystyle x} bound in the surrounding scope. k {\\displaystyle k} has the type ∀ α ∀ β . α → β → α {\\displaystyle \\forall \\alpha \\forall \\beta .\\alpha \\rightarrow \\beta \\rightarrow \\alpha } . One could imagine the free type variable α {\\displaystyle \\alpha } in the type of f {\\displaystyle f} be bound by the ∀ α {\\displaystyle \\forall \\alpha } in the type of k {\\displaystyle k} . But such a scoping cannot be expressed in HM. Rather, the binding is realized by the context. === Type order === Polymorphism means that one and the same expression can have (perhaps infinitely) many types. But in this type system, these types are not completely unrelated, but rather orchestrated by the parametric polymorphism. As an example, the identity λ x . x {\\displaystyle \\lambda x.x} can have ∀ α . α → α {\\displaystyle \\forall \\alpha .\\alpha \\rightarrow \\alpha } as its type as well as string → string {\\displaystyle {\\texttt {string}}\\rightarrow {\\texttt {string}}} or int → int {\\displaystyle {\\texttt {int}}\\rightarrow {\\texttt {int}}} and many others, but not int → string {\\displaystyle {\\texttt {int}}\\rightarrow {\\texttt {string}}} . The most general type for this function is ∀ α . α → α {\\displaystyle \\forall \\alpha .\\alpha \\rightarrow \\alpha } , while the others are more specific and can be derived from the general one by consistently replacing another type for the type parameter, i.e. the quantified variable α {\\displaystyle \\alpha } . The counter-example fails because the replacement is not consistent. The consistent replacement can be made formal by applying a substitution S = { a i ↦ τ i , … } {\\displaystyle S=\\left\\{\\ a_{i}\\mapsto \\tau _{i},\\ \\dots \\ \\right\\}} to the term of a type τ {\\displaystyle \\tau } , written S τ {\\displaystyle S\\tau } . As the example suggests, substitution is not only strongly related to an order, that expresses that a type is more or less special, but also with the all-quantification which allows the substitution to be applied. Formally, in HM, a type σ ′ {\\displaystyle \\sigma '} is more general than σ {\\displaystyle \\sigma } , formally σ ′ ⊑ σ {\\displaystyle \\sigma '\\sqsubseteq \\sigma } , if some quantified variable in σ ′ {\\displaystyle \\sigma '} is consistently substituted such that one gains σ {\\displaystyle \\sigma } as shown in the side bar. This order is part of the type definition of the type system. In our previous example, applying the substitution S = { α ↦ string } {\\displaystyle S=\\left\\{\\alpha \\mapsto {\\texttt {string}}\\right\\}} would result in ∀ α . α → α ⊑ string → string {\\displaystyle \\forall \\alpha .\\alpha \\rightarrow \\alpha \\sqsubseteq {\\texttt {string}}\\rightarrow {\\texttt {string}}} . While substituting a monomorphic (ground) type for a quantified variable is straight forward, substituting a polytype has some pitfalls caused by the presence of free variables. Most particularly, unbound variables must not be replaced. They are treated as constants here. Additionally, quantifications can only occur top-level. Substituting a parametric type, one has to lift its quantifiers. The table on the right makes the rule precise. Alternatively, consider an equivalent notation for the polytypes without quantifiers in which quantified variables are represented by a different set of symbols. In such a notation, the specialization reduces to plain consistent replacement of such variables. The relation ⊑ {\\displaystyle \\sqsubseteq } is a partial order and ∀ α . α {\\displaystyle \\forall \\alpha .\\alpha } is its smallest element. ==== Principal type ==== While specialization of a type scheme is one use of the order, it plays a crucial second role in the type system. Type inference with polymorphism faces the challenge of summarizing all possible types an expression may have. The order guarantees that such a summary exists as the most general type of the expression. ==== Substitution in typings ==== The type order defined above can be extended to typings because the implied all-quantification of typings enables consistent replacement: Γ ⊢ e : σ ⟹ S Γ ⊢ e : S σ {\\displaystyle \\Gamma \\vdash e:\\sigma \\quad \\Longrightarrow \\quad S\\Gamma \\vdash e:S\\sigma } Contrary to the specialisation rule, this is not part of the definition, but like the implicit all-quantification rather a consequence of the type rules defined next. Free type variables in a typing serve as placeholders for possible refinement. The binding effect of the environment to free type variables on the right hand side of ⊢ {\\displaystyle \\vdash } that prohibits their substitution in the specialisation rule is again that a replacement has to be consistent and would need to include the whole typing. This article will discuss four different rule sets: ⊢ D {\\displaystyle \\vdash _{D}} declarative system ⊢ S {\\displaystyle \\vdash _{S}} syntactical system ⊢ J {\\displaystyle \\vdash _{J}} algorithm J ⊢ W {\\displaystyle \\vdash _{W}} algorithm W === Deductive system === The syntax of HM is carried forward to the syntax of the inference rules that form the body of the formal system, by using the typings as judgments. Each of the rules define what conclusion could be drawn from what premises. Additionally to the judgments, some extra conditions introduced above might be used as premises, too. A proof using the rules is a sequence of judgments such that all premises are listed before a conclusion. The examples below show a possible format of proofs. From left to right, each line shows the conclusion, the [ N a m e ] {\\displaystyle [{\\mathtt {Name}}]} of the rule applied and the premises, either by referring to an earlier line (number) if the premise is a judgment or by making the predicate explicit. ==== Typing rules ==== See also Typing rules The side box shows the deduction rules of the HM type system. One can roughly divide the rules into two groups: The first four rules [ V a r ] {\\displaystyle [{\\mathtt {Var}}]} (variable or function access), [ A p p ] {\\displaystyle [{\\mathtt {App}}]} (application, i.e. function call with one parameter), [ A b s ] {\\displaystyle [{\\mathtt {Abs}}]} (abstraction, i.e. function declaration) and [ L e t ] {\\displaystyle [{\\mathtt {Let}}]} (variable declaration) are centered around the syntax, presenting one rule for each of the expression forms. Their meaning is obvious at the first glance, as they decompose each expression, prove their sub-expressions and finally combine the individual types found in the premises to the type in the conclusion. The second group is formed by the remaining two rules [ I n s t ] {\\displaystyle [{\\mathtt {Inst}}]} and [ G e n ] {\\displaystyle [{\\mathtt {Gen}}]} . They handle specialization and generalization of types. While the rule [ I n s t ] {\\displaystyle [{\\mathtt {Inst}}]} should be clear from the section on specialization above, [ G e n ] {\\displaystyle [{\\mathtt {Gen}}]} complements the former, working in the opposite direction. It allows generalization, i.e. to quantify monotype variables not bound in the context. The following two examples exercise the rule system in action. Since both the expression and the type are given, they are a type-checking use of the rules. Example: A proof for Γ ⊢ D i d ( n ) : i n t {\\displaystyle \\Gamma \\vdash _{D}id(n):int} where Γ = i d : ∀ α . α → α , n : i n t {\\displaystyle \\Gamma =id:\\forall \\alpha .\\alpha \\rightarrow \\alpha ,\\ n:int} , could be written 1 : Γ ⊢ D i d : ∀ α . α → α [ V a r ] ( i d : ∀ α . α → α ∈ Γ ) 2 : Γ ⊢ D i d : i n t → i n t [ I n s t ] ( 1 ) , ( ∀ α . α → α ⊑ i n t → i n t ) 3 : Γ ⊢ D n : i n t [ V a r ] ( n : i n t ∈ Γ ) 4 : Γ ⊢ D i d ( n ) : i n t [ A p p ] ( 2 ) , ( 3 ) {\\displaystyle {\\begin{array}{llll}1:&\\Gamma \\vdash _{D}id:\\forall \\alpha .\\alpha \\rightarrow \\alpha &[{\\mathtt {Var}}]&(id:\\forall \\alpha .\\alpha \\rightarrow \\alpha \\in \\Gamma )\\\\2:&\\Gamma \\vdash _{D}id:int\\rightarrow int&[{\\mathtt {Inst}}]&(1),\\ (\\forall \\alpha .\\alpha \\rightarrow \\alpha \\sqsubseteq int\\rightarrow int)\\\\3:&\\Gamma \\vdash _{D}n:int&[{\\mathtt {Var}}]&(n:int\\in \\Gamma )\\\\4:&\\Gamma \\vdash _{D}id(n):int&[{\\mathtt {App}}]&(2),\\ (3)\\\\\\end{array}}} Example: To demonstrate generalization, ⊢ D let i d = λ x . x in i d : ∀ α . α → α {\\displaystyle \\vdash _{D}\\ {\\textbf {let}}\\,id=\\lambda x.x\\ {\\textbf {in}}\\ id\\,:\\,\\forall \\alpha .\\alpha \\rightarrow \\alpha } is shown below: 1 : x : α ⊢ D x : α [ V a r ] ( x : α ∈ { x : α } ) 2 : ⊢ D λ x . x : α → α [ A b s ] ( 1 ) 3 : i d : α → α ⊢ D i d : α → α [ V a r ] ( i d : α → α ∈ { i d : α → α } ) 4 : ⊢ D let i d = λ x . x in i d : α → α [ L e t ] ( 2 ) , ( 3 ) 5 : ⊢ D let i d = λ x . x in i d : ∀ α . α → α [ G e n ] ( 4 ) , ( α ∉ f r e e ( ϵ ) ) {\\displaystyle {\\begin{array}{llll}1:&x:\\alpha \\vdash _{D}x:\\alpha &[{\\mathtt {Var}}]&(x:\\alpha \\in \\left\\{x:\\alpha \\right\\})\\\\2:&\\vdash _{D}\\lambda x.x:\\alpha \\rightarrow \\alpha &[{\\mathtt {Abs}}]&(1)\\\\3:&id:\\alpha \\rightarrow \\alpha \\vdash _{D}id:\\alpha \\rightarrow \\alpha &[{\\mathtt {Var}}]&(id:\\alpha \\rightarrow \\alpha \\in \\left\\{id:\\alpha \\rightarrow \\alpha \\right\\})\\\\4:&\\vdash _{D}{\\textbf {let}}\\,id=\\lambda x.x\\ {\\textbf {in}}\\ id\\,:\\,\\alpha \\rightarrow \\alpha &[{\\mathtt {Let}}]&(2),\\ (3)\\\\5:&\\vdash _{D}{\\textbf {let}}\\,id=\\lambda x.x\\ {\\textbf {in}}\\ id\\,:\\,\\forall \\alpha .\\alpha \\rightarrow \\alpha &[{\\mathtt {Gen}}]&(4),\\ (\\alpha \\not \\in free(\\epsilon ))\\\\\\end{array}}} === Let-polymorphism === Not visible immediately, the rule set encodes a regulation under which circumstances a type might be generalized or not by a slightly varying use of mono- and polytypes in the rules [ A b s ] {\\displaystyle [{\\mathtt {Abs}}]} and [ L e t ] {\\displaystyle [{\\mathtt {Let}}]} . Remember that σ {\\displaystyle \\sigma } and τ {\\displaystyle \\tau } denote poly- and monotypes respectively. In rule [ A b s ] {\\displaystyle [{\\mathtt {Abs}}]} , the value variable of the parameter of the function λ x . e {\\displaystyle \\lambda x.e} is added to the context with a monomorphic type through the premise Γ , x : τ ⊢ D e : τ ′ {\\displaystyle \\Gamma ,\\ x:\\tau \\vdash _{D}e:\\tau '} , while in the rule [ L e t ] {\\displaystyle [{\\mathtt {Let}}]} , the variable enters the environment in polymorphic form Γ , x : σ ⊢ D e 1 : τ {\\displaystyle \\Gamma ,\\ x:\\sigma \\vdash _{D}e_{1}:\\tau } . Though in both cases the presence of x {\\displaystyle x} in the context prevents the use of the generalisation rule for any free variable in the assignment, this regulation forces the type of parameter x {\\displaystyle x} in a λ {\\displaystyle \\lambda } -expression to remain monomorphic, while in a let-expression, the variable could be introduced polymorphic, making specializations possible. As a consequence of this regulation, λ f . ( f true , f 0 ) {\\displaystyle \\lambda f.(f\\,{\\textrm {true}},f\\,{\\textrm {0}})} cannot be typed, since the parameter f {\\displaystyle f} is in a monomorphic position, while let f = λ x . x in ( f true , f 0 ) {\\displaystyle {\\textbf {let}}\\ f=\\lambda x.x\\,{\\textbf {in}}\\,(f\\,{\\textrm {true}},f\\,{\\textrm {0}})} has type ( b o o l , i n t ) {\\displaystyle (bool,int)} , because f {\\displaystyle f} has been introduced in a let-expression and is treated polymorphic therefore. === Generalization rule === The generalisation rule is also worth a closer look. Here, the all-quantification implicit in the premise Γ ⊢ D e : σ {\\displaystyle \\Gamma \\vdash _{D}e:\\sigma } is simply moved to the right hand side of ⊢ D {\\displaystyle \\vdash _{D}} in the conclusion, bound by an explicit universal quantifier. This is possible, since α {\\displaystyle \\alpha } does not occur free in the context. Again, while this makes the generalization rule plausible, it is not really a consequence. On the contrary, the generalization rule is part of the definition of HM's type system and the implicit all-quantification a consequence. == An inference algorithm == Now that the deduction system of HM is at hand, one could present an algorithm and validate it with respect to the rules. Alternatively, it might be possible to derive it by taking a closer look on how the rules interact and proof are formed. This is done in the remainder of this article focusing on the possible decisions one can make while proving a typing. === Degrees of freedom choosing the rules === Isolating the points in a proof, where no decision is possible at all, the first group of rules centered around the syntax leaves no choice since to each syntactical rule corresponds a unique typing rule, which determines a part of the proof, while between the conclusion and the premises of these fixed parts chains of [ I n s t ] {\\displaystyle [{\\mathtt {Inst}}]} and [ G e n ] {\\displaystyle [{\\mathtt {Gen}}]} could occur. Such a chain could also exist between the conclusion of the proof and the rule for topmost expression. All proofs must have the so sketched shape. Because the only choice in a proof with respect of rule selection are the [ I n s t ] {\\displaystyle [{\\mathtt {Inst}}]} and [ G e n ] {\\displaystyle [{\\mathtt {Gen}}]} chains, the form of the proof suggests the question whether it can be made more precise, where these chains might not be needed. This is in fact possible and leads to a variant of the rules system with no such rules. === Syntax-directed rule system === A contemporary treatment of HM uses a purely syntax-directed rule system due to Clement as an intermediate step. In this system, the specialization is located directly after the original [ V a r ] {\\displaystyle [{\\mathtt {Var}}]} rule and merged into it, while the generalization becomes part of the [ L e t ] {\\displaystyle [{\\mathtt {Let}}]} rule. There the generalization is also determined to always produce the most general type by introducing the function Γ ¯ ( τ ) {\\displaystyle {\\bar {\\Gamma }}(\\tau )} , which quantifies all monotype variables not bound in Γ {\\displaystyle \\Gamma } . Formally, to validate that this new rule system ⊢ S {\\displaystyle \\vdash _{S}} is equivalent to the original ⊢ D {\\displaystyle \\vdash _{D}} , one has to show that Γ ⊢ D e : σ ⇔ Γ ⊢ S e : σ {\\displaystyle \\Gamma \\vdash _{D}\\ e:\\sigma \\Leftrightarrow \\Gamma \\vdash _{S}\\ e:\\sigma } , which decomposes into two sub-proofs: Γ ⊢ D e : σ ⇐ Γ ⊢ S e : σ {\\displaystyle \\Gamma \\vdash _{D}\\ e:\\sigma \\Leftarrow \\Gamma \\vdash _{S}\\ e:\\sigma } (Consistency) Γ ⊢ D e : σ ⇒ Γ ⊢ S e : σ {\\displaystyle \\Gamma \\vdash _{D}\\ e:\\sigma \\Rightarrow \\Gamma \\vdash _{S}\\ e:\\sigma } (Completeness) While consistency can be seen by decomposing the rules [ L e t ] {\\displaystyle [{\\mathtt {Let}}]} and [ V a r ] {\\displaystyle [{\\mathtt {Var}}]} of ⊢ S {\\displaystyle \\vdash _{S}} into proofs in ⊢ D {\\displaystyle \\vdash _{D}} , it is likely visible that ⊢ S {\\displaystyle \\vdash _{S}} is incomplete, as one cannot show λ x . x : ∀ α . α → α {\\displaystyle \\lambda \\ x.x:\\forall \\alpha .\\alpha \\rightarrow \\alpha } in ⊢ S {\\displaystyle \\vdash _{S}} , for instance, but only λ x . x : α → α {\\displaystyle \\lambda \\ x.x:\\alpha \\rightarrow \\alpha } . An only slightly weaker version of completeness is provable though, namely Γ ⊢ D e : σ ⇒ Γ ⊢ S e : τ ∧ Γ ¯ ( τ ) ⊑ σ {\\displaystyle \\Gamma \\vdash _{D}\\ e:\\sigma \\Rightarrow \\Gamma \\vdash _{S}\\ e:\\tau \\wedge {\\bar {\\Gamma }}(\\tau )\\sqsubseteq \\sigma } implying, one can derive the principal type for an expression in ⊢ S {\\displaystyle \\vdash _{S}} allowing us to generalize the proof in the end. Comparing ⊢ D {\\displaystyle \\vdash _{D}} and ⊢ S {\\displaystyle \\vdash _{S}} , now only monotypes appear in the judgments of all rules. Additionally, the shape of any possible proof with the deduction system is now identical to the shape of the expression (both seen as trees). Thus the expression fully determines the shape of the proof. In ⊢ D {\\displaystyle \\vdash _{D}} the shape would likely be determined with respect to all rules except [ I n s t ] {\\displaystyle [{\\mathtt {Inst}}]} and [ G e n ] {\\displaystyle [{\\mathtt {Gen}}]} , which allow building arbitrarily long branches (chains) between the other nodes. === Degrees of freedom instantiating the rules === Now that the shape of the proof is known, one is already close to formulating a type inference algorithm. Because any proof for a given expression must have the same shape, one can assume the monotypes in the proof's judgements to be undetermined and consider how to determine them. Here, the substitution (specialisation) order comes into play. Although at the first glance one cannot determine the types locally, the hope is that it is possible to refine them with the help of the order while traversing the proof tree, additionally assuming, because the resulting algorithm is to become an inference method, that the type in any premise will be determined as the best possible. And in fact, one can, as looking at the rules of ⊢ S {\\displaystyle \\vdash _{S}} suggests: [Abs]: The critical choice is τ. At this point, nothing is known about τ, so one can only assume the most general type, which is ∀ α . α {\\displaystyle \\forall \\alpha .\\alpha } . The plan is to specialize the type if it should become necessary. Unfortunately, a polytype is not permitted in this place, so some α has to do for the moment. To avoid unwanted captures, a type variable not yet in the proof is a safe choice. Additionally, one has to keep in mind that this monotype is not yet fixed, but might be further refined. [Var]: The choice is how to refine σ. Because any choice of a type τ here depends on the usage of the variable, which is not locally known, the safest bet is the most general one. Using the same method as above one can instantiate all quantified variables in σ with fresh monotype variables, again keeping them open to further refinement. [Let]: The rule does not leave any choice. Done. [App]: Only the application rule might force a refinement to the variables \"opened\" so far, as required by both premises. The first premise forces the outcome of the inference to be of the form τ → τ ′ {\\displaystyle \\tau \\rightarrow \\tau '} . If it is, then fine. One can later pick its τ' for the result. If not, it might be an open variable. Then this can be refined to the required form with two new variables as before. Otherwise, the type checking fails because the first premise inferred a type which is not and cannot be made into a function type. The second premise requires that the inferred type is equal to τ of the first premise. Now there are two possibly different types, perhaps with open type variables, at hand to compare and to make equal if it is possible. If it is, a refinement is found, and if not, a type error is detected again. An effective method is known to \"make two terms equal\" by substitution, Robinson's Unification in combination with the so-called Union-Find algorithm. To briefly summarize the union-find algorithm, given the set of all types in a proof, it allows one to group them together into equivalence classes by means of a union procedure and to pick a representative for each such class using a find procedure. Emphasizing the word procedure in the sense of side effect, we're clearly leaving the realm of logic in order to prepare an effective algorithm. The representative of a u n i o n ( a , b ) {\\displaystyle {\\mathtt {union}}(a,b)} is determined such that, if both a and b are type variables then the representative is arbitrarily one of them, but while uniting a variable and a term, the term becomes the representative. Assuming an implementation of union-find at hand, one can formulate the unification of two monotypes as follows: unify(ta, tb): ta = find(ta) tb = find(tb) if both ta,tb are terms of the form D p1..pn with identical D,n then unify(ta[i], tb[i]) for each corresponding ith parameter else if at least one of ta,tb is a type variable then union(ta, tb) else error 'types do not match' Now having a sketch of an inference algorithm at hand, a more formal presentation is given in the next section. It is described in Milner P. 370 ff. as algorithm J. === Algorithm J === The presentation of Algorithm J is a misuse of the notation of logical rules, since it includes side effects but allows a direct comparison with ⊢ S {\\displaystyle \\vdash _{S}} while expressing an efficient implementation at the same time. The rules now specify a procedure with parameters Γ , e {\\displaystyle \\Gamma ,e} yielding τ {\\displaystyle \\tau } in the conclusion where the execution of the premises proceeds from left to right. The procedure i n s t ( σ ) {\\displaystyle inst(\\sigma )} specializes the polytype σ {\\displaystyle \\sigma } by copying the term and replacing the bound type variables consistently by new monotype variables. ' n e w v a r {\\displaystyle newvar} ' produces a new monotype variable. Likely, Γ ¯ ( τ ) {\\displaystyle {\\bar {\\Gamma }}(\\tau )} has to copy the type introducing new variables for the quantification to avoid unwanted captures. Overall, the algorithm now proceeds by always making the most general choice leaving the specialization to the unification, which by itself produces the most general result. As noted above, the final result τ {\\displaystyle \\tau } has to be generalized to Γ ¯ ( τ ) {\\displaystyle {\\bar {\\Gamma }}(\\tau )} in the end, to gain the most general type for a given expression. Because the procedures used in the algorithm have nearly O(1) cost, the overall cost of the algorithm is close to linear in the size of the expression for which a type is to be inferred. This is in strong contrast to many other attempts to derive type inference algorithms, which often came out to be NP-hard, if not undecidable with respect to termination. Thus the HM performs as well as the best fully informed type-checking algorithms can. Type-checking here means that an algorithm does not have to find a proof, but only to validate a given one. Efficiency is slightly reduced because the binding of type variables in the context has to be maintained to allow computation of Γ ¯ ( τ ) {\\displaystyle {\\bar {\\Gamma }}(\\tau )} and enable an occurs check to prevent the building of recursive types during u n i f y ( α , τ ) {\\displaystyle {\\mathit {unify}}(\\alpha ,\\tau )} . An example of such a case is λ x . ( x x ) {\\displaystyle \\lambda \\ x.(x\\ x)} , for which no type can be derived using HM. Practically, types are only small terms and do not build up expanding structures. Thus, in complexity analysis, one can treat comparing them as a constant, retaining O(1) costs. == Proving the algorithm == In the previous section, while sketching the algorithm its proof was hinted at with metalogical argumentation. While this leads to an efficient algorithm J, it is not clear whether the algorithm properly reflects the deduction systems D or S which serve as a semantic base line. The most critical point in the above argumentation is the refinement of monotype variables bound by the context. For instance, the algorithm boldly changes the context while inferring e.g. λ f . ( f 1 ) {\\displaystyle \\lambda f.(f\\ 1)} , because the monotype variable added to the context for the parameter f {\\displaystyle f} later needs to be refined to i n t → β {\\displaystyle int\\rightarrow \\beta } when handling application. The problem is that the deduction rules do not allow such a refinement. Arguing that the refined type could have been added earlier instead of the monotype variable is an expedient at best. The key to reaching a formally satisfying argument is to properly include the context within the refinement. Formally, typing is compatible with substitution of free type variables. Γ ⊢ S e : τ ⟹ S Γ ⊢ S e : S τ {\\displaystyle \\Gamma \\vdash _{S}e:\\tau \\quad \\Longrightarrow \\quad S\\Gamma \\vdash _{S}e:S\\tau } To refine the free variables thus means to refine the whole typing. === Algorithm W === From there, a proof of algorithm J leads to algorithm W, which only makes the side effects imposed by the procedure union {\\displaystyle {\\textit {union}}} explicit by expressing its serial composition by means of the substitutions S i {\\displaystyle S_{i}} . The presentation of algorithm W in the sidebar still makes use of side effects in the operations set in italic, but these are now limited to generating fresh symbols. The form of judgement is Γ ⊢ e : τ , S {\\displaystyle \\Gamma \\vdash e:\\tau ,S} , denoting a function with a context and expression as parameter producing a monotype together with a substitution. mgu {\\displaystyle {\\textsf {mgu}}} is a side-effect free version of union {\\displaystyle {\\textit {union}}} producing a substitution which is the most general unifier. While algorithm W is normally considered to be the HM algorithm and is often directly presented after the rule system in literature, its purpose is described by Milner on P. 369 as follows: As it stands, W is hardly an efficient algorithm; substitutions are applied too often. It was formulated to aid the proof of soundness. We now present a simpler algorithm J which simulates W in a precise sense. While he considered W more complicated and less efficient, he presented it in his publication before J. It has its merits when side effects are unavailable or unwanted. W is also needed to prove completeness, which is factored by him into the soundness proof. === Proof obligations === Before formulating the proof obligations, a deviation between the rules systems D and S and the algorithms presented needs to be emphasized. While the development above sort of misused the monotypes as \"open\" proof variables, the possibility that proper monotype variables might be harmed was sidestepped by introducing fresh variables and hoping for the best. But there's a catch: One of the promises made was that these fresh variables would be \"kept in mind\" as such. This promise is not fulfilled by the algorithm. Having a context 1 : i n t , f : α {\\displaystyle 1:int,\\ f:\\alpha } , the expression f 1 {\\displaystyle f\\ 1} cannot be typed in either ⊢ D {\\displaystyle \\vdash _{D}} or ⊢ S {\\displaystyle \\vdash _{S}} , but the algorithms come up with the type β {\\displaystyle \\beta } , where W additionally delivers the substitution { α ↦ i n t → β } {\\displaystyle \\left\\{\\alpha \\mapsto int\\rightarrow \\beta \\right\\}} , meaning that the algorithm fails to detect all type errors. This omission can easily be fixed by more carefully distinguishing proof variables and monotype variables. The authors were well aware of the problem but decided not to fix it. One might assume a pragmatic reason behind this. While more properly implementing the type inference would have enabled the algorithm to deal with abstract monotypes, they were not needed for the intended application where none of the items in a preexisting context have free variables. In this light, the unneeded complication was dropped in favor of a simpler algorithm. The remaining downside is that the proof of the algorithm with respect to the rule system is less general and can only be made for contexts with f r e e ( Γ ) = ∅ {\\displaystyle free(\\Gamma )=\\emptyset } as a side condition. (Correctness) Γ ⊢ W e : τ , S ⟹ Γ ⊢ S e : τ (Completeness) Γ ⊢ S e : τ ⟹ Γ ⊢ W e : τ ′ , S forall τ where ∅ ¯ ( τ ′ ) ⊑ τ {\\displaystyle {\\begin{array}{lll}{\\text{(Correctness)}}&\\Gamma \\vdash _{W}e:\\tau ,S&\\quad \\Longrightarrow \\quad \\Gamma \\vdash _{S}e:\\tau \\\\{\\text{(Completeness)}}&\\Gamma \\vdash _{S}e:\\tau &\\quad \\Longrightarrow \\quad \\Gamma \\vdash _{W}e:\\tau ',S\\quad \\quad {\\text{forall}}\\ \\tau \\ {\\text{where}}\\ {\\overline {\\emptyset }}(\\tau ')\\sqsubseteq \\tau \\end{array}}} The side condition in the completeness obligation addresses how the deduction may give many types, while the algorithm always produces one. At the same time, the side condition demands that the type inferred is actually the most general. To properly prove the obligations one needs to strengthen them first to allow activating the substitution lemma threading the substitution S {\\displaystyle S} through ⊢ S {\\displaystyle \\vdash _{S}} and ⊢ W {\\displaystyle \\vdash _{W}} . From there, the proofs are by induction over the expression. Another proof obligation is the substitution lemma itself, i.e. the substitution of the typing, which finally establishes the all-quantification. The later cannot formally be proven, since no such syntax is at hand. == Extensions == === Recursive definitions === To make programming practical recursive functions are needed. A central property of the lambda calculus is that recursive definitions are not directly available, but can instead be expressed with a fixed point combinator. But unfortunately, the fixpoint combinator cannot be formulated in a typed version of the lambda calculus without having a disastrous effect on the system as outlined below. ==== Typing rule ==== The original paper shows recursion can be realized by a combinator f i x : ∀ α . ( α → α ) → α {\\displaystyle {\\mathit {fix}}:\\forall \\alpha .(\\alpha \\rightarrow \\alpha )\\rightarrow \\alpha } . A possible recursive definition could thus be formulated as r e c v = e 1 i n e 2 ::= l e t v = f i x ( λ v . e 1 ) i n e 2 {\\displaystyle {\\mathtt {rec}}\\ v=e_{1}\\ {\\mathtt {in}}\\ e_{2}\\ ::={\\mathtt {let}}\\ v={\\mathit {fix}}(\\lambda v.e_{1})\\ {\\mathtt {in}}\\ e_{2}} . Alternatively an extension of the expression syntax and an extra typing rule is possible: Γ , Γ ′ ⊢ e 1 : τ 1 … Γ , Γ ′ ⊢ e n : τ n Γ , Γ ″ ⊢ e : τ Γ ⊢ r e c v 1 = e 1 a n d … a n d v n = e n i n e : τ [ R e c ] {\\displaystyle \\displaystyle {\\frac {\\Gamma ,\\Gamma '\\vdash e_{1}:\\tau _{1}\\quad \\dots \\quad \\Gamma ,\\Gamma '\\vdash e_{n}:\\tau _{n}\\quad \\Gamma ,\\Gamma ''\\vdash e:\\tau }{\\Gamma \\ \\vdash \\ {\\mathtt {rec}}\\ v_{1}=e_{1}\\ {\\mathtt {and}}\\ \\dots \\ {\\mathtt {and}}\\ v_{n}=e_{n}\\ {\\mathtt {in}}\\ e:\\tau }}\\quad [{\\mathtt {Rec}}]} where Γ ′ = v 1 : τ 1 , … , v n : τ n {\\displaystyle \\Gamma '=v_{1}:\\tau _{1},\\ \\dots ,\\ v_{n}:\\tau _{n}} Γ ″ = v 1 : Γ ¯ ( τ 1 ) , … , v n : Γ ¯ ( τ n ) {\\displaystyle \\Gamma ''=v_{1}:{\\bar {\\Gamma }}(\\ \\tau _{1}\\ ),\\ \\dots ,\\ v_{n}:{\\bar {\\Gamma }}(\\ \\tau _{n}\\ )} basically merging [ A b s ] {\\displaystyle [{\\mathtt {Abs}}]} and [ L e t ] {\\displaystyle [{\\mathtt {Let}}]} while including the recursively defined variables in monotype positions where they occur to the left of the i n {\\displaystyle {\\mathtt {in}}} but as polytypes to the right of it. ==== Consequences ==== While the above is straightforward it does come at a price. Type theory connects lambda calculus with computation and logic. The easy modification above has effects on both: The strong normalisation property is invalidated, because non-terminating terms can be formulated. The logic collapses because the type ∀ a . a {\\displaystyle \\forall a.a} becomes inhabited. === Overloading === Overloading means that different functions can be defined and used with the same name. Most programming languages at least provide overloading with the built-in arithmetic operations (+, <, etc.), to allow the programmer to write arithmetic expressions in the same form, even for different numerical types like int or real. Because a mixture of these different types within the same expression also demands for implicit conversion, overloading especially for these operations is often built into the programming language itself. In some languages, this feature is generalized and made available to the user, e.g. in C++. While ad hoc overloading has been avoided in functional programming for the computation costs both in type checking and inference, a means to systematise overloading has been introduced that resembles both in form and naming to object oriented programming, but works one level upwards. \"Instances\" in this systematic are not objects (i.e. on value level), but rather types. The quicksort example mentioned in the introduction uses the overloading in the orders, having the following type annotation in Haskell: Herein, the type a is not only polymorphic, but also restricted to be an instance of some type class Ord, that provides the order predicates < and >= used in the functions body. The proper implementations of these predicates are then passed to quicksorts as additional parameters, as soon as quicksort is used on more concrete types providing a single implementation of the overloaded function quickSort. Because the \"classes\" only allow a single type as their argument, the resulting type system can still provide inference. Additionally, the type classes can then be equipped with some kind of overloading order allowing one to arrange the classes as a lattice. === Higher-order types === Parametric polymorphism implies that types themselves are passed as parameters as if they were proper values. Passed as arguments to a proper functions, but also into \"type functions\" as in the \"parametric\" type constants, leads to the question how to more properly type types themselves. Higher-order types are used to create an even more expressive type system. Unfortunately, unification is no longer decidable in the presence of meta types, rendering type inference impossible in this extend of generality. Additionally, assuming a type of all types that includes itself as type leads into a paradox, as in the set of all sets, so one must proceed in steps of levels of abstraction. Research in second order lambda calculus, one step upwards, showed that type inference is undecidable in this generality. Haskell introduces one higher level named kind. In standard Haskell, kinds are inferred and used for little more than to describe the arity of type constructors. e.g. a list type constructor is thought of as mapping a type (the type of its elements) to another type (the type of the list containing said elements); notationally this is expressed as ∗ → ∗ {\\displaystyle *\\to *} . Language extensions are available which extend kinds to emulate features of a dependent type system. === Subtyping === Attempts to combine subtyping and type inference have caused quite some frustration. It is straightforward to accumulate and propagate subtyping constraints (as opposed to type equality constraints), making the resulting constraints part of the inferred typing schemes, for example ∀ α . ( α ≤ T ) ⇒ α → α {\\displaystyle \\forall \\alpha .\\ (\\alpha \\leq T)\\Rightarrow \\alpha \\rightarrow \\alpha } , where α ≤ T {\\displaystyle \\alpha \\leq T} is a constraint on the type variable α {\\displaystyle \\alpha } . However, because type variables are no longer unified eagerly in this approach, it tends to generate large and unwieldy typing schemes containing many useless type variables and constraints, making them hard to read and understand. Therefore, considerable effort was put into simplifying such typing schemes and their constraints, using techniques similar to those of nondeterministic finite automaton (NFA) simplification (useful in the presence of inferred recursive types). More recently, Dolan and Mycroft formalized the relationship between typing scheme simplification and NFA simplification and showed that an algebraic take on the formalization of subtyping allowed generating compact principal typing schemes for an ML-like language (called MLsub). Notably, their proposed typing scheme used a restricted form of union and intersection types instead of explicit constraints. Parreaux later claimed that this algebraic formulation was equivalent to a relatively simple algorithm resembling Algorithm W, and that the use of union and intersection types was not essential. On the other hand, type inference has proven more difficult in the context of object-oriented programming languages, because object methods tend to require first-class polymorphism in the style of System F (where type inference is undecidable) and because of features like F-bounded polymorphism. Consequently, type systems with subtyping enabling object-oriented programming, such as Cardelli's system F <: {\\displaystyle F_{<:}} , do not support HM-style type inference. Row polymorphism can be used as an alternative to subtyping for supporting language features like structural records. While this style of polymorphism is less flexible than subtyping in some ways, notably requiring more polymorphism than strictly necessary to cope with the lack of directionality in type constraints, it has the advantage that it can be integrated with the standard HM algorithms quite easily. == Notes == == References == == External links == A literate Haskell implementation of Algorithm W along with its source code on GitHub. A simple implementation of Hindley-Milner algorithm in Python."
  },
  "chunks": [
    {
      "id": "hindleymilnertypesys_4f4e0343_c0000",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 939,
      "content": "A Hindley–Milner (HM) type system is a classical type system for the lambda calculus with parametric polymorphism. It is also known as Damas–Milner or Damas–Hindley–Milner. It was first described by J. Roger Hindley and later rediscovered by Robin Milner. Luis Damas contributed a close formal analysis and proof of the method in his PhD thesis. Among HM's more notable properties are its completeness and its ability to infer the most general type of a given program without programmer-supplied type annotations or other hints. Algorithm W is an efficient type inference method in practice and has been successfully applied on large code bases, although it has a high theoretical complexity. HM is preferably used for functional languages. It was first implemented as part of the type system of the programming language ML. Since then, HM has been extended in various ways, most notably with type class constraints like those in Haskell.",
      "char_count": 938,
      "token_estimate": 234,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0001",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== Introduction ==",
      "heading_path": "== Introduction ==",
      "start_char": 957,
      "end_char": 1836,
      "content": "== Introduction == As a type inference method, Hindley–Milner is able to deduce the types of variables, expressions and functions from programs written in an entirely untyped style. Being scope sensitive, it is not limited to deriving the types only from a small portion of source code, but rather from complete programs or modules. Being able to cope with parametric types, too, it is core to the type systems of many functional programming languages. It was first applied in this manner in the ML programming language. The origin is the type inference algorithm for the simply typed lambda calculus that was devised by Haskell Curry and Robert Feys in 1958. In 1969, J. Roger Hindley extended this work and proved that their algorithm always inferred the most general type. In 1978, Robin Milner, independently of Hindley's work, provided an equivalent algorithm, Algorithm W.",
      "char_count": 878,
      "token_estimate": 219,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0002",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Monomorphism vs. polymorphism ==",
      "heading_path": "== = Monomorphism vs. polymorphism ==",
      "start_char": 1990,
      "end_char": 2894,
      "content": "== = Monomorphism vs. polymorphism === In the simply typed lambda calculus, types T are either atomic type constants or function types of form T → T {\\displaystyle T\\rightarrow T} . Such types are monomorphic. Typical examples are the types used in arithmetic values: 3 : Number add 3 4 : Number add : Number -> Number -> Number Contrary to this, the untyped lambda calculus is neutral to typing at all, and many of its functions can be meaningfully applied to all type of arguments. The trivial example is the identity function id ≡ λ x . x which simply returns whatever value it is applied to. Less trivial examples include parametric types like lists. While polymorphism in general means that operations accept values of more than one type, the polymorphism used here is parametric. One finds the notation of type schemes in the literature, too, emphasizing the parametric nature of the polymorphism.",
      "char_count": 903,
      "token_estimate": 225,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0003",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Monomorphism vs. polymorphism ==",
      "heading_path": "== = Monomorphism vs. polymorphism ==",
      "start_char": 2894,
      "end_char": 3826,
      "content": "Additionally, constants may be typed with (quantified) type variables. E.g.: cons : forall a . a -> List a -> List a nil : forall a . List a id : forall a . a -> a Polymorphic types can become monomorphic by consistent substitution of their variables. Examples of monomorphic instances are: id' : String -> String nil' : List Number More generally, types are polymorphic when they contain type variables, while types without them are monomorphic. Contrary to the type systems used for example in Pascal (1970) or C (1972), which only support monomorphic types, HM is designed with emphasis on parametric polymorphism. The successors of the languages mentioned, like C++ (1985), focused on different types of polymorphism, namely subtyping in connection with object-oriented programming and overloading. While subtyping is incompatible with HM, a variant of systematic overloading is available in the HM-based type system of Haskell.",
      "char_count": 932,
      "token_estimate": 233,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0004",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Let-polymorphism ==",
      "heading_path": "== = Let-polymorphism ==",
      "start_char": 3814,
      "end_char": 4738,
      "content": "== = Let-polymorphism === When extending the type inference for the simply-typed lambda calculus towards polymorphism, one has to decide whether assigning a polymorphic type not only as type of an expression, but also as the type of a λ-bound variable is admissible. This would allow the generic identity type to be assigned to the variable 'id' in: (λ id . ... (id 3) ... (id \"text\") ... ) (λ x . x) Allowing this gives rise to the polymorphic lambda calculus; however, unfortunately, type inference in this system is not decidable. Instead, HM distinguishes variables that are immediately bound to an expression from more general λ-bound variables, calling the former let-bound variables, and allows polymorphic types to be assigned only to these. This leads to let-polymorphism where the above example takes the form let id = λ x . x in ... (id 3) ... (id \"text\") ... which can be typed with a polymorphic type for 'id'.",
      "char_count": 923,
      "token_estimate": 230,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0005",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Let-polymorphism ==",
      "heading_path": "== = Let-polymorphism ==",
      "start_char": 4738,
      "end_char": 5029,
      "content": "As indicated, the expression syntax is extended to make the let-bound variables explicit, and by restricting the type system to allow only let-bound variable to have polymorphic types, while the parameters in lambda-abstractions must get a monomorphic type, type inference becomes decidable.",
      "char_count": 291,
      "token_estimate": 72,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0006",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== Overview ==",
      "heading_path": "== Overview ==",
      "start_char": 5020,
      "end_char": 5896,
      "content": "== Overview == The remainder of this article proceeds as follows: The HM type system is defined. This is done by describing a deduction system that makes precise what expressions have what type, if any. From there, it works towards an implementation of the type inference method. After introducing a syntax-driven variant of the above deductive system, it sketches an efficient implementation (algorithm J), appealing mostly to the reader's metalogical intuition. Because it remains open whether algorithm J indeed realises the initial deduction system, a less efficient implementation (algorithm W), is introduced and its use in a proof is hinted. Finally, further topics related to the algorithm are discussed. The same description of the deduction system is used throughout, even for the two algorithms, to make the various forms in which the HM method is presented directly comparable.",
      "char_count": 889,
      "token_estimate": 222,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0007",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== The Hindley–Milner type system ==",
      "heading_path": "== The Hindley–Milner type system ==",
      "start_char": 5932,
      "end_char": 6403,
      "content": "== The Hindley–Milner type system == The type system can be formally described by syntax rules that fix a language for the expressions, types, etc. The presentation here of such a syntax is not too formal, in that it is written down not to study the surface grammar, but rather the depth grammar, and leaves some syntactical details open. This form of presentation is usual. Building on this, typing rules are used to define how expressions and types are related. As before, the form used is a bit liberal.",
      "char_count": 506,
      "token_estimate": 126,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0008",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Syntax ==",
      "heading_path": "== = Syntax ==",
      "start_char": 6417,
      "end_char": 6771,
      "content": "== = Syntax === The expressions to be typed are exactly those of the lambda calculus extended with a let-expression as shown in the adjacent table. Parentheses can be used to disambiguate an expression. The application is left-binding and binds stronger than abstraction or the let-in construct. Types are syntactically split into two groups, monotypes and polytypes.",
      "char_count": 367,
      "token_estimate": 91,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0009",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Type order ==",
      "heading_path": "== = Type order ==",
      "start_char": 6789,
      "end_char": 7759,
      "content": "== = Type order === Polymorphism means that one and the same expression can have (perhaps infinitely) many types. But in this type system, these types are not completely unrelated, but rather orchestrated by the parametric polymorphism. As an example, the identity λ x . x {\\displaystyle \\lambda x.x} can have ∀ α . α → α {\\displaystyle \\forall \\alpha .\\alpha \\rightarrow \\alpha } as its type as well as string → string {\\displaystyle {\\texttt {string}}\\rightarrow {\\texttt {string}}} or int → int {\\displaystyle {\\texttt {int}}\\rightarrow {\\texttt {int}}} and many others, but not int → string {\\displaystyle {\\texttt {int}}\\rightarrow {\\texttt {string}}} . The most general type for this function is ∀ α . α → α {\\displaystyle \\forall \\alpha .\\alpha \\rightarrow \\alpha } , while the others are more specific and can be derived from the general one by consistently replacing another type for the type parameter, i.e. the quantified variable α {\\displaystyle \\alpha } .",
      "char_count": 969,
      "token_estimate": 242,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0010",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Type order ==",
      "heading_path": "== = Type order ==",
      "start_char": 7759,
      "end_char": 8677,
      "content": "The counter-example fails because the replacement is not consistent. The consistent replacement can be made formal by applying a substitution S = { a i ↦ τ i , … } {\\displaystyle S=\\left\\{\\ a_{i}\\mapsto \\tau _{i},\\ \\dots \\ \\right\\}} to the term of a type τ {\\displaystyle \\tau } , written S τ {\\displaystyle S\\tau } . As the example suggests, substitution is not only strongly related to an order, that expresses that a type is more or less special, but also with the all-quantification which allows the substitution to be applied. Formally, in HM, a type σ ′ {\\displaystyle \\sigma '} is more general than σ {\\displaystyle \\sigma } , formally σ ′ ⊑ σ {\\displaystyle \\sigma '\\sqsubseteq \\sigma } , if some quantified variable in σ ′ {\\displaystyle \\sigma '} is consistently substituted such that one gains σ {\\displaystyle \\sigma } as shown in the side bar. This order is part of the type definition of the type system.",
      "char_count": 918,
      "token_estimate": 229,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0011",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Type order ==",
      "heading_path": "== = Type order ==",
      "start_char": 8678,
      "end_char": 9584,
      "content": "In our previous example, applying the substitution S = { α ↦ string } {\\displaystyle S=\\left\\{\\alpha \\mapsto {\\texttt {string}}\\right\\}} would result in ∀ α . α → α ⊑ string → string {\\displaystyle \\forall \\alpha .\\alpha \\rightarrow \\alpha \\sqsubseteq {\\texttt {string}}\\rightarrow {\\texttt {string}}} . While substituting a monomorphic (ground) type for a quantified variable is straight forward, substituting a polytype has some pitfalls caused by the presence of free variables. Most particularly, unbound variables must not be replaced. They are treated as constants here. Additionally, quantifications can only occur top-level. Substituting a parametric type, one has to lift its quantifiers. The table on the right makes the rule precise. Alternatively, consider an equivalent notation for the polytypes without quantifiers in which quantified variables are represented by a different set of symbols.",
      "char_count": 906,
      "token_estimate": 226,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0012",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Type order ==",
      "heading_path": "== = Type order ==",
      "start_char": 9585,
      "end_char": 9822,
      "content": "In such a notation, the specialization reduces to plain consistent replacement of such variables. The relation ⊑ {\\displaystyle \\sqsubseteq } is a partial order and ∀ α . α {\\displaystyle \\forall \\alpha .\\alpha } is its smallest element.",
      "char_count": 237,
      "token_estimate": 59,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0013",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Deductive system ==",
      "heading_path": "== = Deductive system ==",
      "start_char": 9829,
      "end_char": 10572,
      "content": "== = Deductive system === The syntax of HM is carried forward to the syntax of the inference rules that form the body of the formal system, by using the typings as judgments. Each of the rules define what conclusion could be drawn from what premises. Additionally to the judgments, some extra conditions introduced above might be used as premises, too. A proof using the rules is a sequence of judgments such that all premises are listed before a conclusion. The examples below show a possible format of proofs. From left to right, each line shows the conclusion, the [ N a m e ] {\\displaystyle [{\\mathtt {Name}}]} of the rule applied and the premises, either by referring to an earlier line (number) if the premise is a judgment or by making the predicate explicit.",
      "char_count": 766,
      "token_estimate": 191,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0014",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Let-polymorphism ==",
      "heading_path": "== = Let-polymorphism ==",
      "start_char": 10596,
      "end_char": 11496,
      "content": "== = Let-polymorphism === Not visible immediately, the rule set encodes a regulation under which circumstances a type might be generalized or not by a slightly varying use of mono- and polytypes in the rules [ A b s ] {\\displaystyle [{\\mathtt {Abs}}]} and [ L e t ] {\\displaystyle [{\\mathtt {Let}}]} . Remember that σ {\\displaystyle \\sigma } and τ {\\displaystyle \\tau } denote poly- and monotypes respectively. In rule [ A b s ] {\\displaystyle [{\\mathtt {Abs}}]} , the value variable of the parameter of the function λ x . e {\\displaystyle \\lambda x.e} is added to the context with a monomorphic type through the premise Γ , x : τ ⊢ D e : τ ′ {\\displaystyle \\Gamma ,\\ x:\\tau \\vdash _{D}e:\\tau '} , while in the rule [ L e t ] {\\displaystyle [{\\mathtt {Let}}]} , the variable enters the environment in polymorphic form Γ , x : σ ⊢ D e 1 : τ {\\displaystyle \\Gamma ,\\ x:\\sigma \\vdash _{D}e_{1}:\\tau } .",
      "char_count": 899,
      "token_estimate": 224,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0015",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Let-polymorphism ==",
      "heading_path": "== = Let-polymorphism ==",
      "start_char": 11496,
      "end_char": 12411,
      "content": "Though in both cases the presence of x {\\displaystyle x} in the context prevents the use of the generalisation rule for any free variable in the assignment, this regulation forces the type of parameter x {\\displaystyle x} in a λ {\\displaystyle \\lambda } -expression to remain monomorphic, while in a let-expression, the variable could be introduced polymorphic, making specializations possible. As a consequence of this regulation, λ f . ( f true , f 0 ) {\\displaystyle \\lambda f.(f\\,{\\textrm {true}},f\\,{\\textrm {0}})} cannot be typed, since the parameter f {\\displaystyle f} is in a monomorphic position, while let f = λ x . x in ( f true , f 0 ) {\\displaystyle {\\textbf {let}}\\ f=\\lambda x.x\\,{\\textbf {in}}\\,(f\\,{\\textrm {true}},f\\,{\\textrm {0}})} has type ( b o o l , i n t ) {\\displaystyle (bool,int)} , because f {\\displaystyle f} has been introduced in a let-expression and is treated polymorphic therefore.",
      "char_count": 915,
      "token_estimate": 228,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0016",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Generalization rule ==",
      "heading_path": "== = Generalization rule ==",
      "start_char": 12415,
      "end_char": 13030,
      "content": "== = Generalization rule === The generalisation rule is also worth a closer look. Here, the all-quantification implicit in the premise Γ ⊢ D e : σ {\\displaystyle \\Gamma \\vdash _{D}e:\\sigma } is simply moved to the right hand side of ⊢ D {\\displaystyle \\vdash _{D}} in the conclusion, bound by an explicit universal quantifier. This is possible, since α {\\displaystyle \\alpha } does not occur free in the context. Again, while this makes the generalization rule plausible, it is not really a consequence. On the contrary, the generalization rule is part of the definition of HM's type system and the implicit all-quantification a consequence.",
      "char_count": 641,
      "token_estimate": 160,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0017",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== An inference algorithm ==",
      "heading_path": "== An inference algorithm ==",
      "start_char": 13058,
      "end_char": 13420,
      "content": "== An inference algorithm == Now that the deduction system of HM is at hand, one could present an algorithm and validate it with respect to the rules. Alternatively, it might be possible to derive it by taking a closer look on how the rules interact and proof are formed. This is done in the remainder of this article focusing on the possible decisions one can make while proving a typing.",
      "char_count": 389,
      "token_estimate": 97,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0018",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Degrees of freedom choosing the rules ==",
      "heading_path": "== = Degrees of freedom choosing the rules ==",
      "start_char": 13465,
      "end_char": 14385,
      "content": "== = Degrees of freedom choosing the rules === Isolating the points in a proof, where no decision is possible at all, the first group of rules centered around the syntax leaves no choice since to each syntactical rule corresponds a unique typing rule, which determines a part of the proof, while between the conclusion and the premises of these fixed parts chains of [ I n s t ] {\\displaystyle [{\\mathtt {Inst}}]} and [ G e n ] {\\displaystyle [{\\mathtt {Gen}}]} could occur. Such a chain could also exist between the conclusion of the proof and the rule for topmost expression. All proofs must have the so sketched shape. Because the only choice in a proof with respect of rule selection are the [ I n s t ] {\\displaystyle [{\\mathtt {Inst}}]} and [ G e n ] {\\displaystyle [{\\mathtt {Gen}}]} chains, the form of the proof suggests the question whether it can be made more precise, where these chains might not be needed.",
      "char_count": 919,
      "token_estimate": 229,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0019",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Syntax-directed rule system ==",
      "heading_path": "== = Syntax-directed rule system ==",
      "start_char": 14463,
      "end_char": 15096,
      "content": "== = Syntax-directed rule system === A contemporary treatment of HM uses a purely syntax-directed rule system due to Clement as an intermediate step. In this system, the specialization is located directly after the original [ V a r ] {\\displaystyle [{\\mathtt {Var}}]} rule and merged into it, while the generalization becomes part of the [ L e t ] {\\displaystyle [{\\mathtt {Let}}]} rule. There the generalization is also determined to always produce the most general type by introducing the function Γ ¯ ( τ ) {\\displaystyle {\\bar {\\Gamma }}(\\tau )} , which quantifies all monotype variables not bound in Γ {\\displaystyle \\Gamma } .",
      "char_count": 632,
      "token_estimate": 158,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0020",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Syntax-directed rule system ==",
      "heading_path": "== = Syntax-directed rule system ==",
      "start_char": 15096,
      "end_char": 16010,
      "content": "Formally, to validate that this new rule system ⊢ S {\\displaystyle \\vdash _{S}} is equivalent to the original ⊢ D {\\displaystyle \\vdash _{D}} , one has to show that Γ ⊢ D e : σ ⇔ Γ ⊢ S e : σ {\\displaystyle \\Gamma \\vdash _{D}\\ e:\\sigma \\Leftrightarrow \\Gamma \\vdash _{S}\\ e:\\sigma } , which decomposes into two sub-proofs: Γ ⊢ D e : σ ⇐ Γ ⊢ S e : σ {\\displaystyle \\Gamma \\vdash _{D}\\ e:\\sigma \\Leftarrow \\Gamma \\vdash _{S}\\ e:\\sigma } (Consistency) Γ ⊢ D e : σ ⇒ Γ ⊢ S e : σ {\\displaystyle \\Gamma \\vdash _{D}\\ e:\\sigma \\Rightarrow \\Gamma \\vdash _{S}\\ e:\\sigma } (Completeness) While consistency can be seen by decomposing the rules [ L e t ] {\\displaystyle [{\\mathtt {Let}}]} and [ V a r ] {\\displaystyle [{\\mathtt {Var}}]} of ⊢ S {\\displaystyle \\vdash _{S}} into proofs in ⊢ D {\\displaystyle \\vdash _{D}} , it is likely visible that ⊢ S {\\displaystyle \\vdash _{S}} is incomplete, as one cannot show λ x . x : ∀ α .",
      "char_count": 914,
      "token_estimate": 228,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0021",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Syntax-directed rule system ==",
      "heading_path": "== = Syntax-directed rule system ==",
      "start_char": 16011,
      "end_char": 16960,
      "content": "α → α {\\displaystyle \\lambda \\ x.x:\\forall \\alpha .\\alpha \\rightarrow \\alpha } in ⊢ S {\\displaystyle \\vdash _{S}} , for instance, but only λ x . x : α → α {\\displaystyle \\lambda \\ x.x:\\alpha \\rightarrow \\alpha } . An only slightly weaker version of completeness is provable though, namely Γ ⊢ D e : σ ⇒ Γ ⊢ S e : τ ∧ Γ ¯ ( τ ) ⊑ σ {\\displaystyle \\Gamma \\vdash _{D}\\ e:\\sigma \\Rightarrow \\Gamma \\vdash _{S}\\ e:\\tau \\wedge {\\bar {\\Gamma }}(\\tau )\\sqsubseteq \\sigma } implying, one can derive the principal type for an expression in ⊢ S {\\displaystyle \\vdash _{S}} allowing us to generalize the proof in the end. Comparing ⊢ D {\\displaystyle \\vdash _{D}} and ⊢ S {\\displaystyle \\vdash _{S}} , now only monotypes appear in the judgments of all rules. Additionally, the shape of any possible proof with the deduction system is now identical to the shape of the expression (both seen as trees). Thus the expression fully determines the shape of the proof.",
      "char_count": 949,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0022",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Syntax-directed rule system ==",
      "heading_path": "== = Syntax-directed rule system ==",
      "start_char": 16961,
      "end_char": 17243,
      "content": "In ⊢ D {\\displaystyle \\vdash _{D}} the shape would likely be determined with respect to all rules except [ I n s t ] {\\displaystyle [{\\mathtt {Inst}}]} and [ G e n ] {\\displaystyle [{\\mathtt {Gen}}]} , which allow building arbitrarily long branches (chains) between the other nodes.",
      "char_count": 282,
      "token_estimate": 70,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0023",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Degrees of freedom instantiating the rules ==",
      "heading_path": "== = Degrees of freedom instantiating the rules ==",
      "start_char": 17259,
      "end_char": 18116,
      "content": "== = Degrees of freedom instantiating the rules === Now that the shape of the proof is known, one is already close to formulating a type inference algorithm. Because any proof for a given expression must have the same shape, one can assume the monotypes in the proof's judgements to be undetermined and consider how to determine them. Here, the substitution (specialisation) order comes into play. Although at the first glance one cannot determine the types locally, the hope is that it is possible to refine them with the help of the order while traversing the proof tree, additionally assuming, because the resulting algorithm is to become an inference method, that the type in any premise will be determined as the best possible. And in fact, one can, as looking at the rules of ⊢ S {\\displaystyle \\vdash _{S}} suggests: [Abs]: The critical choice is τ.",
      "char_count": 856,
      "token_estimate": 214,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0024",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Degrees of freedom instantiating the rules ==",
      "heading_path": "== = Degrees of freedom instantiating the rules ==",
      "start_char": 18116,
      "end_char": 18997,
      "content": "At this point, nothing is known about τ, so one can only assume the most general type, which is ∀ α . α {\\displaystyle \\forall \\alpha .\\alpha } . The plan is to specialize the type if it should become necessary. Unfortunately, a polytype is not permitted in this place, so some α has to do for the moment. To avoid unwanted captures, a type variable not yet in the proof is a safe choice. Additionally, one has to keep in mind that this monotype is not yet fixed, but might be further refined. [Var]: The choice is how to refine σ. Because any choice of a type τ here depends on the usage of the variable, which is not locally known, the safest bet is the most general one. Using the same method as above one can instantiate all quantified variables in σ with fresh monotype variables, again keeping them open to further refinement. [Let]: The rule does not leave any choice. Done.",
      "char_count": 881,
      "token_estimate": 220,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0025",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Degrees of freedom instantiating the rules ==",
      "heading_path": "== = Degrees of freedom instantiating the rules ==",
      "start_char": 18998,
      "end_char": 19851,
      "content": "[App]: Only the application rule might force a refinement to the variables \"opened\" so far, as required by both premises. The first premise forces the outcome of the inference to be of the form τ → τ ′ {\\displaystyle \\tau \\rightarrow \\tau '} . If it is, then fine. One can later pick its τ' for the result. If not, it might be an open variable. Then this can be refined to the required form with two new variables as before. Otherwise, the type checking fails because the first premise inferred a type which is not and cannot be made into a function type. The second premise requires that the inferred type is equal to τ of the first premise. Now there are two possibly different types, perhaps with open type variables, at hand to compare and to make equal if it is possible. If it is, a refinement is found, and if not, a type error is detected again.",
      "char_count": 853,
      "token_estimate": 213,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0026",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Degrees of freedom instantiating the rules ==",
      "heading_path": "== = Degrees of freedom instantiating the rules ==",
      "start_char": 19852,
      "end_char": 20671,
      "content": "An effective method is known to \"make two terms equal\" by substitution, Robinson's Unification in combination with the so-called Union-Find algorithm. To briefly summarize the union-find algorithm, given the set of all types in a proof, it allows one to group them together into equivalence classes by means of a union procedure and to pick a representative for each such class using a find procedure. Emphasizing the word procedure in the sense of side effect, we're clearly leaving the realm of logic in order to prepare an effective algorithm. The representative of a u n i o n ( a , b ) {\\displaystyle {\\mathtt {union}}(a,b)} is determined such that, if both a and b are type variables then the representative is arbitrarily one of them, but while uniting a variable and a term, the term becomes the representative.",
      "char_count": 819,
      "token_estimate": 204,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0027",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Degrees of freedom instantiating the rules ==",
      "heading_path": "== = Degrees of freedom instantiating the rules ==",
      "start_char": 20672,
      "end_char": 21218,
      "content": "Assuming an implementation of union-find at hand, one can formulate the unification of two monotypes as follows: unify(ta, tb): ta = find(ta) tb = find(tb) if both ta,tb are terms of the form D p1..pn with identical D,n then unify(ta[i], tb[i]) for each corresponding ith parameter else if at least one of ta,tb is a type variable then union(ta, tb) else error 'types do not match' Now having a sketch of an inference algorithm at hand, a more formal presentation is given in the next section. It is described in Milner P. 370 ff. as algorithm J.",
      "char_count": 546,
      "token_estimate": 136,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0028",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Algorithm J ==",
      "heading_path": "== = Algorithm J ==",
      "start_char": 21188,
      "end_char": 22084,
      "content": "== = Algorithm J === The presentation of Algorithm J is a misuse of the notation of logical rules, since it includes side effects but allows a direct comparison with ⊢ S {\\displaystyle \\vdash _{S}} while expressing an efficient implementation at the same time. The rules now specify a procedure with parameters Γ , e {\\displaystyle \\Gamma ,e} yielding τ {\\displaystyle \\tau } in the conclusion where the execution of the premises proceeds from left to right. The procedure i n s t ( σ ) {\\displaystyle inst(\\sigma )} specializes the polytype σ {\\displaystyle \\sigma } by copying the term and replacing the bound type variables consistently by new monotype variables. ' n e w v a r {\\displaystyle newvar} ' produces a new monotype variable. Likely, Γ ¯ ( τ ) {\\displaystyle {\\bar {\\Gamma }}(\\tau )} has to copy the type introducing new variables for the quantification to avoid unwanted captures.",
      "char_count": 895,
      "token_estimate": 223,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0029",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Algorithm J ==",
      "heading_path": "== = Algorithm J ==",
      "start_char": 22084,
      "end_char": 23007,
      "content": "Overall, the algorithm now proceeds by always making the most general choice leaving the specialization to the unification, which by itself produces the most general result. As noted above, the final result τ {\\displaystyle \\tau } has to be generalized to Γ ¯ ( τ ) {\\displaystyle {\\bar {\\Gamma }}(\\tau )} in the end, to gain the most general type for a given expression. Because the procedures used in the algorithm have nearly O(1) cost, the overall cost of the algorithm is close to linear in the size of the expression for which a type is to be inferred. This is in strong contrast to many other attempts to derive type inference algorithms, which often came out to be NP-hard, if not undecidable with respect to termination. Thus the HM performs as well as the best fully informed type-checking algorithms can. Type-checking here means that an algorithm does not have to find a proof, but only to validate a given one.",
      "char_count": 923,
      "token_estimate": 230,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0030",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Algorithm J ==",
      "heading_path": "== = Algorithm J ==",
      "start_char": 23008,
      "end_char": 23635,
      "content": "Efficiency is slightly reduced because the binding of type variables in the context has to be maintained to allow computation of Γ ¯ ( τ ) {\\displaystyle {\\bar {\\Gamma }}(\\tau )} and enable an occurs check to prevent the building of recursive types during u n i f y ( α , τ ) {\\displaystyle {\\mathit {unify}}(\\alpha ,\\tau )} . An example of such a case is λ x . ( x x ) {\\displaystyle \\lambda \\ x.(x\\ x)} , for which no type can be derived using HM. Practically, types are only small terms and do not build up expanding structures. Thus, in complexity analysis, one can treat comparing them as a constant, retaining O(1) costs.",
      "char_count": 627,
      "token_estimate": 156,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0031",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== Proving the algorithm ==",
      "heading_path": "== Proving the algorithm ==",
      "start_char": 23644,
      "end_char": 24572,
      "content": "== Proving the algorithm == In the previous section, while sketching the algorithm its proof was hinted at with metalogical argumentation. While this leads to an efficient algorithm J, it is not clear whether the algorithm properly reflects the deduction systems D or S which serve as a semantic base line. The most critical point in the above argumentation is the refinement of monotype variables bound by the context. For instance, the algorithm boldly changes the context while inferring e.g. λ f . ( f 1 ) {\\displaystyle \\lambda f.(f\\ 1)} , because the monotype variable added to the context for the parameter f {\\displaystyle f} later needs to be refined to i n t → β {\\displaystyle int\\rightarrow \\beta } when handling application. The problem is that the deduction rules do not allow such a refinement. Arguing that the refined type could have been added earlier instead of the monotype variable is an expedient at best.",
      "char_count": 927,
      "token_estimate": 231,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0032",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== Proving the algorithm ==",
      "heading_path": "== Proving the algorithm ==",
      "start_char": 24572,
      "end_char": 24948,
      "content": "The key to reaching a formally satisfying argument is to properly include the context within the refinement. Formally, typing is compatible with substitution of free type variables. Γ ⊢ S e : τ ⟹ S Γ ⊢ S e : S τ {\\displaystyle \\Gamma \\vdash _{S}e:\\tau \\quad \\Longrightarrow \\quad S\\Gamma \\vdash _{S}e:S\\tau } To refine the free variables thus means to refine the whole typing.",
      "char_count": 376,
      "token_estimate": 94,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0033",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Algorithm W ==",
      "heading_path": "== = Algorithm W ==",
      "start_char": 24941,
      "end_char": 25753,
      "content": "== = Algorithm W === From there, a proof of algorithm J leads to algorithm W, which only makes the side effects imposed by the procedure union {\\displaystyle {\\textit {union}}} explicit by expressing its serial composition by means of the substitutions S i {\\displaystyle S_{i}} . The presentation of algorithm W in the sidebar still makes use of side effects in the operations set in italic, but these are now limited to generating fresh symbols. The form of judgement is Γ ⊢ e : τ , S {\\displaystyle \\Gamma \\vdash e:\\tau ,S} , denoting a function with a context and expression as parameter producing a monotype together with a substitution. mgu {\\displaystyle {\\textsf {mgu}}} is a side-effect free version of union {\\displaystyle {\\textit {union}}} producing a substitution which is the most general unifier.",
      "char_count": 811,
      "token_estimate": 202,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0034",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Algorithm W ==",
      "heading_path": "== = Algorithm W ==",
      "start_char": 25753,
      "end_char": 26413,
      "content": "While algorithm W is normally considered to be the HM algorithm and is often directly presented after the rule system in literature, its purpose is described by Milner on P. 369 as follows: As it stands, W is hardly an efficient algorithm; substitutions are applied too often. It was formulated to aid the proof of soundness. We now present a simpler algorithm J which simulates W in a precise sense. While he considered W more complicated and less efficient, he presented it in his publication before J. It has its merits when side effects are unavailable or unwanted. W is also needed to prove completeness, which is factored by him into the soundness proof.",
      "char_count": 660,
      "token_estimate": 165,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0035",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Proof obligations ==",
      "heading_path": "== = Proof obligations ==",
      "start_char": 26420,
      "end_char": 26966,
      "content": "== = Proof obligations === Before formulating the proof obligations, a deviation between the rules systems D and S and the algorithms presented needs to be emphasized. While the development above sort of misused the monotypes as \"open\" proof variables, the possibility that proper monotype variables might be harmed was sidestepped by introducing fresh variables and hoping for the best. But there's a catch: One of the promises made was that these fresh variables would be \"kept in mind\" as such. This promise is not fulfilled by the algorithm.",
      "char_count": 545,
      "token_estimate": 136,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0036",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Proof obligations ==",
      "heading_path": "== = Proof obligations ==",
      "start_char": 26966,
      "end_char": 27898,
      "content": "Having a context 1 : i n t , f : α {\\displaystyle 1:int,\\ f:\\alpha } , the expression f 1 {\\displaystyle f\\ 1} cannot be typed in either ⊢ D {\\displaystyle \\vdash _{D}} or ⊢ S {\\displaystyle \\vdash _{S}} , but the algorithms come up with the type β {\\displaystyle \\beta } , where W additionally delivers the substitution { α ↦ i n t → β } {\\displaystyle \\left\\{\\alpha \\mapsto int\\rightarrow \\beta \\right\\}} , meaning that the algorithm fails to detect all type errors. This omission can easily be fixed by more carefully distinguishing proof variables and monotype variables. The authors were well aware of the problem but decided not to fix it. One might assume a pragmatic reason behind this. While more properly implementing the type inference would have enabled the algorithm to deal with abstract monotypes, they were not needed for the intended application where none of the items in a preexisting context have free variables.",
      "char_count": 932,
      "token_estimate": 233,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0037",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Proof obligations ==",
      "heading_path": "== = Proof obligations ==",
      "start_char": 27899,
      "end_char": 28832,
      "content": "In this light, the unneeded complication was dropped in favor of a simpler algorithm. The remaining downside is that the proof of the algorithm with respect to the rule system is less general and can only be made for contexts with f r e e ( Γ ) = ∅ {\\displaystyle free(\\Gamma )=\\emptyset } as a side condition. (Correctness) Γ ⊢ W e : τ , S ⟹ Γ ⊢ S e : τ (Completeness) Γ ⊢ S e : τ ⟹ Γ ⊢ W e : τ ′ , S forall τ where ∅ ¯ ( τ ′ ) ⊑ τ {\\displaystyle {\\begin{array}{lll}{\\text{(Correctness)}}&\\Gamma \\vdash _{W}e:\\tau ,S&\\quad \\Longrightarrow \\quad \\Gamma \\vdash _{S}e:\\tau \\\\{\\text{(Completeness)}}&\\Gamma \\vdash _{S}e:\\tau &\\quad \\Longrightarrow \\quad \\Gamma \\vdash _{W}e:\\tau ',S\\quad \\quad {\\text{forall}}\\ \\tau \\ {\\text{where}}\\ {\\overline {\\emptyset }}(\\tau ')\\sqsubseteq \\tau \\end{array}}} The side condition in the completeness obligation addresses how the deduction may give many types, while the algorithm always produces one.",
      "char_count": 933,
      "token_estimate": 233,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0038",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Proof obligations ==",
      "heading_path": "== = Proof obligations ==",
      "start_char": 28833,
      "end_char": 29444,
      "content": "At the same time, the side condition demands that the type inferred is actually the most general. To properly prove the obligations one needs to strengthen them first to allow activating the substitution lemma threading the substitution S {\\displaystyle S} through ⊢ S {\\displaystyle \\vdash _{S}} and ⊢ W {\\displaystyle \\vdash _{W}} . From there, the proofs are by induction over the expression. Another proof obligation is the substitution lemma itself, i.e. the substitution of the typing, which finally establishes the all-quantification. The later cannot formally be proven, since no such syntax is at hand.",
      "char_count": 611,
      "token_estimate": 152,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0039",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Recursive definitions ==",
      "heading_path": "== = Recursive definitions ==",
      "start_char": 29466,
      "end_char": 29864,
      "content": "== = Recursive definitions === To make programming practical recursive functions are needed. A central property of the lambda calculus is that recursive definitions are not directly available, but can instead be expressed with a fixed point combinator. But unfortunately, the fixpoint combinator cannot be formulated in a typed version of the lambda calculus without having a disastrous effect on the system as outlined below.",
      "char_count": 426,
      "token_estimate": 106,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0040",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Overloading ==",
      "heading_path": "== = Overloading ==",
      "start_char": 29883,
      "end_char": 30811,
      "content": "== = Overloading === Overloading means that different functions can be defined and used with the same name. Most programming languages at least provide overloading with the built-in arithmetic operations (+, <, etc.), to allow the programmer to write arithmetic expressions in the same form, even for different numerical types like int or real. Because a mixture of these different types within the same expression also demands for implicit conversion, overloading especially for these operations is often built into the programming language itself. In some languages, this feature is generalized and made available to the user, e.g. in C++. While ad hoc overloading has been avoided in functional programming for the computation costs both in type checking and inference, a means to systematise overloading has been introduced that resembles both in form and naming to object oriented programming, but works one level upwards.",
      "char_count": 927,
      "token_estimate": 231,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0041",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Overloading ==",
      "heading_path": "== = Overloading ==",
      "start_char": 30811,
      "end_char": 31699,
      "content": "\"Instances\" in this systematic are not objects (i.e. on value level), but rather types. The quicksort example mentioned in the introduction uses the overloading in the orders, having the following type annotation in Haskell: Herein, the type a is not only polymorphic, but also restricted to be an instance of some type class Ord, that provides the order predicates < and >= used in the functions body. The proper implementations of these predicates are then passed to quicksorts as additional parameters, as soon as quicksort is used on more concrete types providing a single implementation of the overloaded function quickSort. Because the \"classes\" only allow a single type as their argument, the resulting type system can still provide inference. Additionally, the type classes can then be equipped with some kind of overloading order allowing one to arrange the classes as a lattice.",
      "char_count": 888,
      "token_estimate": 222,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0042",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Higher-order types ==",
      "heading_path": "== = Higher-order types ==",
      "start_char": 31707,
      "end_char": 32592,
      "content": "== = Higher-order types === Parametric polymorphism implies that types themselves are passed as parameters as if they were proper values. Passed as arguments to a proper functions, but also into \"type functions\" as in the \"parametric\" type constants, leads to the question how to more properly type types themselves. Higher-order types are used to create an even more expressive type system. Unfortunately, unification is no longer decidable in the presence of meta types, rendering type inference impossible in this extend of generality. Additionally, assuming a type of all types that includes itself as type leads into a paradox, as in the set of all sets, so one must proceed in steps of levels of abstraction. Research in second order lambda calculus, one step upwards, showed that type inference is undecidable in this generality. Haskell introduces one higher level named kind.",
      "char_count": 884,
      "token_estimate": 221,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0043",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Higher-order types ==",
      "heading_path": "== = Higher-order types ==",
      "start_char": 32592,
      "end_char": 33024,
      "content": "In standard Haskell, kinds are inferred and used for little more than to describe the arity of type constructors. e.g. a list type constructor is thought of as mapping a type (the type of its elements) to another type (the type of the list containing said elements); notationally this is expressed as ∗ → ∗ {\\displaystyle *\\to *} . Language extensions are available which extend kinds to emulate features of a dependent type system.",
      "char_count": 432,
      "token_estimate": 108,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0044",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Subtyping ==",
      "heading_path": "== = Subtyping ==",
      "start_char": 33016,
      "end_char": 33770,
      "content": "== = Subtyping === Attempts to combine subtyping and type inference have caused quite some frustration. It is straightforward to accumulate and propagate subtyping constraints (as opposed to type equality constraints), making the resulting constraints part of the inferred typing schemes, for example ∀ α . ( α ≤ T ) ⇒ α → α {\\displaystyle \\forall \\alpha .\\ (\\alpha \\leq T)\\Rightarrow \\alpha \\rightarrow \\alpha } , where α ≤ T {\\displaystyle \\alpha \\leq T} is a constraint on the type variable α {\\displaystyle \\alpha } . However, because type variables are no longer unified eagerly in this approach, it tends to generate large and unwieldy typing schemes containing many useless type variables and constraints, making them hard to read and understand.",
      "char_count": 753,
      "token_estimate": 188,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0045",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Subtyping ==",
      "heading_path": "== = Subtyping ==",
      "start_char": 33770,
      "end_char": 34616,
      "content": "Therefore, considerable effort was put into simplifying such typing schemes and their constraints, using techniques similar to those of nondeterministic finite automaton (NFA) simplification (useful in the presence of inferred recursive types). More recently, Dolan and Mycroft formalized the relationship between typing scheme simplification and NFA simplification and showed that an algebraic take on the formalization of subtyping allowed generating compact principal typing schemes for an ML-like language (called MLsub). Notably, their proposed typing scheme used a restricted form of union and intersection types instead of explicit constraints. Parreaux later claimed that this algebraic formulation was equivalent to a relatively simple algorithm resembling Algorithm W, and that the use of union and intersection types was not essential.",
      "char_count": 846,
      "token_estimate": 211,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "hindleymilnertypesys_4f4e0343_c0046",
      "article_id": "hindleymilnertypesys_4f4e0343",
      "section": "== = Subtyping ==",
      "heading_path": "== = Subtyping ==",
      "start_char": 34617,
      "end_char": 35500,
      "content": "On the other hand, type inference has proven more difficult in the context of object-oriented programming languages, because object methods tend to require first-class polymorphism in the style of System F (where type inference is undecidable) and because of features like F-bounded polymorphism. Consequently, type systems with subtyping enabling object-oriented programming, such as Cardelli's system F <: {\\displaystyle F_{<:}} , do not support HM-style type inference. Row polymorphism can be used as an alternative to subtyping for supporting language features like structural records. While this style of polymorphism is less flexible than subtyping in some ways, notably requiring more polymorphism than strictly necessary to cope with the lack of directionality in type constraints, it has the advantage that it can be integrated with the standard HM algorithms quite easily.",
      "char_count": 883,
      "token_estimate": 220,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 2,
    "items": [
      {
        "question": "What is the most general type for the identity function λ x . x?",
        "answer": "The most general type for the identity function λ x . x is ∀ α . α → α.",
        "related_chunk_ids": [
          "hindleymilnertypesys_4f4e0343_c0009"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "How does the polymorphism supported by the Hindley-Milner type system differ from the typing in the simply typed lambda calculus?",
        "answer": "The Hindley-Milner (HM) type system supports parametric polymorphism, which allows functions and operations to accept values of more than one type. An example is the identity function (`id ≡ λ x . x`), which can be applied to any type of argument. This contrasts with the simply typed lambda calculus, which uses monomorphic types that are fixed, such as atomic type constants or specific function types like `Number -> Number -> Number`.",
        "related_chunk_ids": [
          "hindleymilnertypesys_4f4e0343_c0000",
          "hindleymilnertypesys_4f4e0343_c0001",
          "hindleymilnertypesys_4f4e0343_c0002"
        ],
        "category": "INTERPRETATION"
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-30T10:37:30.842Z",
    "content_format": "markdown",
    "total_chunks": 47,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}