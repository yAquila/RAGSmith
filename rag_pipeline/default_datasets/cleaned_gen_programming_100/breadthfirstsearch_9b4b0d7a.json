{
  "article": {
    "id": "breadthfirstsearch_9b4b0d7a",
    "title": "Breadth-first search",
    "url": "https://en.wikipedia.org/wiki/Breadth-first_search",
    "lang": "en",
    "created_at": "2025-07-30T10:33:47.826759",
    "content": "---\nid: breadthfirstsearch_9b4b0d7a\nurl: https://en.wikipedia.org/wiki/Breadth-first_search\ntitle: Breadth-first search\nlang: en\ncreated_at: '2025-07-30T10:30:44.576227'\nchecksum: 9fd29ae9c9fb63ffa0a19f2c7fba6e3c2374a5525b999d03b0d2cab1f0ba0dfe\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 1257\n  char_count: 7098\n  num_chunks: 10\n  original_chunks: 13\n  filtered_out: 3\n  num_sections: 0\n---\nBreadth-first search (BFS) is an algorithm for searching a tree data structure for a node that satisfies a given property. It starts at the tree root and explores all nodes at the present depth prior to moving on to the nodes at the next depth level. Extra memory, usually a queue, is needed to keep track of the child nodes that were encountered but not yet explored. For example, in a chess endgame, a chess engine may build the game tree from the current position by applying all possible moves and use breadth-first search to find a winning position for White. Implicit trees (such as game trees or other problem-solving trees) may be of infinite size; breadth-first search is guaranteed to find a solution node if one exists. In contrast, (plain) depth-first search (DFS), which explores the node branch as far as possible before backtracking and expanding other nodes, may get lost in an infinite branch and never make it to the solution node. Iterative deepening depth-first search avoids the latter drawback at the price of exploring the tree's top parts over and over again. On the other hand, both depth-first algorithms typically require far less extra memory than breadth-first search. Breadth-first search can be generalized to both undirected graphs and directed graphs with a given start node (sometimes referred to as a 'search key'). In state space search in artificial intelligence, repeated searches of vertices are often allowed, while in theoretical analysis of algorithms based on breadth-first search, precautions are typically taken to prevent repetitions. BFS and its application in finding connected components of graphs were invented in 1945 by Konrad Zuse, in his (rejected) Ph.D. thesis on the Plankalkül programming language, but this was not published until 1972. It was reinvented in 1959 by Edward F. Moore, who used it to find the shortest path out of a maze, and later developed by C. Y. Lee into a wire routing algorithm (published in 1961). == Pseudocode == Input: A graph G and a starting vertex root of G Output: Goal state. The parent links trace the shortest path back to root 1 procedure BFS(G, root) is 2 let Q be a queue 3 label root as explored 4 Q.enqueue(root) 5 while Q is not empty do 6 v := Q.dequeue() 7 if v is the goal then 8 return v 9 for all edges from v to w in G.adjacentEdges(v) do 10 if w is not labeled as explored then 11 label w as explored 12 w.parent := v 13 Q.enqueue(w) === More details === This non-recursive implementation is similar to the non-recursive implementation of depth-first search, but differs from it in two ways: it uses a queue (First In First Out) instead of a stack (Last In First Out) and it checks whether a vertex has been explored before enqueueing the vertex rather than delaying this check until the vertex is dequeued from the queue. If G is a tree, replacing the queue of this breadth-first search algorithm with a stack will yield a depth-first search algorithm. For general graphs, replacing the stack of the iterative depth-first search implementation with a queue would also produce a breadth-first search algorithm, although a somewhat nonstandard one. The Q queue contains the frontier along which the algorithm is currently searching. Nodes can be labelled as explored by storing them in a set, or by an attribute on each node, depending on the implementation. Note that the word node is usually interchangeable with the word vertex. The parent attribute of each node is useful for accessing the nodes in a shortest path, for example by backtracking from the destination node up to the starting node, once the BFS has been run, and the predecessors nodes have been set. Breadth-first search produces a breadth-first tree which is shown in the example below. === Example === The lower diagram shows the breadth-first tree obtained by running a BFS on an example graph of German cities (upper diagram) starting from Frankfurt. == Analysis == === Time and space complexity === The time complexity can be expressed as O ( | V | + | E | ) {\\displaystyle O(|V|+|E|)} , as every vertex and every edge will be explored in the worst case. | V | {\\displaystyle |V|} is the number of vertices and | E | {\\displaystyle |E|} is the number of edges in the graph. Note that O ( | E | ) {\\displaystyle O(|E|)} may vary between O ( 1 ) {\\displaystyle O(1)} and O ( | V | 2 ) {\\displaystyle O(|V|^{2})} , depending on how sparse the input graph is. When the number of vertices in the graph is known ahead of time, and additional data structures are used to determine which vertices have already been added to the queue, the space complexity can be expressed as O ( | V | ) {\\displaystyle O(|V|)} , where | V | {\\displaystyle |V|} is the number of vertices. This is in addition to the space required for the graph itself, which may vary depending on the graph representation used by an implementation of the algorithm. When working with graphs that are too large to store explicitly (or infinite), it is more practical to describe the complexity of breadth-first search in different terms: to find the nodes that are at distance d from the start node (measured in number of edge traversals), BFS takes O(bd + 1) time and memory, where b is the \"branching factor\" of the graph (the average out-degree). === Completeness === In the analysis of algorithms, the input to breadth-first search is assumed to be a finite graph, represented as an adjacency list, adjacency matrix, or similar representation. However, in the application of graph traversal methods in artificial intelligence the input may be an implicit representation of an infinite graph. In this context, a search method is described as being complete if it is guaranteed to find a goal state if one exists. Breadth-first search is complete, but depth-first search is not. When applied to infinite graphs represented implicitly, breadth-first search will eventually find the goal state, but depth first search may get lost in parts of the graph that have no goal state and never return. == BFS ordering == An enumeration of the vertices of a graph is said to be a BFS ordering if it is the possible output of the application of BFS to this graph. Let G = ( V , E ) {\\displaystyle G=(V,E)} be a graph with n {\\displaystyle n} vertices. Recall that N ( v ) {\\displaystyle N(v)} is the set of neighbors of v {\\displaystyle v} . Let σ = ( v 1 , … , v m ) {\\displaystyle \\sigma =(v_{1},\\dots ,v_{m})} be a list of distinct elements of V {\\displaystyle V} , for v ∈ V ∖ { v 1 , … , v m } {\\displaystyle v\\in V\\setminus \\{v_{1},\\dots ,v_{m}\\}} , let ν σ ( v ) {\\displaystyle \\nu _{\\sigma }(v)} be the least i {\\displaystyle i} such that v i {\\displaystyle v_{i}} is a neighbor of v {\\displaystyle v} , if such a i {\\displaystyle i} exists, and be ∞ {\\displaystyle \\infty } otherwise. Let σ = ( v 1 , … , v n ) {\\displaystyle \\sigma =(v_{1},\\dots ,v_{n})} be an enumeration of the vertices of V {\\displaystyle V} . The enumeration σ {\\displaystyle \\sigma } is said to be a BFS ordering (with source v 1 {\\displaystyle v_{1}} ) if, for all 1 < i ≤ n {\\displaystyle 1"
  },
  "chunks": [
    {
      "id": "breadthfirstsearch_9b4b0d7a_c0000",
      "article_id": "breadthfirstsearch_9b4b0d7a",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 950,
      "content": "Breadth-first search (BFS) is an algorithm for searching a tree data structure for a node that satisfies a given property. It starts at the tree root and explores all nodes at the present depth prior to moving on to the nodes at the next depth level. Extra memory, usually a queue, is needed to keep track of the child nodes that were encountered but not yet explored. For example, in a chess endgame, a chess engine may build the game tree from the current position by applying all possible moves and use breadth-first search to find a winning position for White. Implicit trees (such as game trees or other problem-solving trees) may be of infinite size; breadth-first search is guaranteed to find a solution node if one exists. In contrast, (plain) depth-first search (DFS), which explores the node branch as far as possible before backtracking and expanding other nodes, may get lost in an infinite branch and never make it to the solution node.",
      "char_count": 949,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "breadthfirstsearch_9b4b0d7a_c0001",
      "article_id": "breadthfirstsearch_9b4b0d7a",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 950,
      "end_char": 1922,
      "content": "Iterative deepening depth-first search avoids the latter drawback at the price of exploring the tree's top parts over and over again. On the other hand, both depth-first algorithms typically require far less extra memory than breadth-first search. Breadth-first search can be generalized to both undirected graphs and directed graphs with a given start node (sometimes referred to as a 'search key'). In state space search in artificial intelligence, repeated searches of vertices are often allowed, while in theoretical analysis of algorithms based on breadth-first search, precautions are typically taken to prevent repetitions. BFS and its application in finding connected components of graphs were invented in 1945 by Konrad Zuse, in his (rejected) Ph.D. thesis on the Plankalkül programming language, but this was not published until 1972. It was reinvented in 1959 by Edward F. Moore, who used it to find the shortest path out of a maze, and later developed by C. Y.",
      "char_count": 972,
      "token_estimate": 243,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "breadthfirstsearch_9b4b0d7a_c0002",
      "article_id": "breadthfirstsearch_9b4b0d7a",
      "section": "== Pseudocode ==",
      "heading_path": "== Pseudocode ==",
      "start_char": 1994,
      "end_char": 2437,
      "content": "== Pseudocode == Input: A graph G and a starting vertex root of G Output: Goal state. The parent links trace the shortest path back to root 1 procedure BFS(G, root) is 2 let Q be a queue 3 label root as explored 4 Q.enqueue(root) 5 while Q is not empty do 6 v := Q.dequeue() 7 if v is the goal then 8 return v 9 for all edges from v to w in G.adjacentEdges(v) do 10 if w is not labeled as explored then 11 label w as explored 12 w.parent := v 13 Q.enqueue(w)",
      "char_count": 458,
      "token_estimate": 114,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "breadthfirstsearch_9b4b0d7a_c0003",
      "article_id": "breadthfirstsearch_9b4b0d7a",
      "section": "== = More details ==",
      "heading_path": "== = More details ==",
      "start_char": 2457,
      "end_char": 3382,
      "content": "== = More details === This non-recursive implementation is similar to the non-recursive implementation of depth-first search, but differs from it in two ways: it uses a queue (First In First Out) instead of a stack (Last In First Out) and it checks whether a vertex has been explored before enqueueing the vertex rather than delaying this check until the vertex is dequeued from the queue. If G is a tree, replacing the queue of this breadth-first search algorithm with a stack will yield a depth-first search algorithm. For general graphs, replacing the stack of the iterative depth-first search implementation with a queue would also produce a breadth-first search algorithm, although a somewhat nonstandard one. The Q queue contains the frontier along which the algorithm is currently searching. Nodes can be labelled as explored by storing them in a set, or by an attribute on each node, depending on the implementation.",
      "char_count": 924,
      "token_estimate": 231,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "breadthfirstsearch_9b4b0d7a_c0004",
      "article_id": "breadthfirstsearch_9b4b0d7a",
      "section": "== = More details ==",
      "heading_path": "== = More details ==",
      "start_char": 3382,
      "end_char": 3778,
      "content": "Note that the word node is usually interchangeable with the word vertex. The parent attribute of each node is useful for accessing the nodes in a shortest path, for example by backtracking from the destination node up to the starting node, once the BFS has been run, and the predecessors nodes have been set. Breadth-first search produces a breadth-first tree which is shown in the example below.",
      "char_count": 396,
      "token_estimate": 99,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "breadthfirstsearch_9b4b0d7a_c0005",
      "article_id": "breadthfirstsearch_9b4b0d7a",
      "section": "== = Time and space complexity ==",
      "heading_path": "== = Time and space complexity ==",
      "start_char": 3975,
      "end_char": 4936,
      "content": "== = Time and space complexity === The time complexity can be expressed as O ( | V | + | E | ) {\\displaystyle O(|V|+|E|)} , as every vertex and every edge will be explored in the worst case. | V | {\\displaystyle |V|} is the number of vertices and | E | {\\displaystyle |E|} is the number of edges in the graph. Note that O ( | E | ) {\\displaystyle O(|E|)} may vary between O ( 1 ) {\\displaystyle O(1)} and O ( | V | 2 ) {\\displaystyle O(|V|^{2})} , depending on how sparse the input graph is. When the number of vertices in the graph is known ahead of time, and additional data structures are used to determine which vertices have already been added to the queue, the space complexity can be expressed as O ( | V | ) {\\displaystyle O(|V|)} , where | V | {\\displaystyle |V|} is the number of vertices. This is in addition to the space required for the graph itself, which may vary depending on the graph representation used by an implementation of the algorithm.",
      "char_count": 960,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "breadthfirstsearch_9b4b0d7a_c0006",
      "article_id": "breadthfirstsearch_9b4b0d7a",
      "section": "== = Time and space complexity ==",
      "heading_path": "== = Time and space complexity ==",
      "start_char": 4936,
      "end_char": 5318,
      "content": "When working with graphs that are too large to store explicitly (or infinite), it is more practical to describe the complexity of breadth-first search in different terms: to find the nodes that are at distance d from the start node (measured in number of edge traversals), BFS takes O(bd + 1) time and memory, where b is the \"branching factor\" of the graph (the average out-degree).",
      "char_count": 382,
      "token_estimate": 95,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "breadthfirstsearch_9b4b0d7a_c0007",
      "article_id": "breadthfirstsearch_9b4b0d7a",
      "section": "== = Completeness ==",
      "heading_path": "== = Completeness ==",
      "start_char": 5306,
      "end_char": 6032,
      "content": "== = Completeness === In the analysis of algorithms, the input to breadth-first search is assumed to be a finite graph, represented as an adjacency list, adjacency matrix, or similar representation. However, in the application of graph traversal methods in artificial intelligence the input may be an implicit representation of an infinite graph. In this context, a search method is described as being complete if it is guaranteed to find a goal state if one exists. Breadth-first search is complete, but depth-first search is not. When applied to infinite graphs represented implicitly, breadth-first search will eventually find the goal state, but depth first search may get lost in parts of the graph that have no goal state and never return.",
      "char_count": 745,
      "token_estimate": 186,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "breadthfirstsearch_9b4b0d7a_c0008",
      "article_id": "breadthfirstsearch_9b4b0d7a",
      "section": "== BFS ordering ==",
      "heading_path": "== BFS ordering ==",
      "start_char": 6050,
      "end_char": 6970,
      "content": "== BFS ordering == An enumeration of the vertices of a graph is said to be a BFS ordering if it is the possible output of the application of BFS to this graph. Let G = ( V , E ) {\\displaystyle G=(V,E)} be a graph with n {\\displaystyle n} vertices. Recall that N ( v ) {\\displaystyle N(v)} is the set of neighbors of v {\\displaystyle v} . Let σ = ( v 1 , … , v m ) {\\displaystyle \\sigma =(v_{1},\\dots ,v_{m})} be a list of distinct elements of V {\\displaystyle V} , for v ∈ V ∖ { v 1 , … , v m } {\\displaystyle v\\in V\\setminus \\{v_{1},\\dots ,v_{m}\\}} , let ν σ ( v ) {\\displaystyle \\nu _{\\sigma }(v)} be the least i {\\displaystyle i} such that v i {\\displaystyle v_{i}} is a neighbor of v {\\displaystyle v} , if such a i {\\displaystyle i} exists, and be ∞ {\\displaystyle \\infty } otherwise. Let σ = ( v 1 , … , v n ) {\\displaystyle \\sigma =(v_{1},\\dots ,v_{n})} be an enumeration of the vertices of V {\\displaystyle V} .",
      "char_count": 919,
      "token_estimate": 229,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "breadthfirstsearch_9b4b0d7a_c0009",
      "article_id": "breadthfirstsearch_9b4b0d7a",
      "section": "== BFS ordering ==",
      "heading_path": "== BFS ordering ==",
      "start_char": 6970,
      "end_char": 7120,
      "content": "The enumeration σ {\\displaystyle \\sigma } is said to be a BFS ordering (with source v 1 {\\displaystyle v_{1}} ) if, for all 1 < i ≤ n {\\displaystyle 1",
      "char_count": 150,
      "token_estimate": 37,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 7,
    "items": [
      {
        "question": "Who originally invented BFS and its application in finding connected components of graphs, and in what year?",
        "answer": "BFS and its application in finding connected components of graphs were invented in 1945 by Konrad Zuse, as part of his Ph.D. thesis on the Plankalkül programming language.",
        "related_chunk_ids": [
          "breadthfirstsearch_9b4b0d7a_c0001"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What are the two primary differences between the non-recursive implementations of breadth-first search and depth-first search?",
        "answer": "The non-recursive implementation of breadth-first search differs from depth-first search in two ways: it uses a queue (First In First Out) instead of a stack (Last In First Out), and it checks if a vertex has been explored before enqueueing it, rather than after dequeuing it.",
        "related_chunk_ids": [
          "breadthfirstsearch_9b4b0d7a_c0003"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "What are the key trade-offs between Breadth-First Search (BFS) and Depth-First Search (DFS) regarding memory usage and performance in infinite trees?",
        "answer": "The primary trade-offs between Breadth-First Search (BFS) and Depth-First Search (DFS) relate to memory consumption and their effectiveness in infinite trees. BFS requires extra memory, typically a queue, to keep track of nodes, whereas DFS algorithms generally use far less extra memory. However, BFS is guaranteed to find a solution in an infinite tree if one exists, while a standard DFS can get lost in an infinite branch and fail to find a solution. This particular drawback of DFS can be mitigated by using an approach like iterative deepening depth-first search.",
        "related_chunk_ids": [
          "breadthfirstsearch_9b4b0d7a_c0000",
          "breadthfirstsearch_9b4b0d7a_c0001"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "According to the pseudocode and its description, what data structure is used for the Breadth-First Search, how does it differ from the one used in a non-recursive Depth-First Search, and what is its role in the algorithm?",
        "answer": "The Breadth-First Search pseudocode uses a queue (Q), which is a First In First Out (FIFO) data structure. This contrasts with a non-recursive Depth-First Search, which uses a stack (Last In First Out). The role of the queue is to contain the frontier of nodes along which the algorithm is currently searching.",
        "related_chunk_ids": [
          "breadthfirstsearch_9b4b0d7a_c0002",
          "breadthfirstsearch_9b4b0d7a_c0003"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "What are the primary trade-offs between using Breadth-First Search (BFS) and Depth-First Search (DFS) when searching a tree structure?",
        "answer": "The main trade-offs between BFS and DFS involve memory usage and completeness in finding a solution. BFS requires extra memory, usually a queue, but is guaranteed to find a solution node if one exists, even in an infinite tree. In contrast, DFS algorithms typically use far less extra memory, but a plain DFS might get lost in an infinite branch and never find the solution node.",
        "related_chunk_ids": [
          "breadthfirstsearch_9b4b0d7a_c0000",
          "breadthfirstsearch_9b4b0d7a_c0001"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "How are attributes on a vertex utilized during and after a Breadth-First Search?",
        "answer": "During a Breadth-First Search, an attribute on each vertex can be used to label it as \"explored\" to track which vertices have been visited. After the search is complete, the `parent` attribute, which is set during the search, is useful for reconstructing the shortest path by backtracking from the destination vertex up to the starting vertex.",
        "related_chunk_ids": [
          "breadthfirstsearch_9b4b0d7a_c0003",
          "breadthfirstsearch_9b4b0d7a_c0004"
        ],
        "category": "INTERPRETATION"
      },
      {
        "question": "What is the formal condition that an enumeration of vertices must satisfy to be considered a BFS ordering?",
        "answer": "An enumeration of vertices σ = (v1, ..., vn) is a BFS ordering with source v1 if it meets a specific condition. This condition uses the function νσ(v), which is the smallest index i such that vertex vi is a neighbor of v. The formal condition is that for all 1 < i ≤ n, the value of νσ(vi) must be less than νσ(vj) for any j > i.",
        "related_chunk_ids": [
          "breadthfirstsearch_9b4b0d7a_c0008",
          "breadthfirstsearch_9b4b0d7a_c0009"
        ],
        "category": "INTERPRETATION"
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-30T10:37:30.580Z",
    "content_format": "markdown",
    "total_chunks": 10,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}