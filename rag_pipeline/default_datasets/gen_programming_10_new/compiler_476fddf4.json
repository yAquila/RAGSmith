{
  "article": {
    "id": "compiler_476fddf4",
    "title": "Compiler",
    "url": "https://en.wikipedia.org/wiki/Compiler",
    "lang": "en",
    "created_at": "2025-07-30T06:55:02.658814",
    "content": "---\nid: compiler_476fddf4\nurl: https://en.wikipedia.org/wiki/Compiler\ntitle: Compiler\nlang: en\ncreated_at: '2025-07-30T06:52:05.039895'\nchecksum: 25fff75b04fbb4f84134ab533c71132f5c5e65a797953802527608c27c3ae38f\noptions:\n  chunk_size: 1000\n  chunk_overlap: 200\n  split_strategy: header_aware\n  total_questions: 10\n  llm_model: gemini-2.5-pro\nstats:\n  word_count: 5836\n  char_count: 38962\n  num_chunks: 35\n  original_chunks: 41\n  filtered_out: 6\n  num_sections: 0\n---\nIn computing, a compiler is a computer program that translates computer code written in one programming language (the source language) into another language (the target language). The name \"compiler\" is primarily used for programs that translate source code from a high-level programming language to a low-level programming language (e.g. assembly language, object code, or machine code) to create an executable program. There are many different types of compilers which produce output in different useful forms. A cross-compiler produces code for a different CPU or operating system than the one on which the cross-compiler itself runs. A bootstrap compiler is often a temporary compiler, used for compiling a more permanent or better optimised compiler for a language. Related software include decompilers, programs that translate from low-level languages to higher level ones; programs that translate between high-level languages, usually called source-to-source compilers or transpilers; language rewriters, usually programs that translate the form of expressions without a change of language; and compiler-compilers, compilers that produce compilers (or parts of them), often in a generic and reusable way so as to be able to produce many differing compilers. A compiler is likely to perform some or all of the following operations, often called phases: preprocessing, lexical analysis, parsing, semantic analysis (syntax-directed translation), conversion of input programs to an intermediate representation, code optimization and machine specific code generation. Compilers generally implement these phases as modular components, promoting efficient design and correctness of transformations of source input to target output. Program faults caused by incorrect compiler behavior can be very difficult to track down and work around; therefore, compiler implementers invest significant effort to ensure compiler correctness. == Comparison with interpreter == With respect to making source code runnable, an interpreter provides a similar function as a compiler, but via a different mechanism. An interpreter executes code without converting it to machine code. Some interpreters execute source code while others execute an intermediate form such as bytecode. A program compiled to native code tends to run faster than if interpreted. Environments with a bytecode intermediate form tend toward intermediate speed. Just-in-time compilation allows for native execution speed with a one-time startup processing time cost. Low-level programming languages, such as assembly and C, are typically compiled, especially when speed is a significant concern, rather than cross-platform support. For such languages, there are more one-to-one correspondences between the source code and the resulting machine code, making it easier for programmers to control the use of hardware. In theory, a programming language can be used via either a compiler or an interpreter, but in practice, each language tends to be used with only one or the other. Nonetheless, it is possible to write a compiler for a language that is commonly interpreted. For example, Common Lisp can be compiled to Java bytecode (then interpreted by the Java virtual machine), C code (then compiled to native machine code), or directly to native code. == History == Theoretical computing concepts developed by scientists, mathematicians, and engineers formed the basis of digital modern computing development during World War II. Primitive binary languages evolved because digital devices only understand ones and zeros and the circuit patterns in the underlying machine architecture. In the late 1940s, assembly languages were created to offer a more workable abstraction of the computer architectures. Limited memory capacity of early computers led to substantial technical challenges when the first compilers were designed. Therefore, the compilation process needed to be divided into several small programs. The front end programs produce the analysis products used by the back end programs to generate target code. As computer technology provided more resources, compiler designs could align better with the compilation process. It is usually more productive for a programmer to use a high-level language, so the development of high-level languages followed naturally from the capabilities offered by digital computers. High-level languages are formal languages that are strictly defined by their syntax and semantics which form the high-level language architecture. Elements of these formal languages include: Alphabet, any finite set of symbols; String, a finite sequence of symbols; Language, any set of strings on an alphabet. The sentences in a language may be defined by a set of rules called a grammar. Backus–Naur form (BNF) describes the syntax of \"sentences\" of a language. It was developed by John Backus and used for the syntax of Algol 60. The ideas derive from the context-free grammar concepts by linguist Noam Chomsky. \"BNF and its extensions have become standard tools for describing the syntax of programming notations. In many cases, parts of compilers are generated automatically from a BNF description.\" Between 1942 and 1945, Konrad Zuse designed the first (algorithmic) programming language for computers called Plankalkül (\"Plan Calculus\"). Zuse also envisioned a Planfertigungsgerät (\"Plan assembly device\") to automatically translate the mathematical formulation of a program into machine-readable punched film stock. While no actual implementation occurred until the 1970s, it presented concepts later seen in APL designed by Ken Iverson in the late 1950s. APL is a language for mathematical computations. Between 1949 and 1951, Heinz Rutishauser proposed Superplan, a high-level language and automatic translator. His ideas were later refined by Friedrich L. Bauer and Klaus Samelson. High-level language design during the formative years of digital computing provided useful programming tools for a variety of applications: FORTRAN (Formula Translation) for engineering and science applications is considered to be one of the first actually implemented high-level languages and first optimizing compiler. COBOL (Common Business-Oriented Language) evolved from A-0 and FLOW-MATIC to become the dominant high-level language for business applications. LISP (List Processor) for symbolic computation. Compiler technology evolved from the need for a strictly defined transformation of the high-level source program into a low-level target program for the digital computer. The compiler could be viewed as a front end to deal with the analysis of the source code and a back end to synthesize the analysis into the target code. Optimization between the front end and back end could produce more efficient target code. Some early milestones in the development of compiler technology: May 1952: Grace Hopper's team at Remington Rand wrote the compiler for the A-0 programming language (and coined the term compiler to describe it), although the A-0 compiler functioned more as a loader or linker than the modern notion of a full compiler. 1952, before September: An Autocode compiler developed by Alick Glennie for the Manchester Mark I computer at the University of Manchester is considered by some to be the first compiled programming language. 1954–1957: A team led by John Backus at IBM developed FORTRAN which is usually considered the first high-level language. In 1957, they completed a FORTRAN compiler that is generally credited as having introduced the first unambiguously complete compiler. 1959: The Conference on Data Systems Language (CODASYL) initiated development of COBOL. The COBOL design drew on A-0 and FLOW-MATIC. By the early 1960s COBOL was compiled on multiple architectures. 1958–1960: Algol 58 was the precursor to ALGOL 60. It introduced code blocks, a key advance in the rise of structured programming. ALGOL 60 was the first language to implement nested function definitions with lexical scope. It included recursion. Its syntax was defined using BNF. ALGOL 60 inspired many languages that followed it. Tony Hoare remarked: \"... it was not only an improvement on its predecessors but also on nearly all its successors.\" 1958–1962: John McCarthy at MIT designed LISP. The symbol processing capabilities provided useful features for artificial intelligence research. In 1962, LISP 1.5 release noted some tools: an interpreter written by Stephen Russell and Daniel J. Edwards, a compiler and assembler written by Tim Hart and Mike Levin. Early operating systems and software were written in assembly language. In the 1960s and early 1970s, the use of high-level languages for system programming was still controversial due to resource limitations. However, several research and industry efforts began the shift toward high-level systems programming languages, for example, BCPL, BLISS, B, and C. BCPL (Basic Combined Programming Language) designed in 1966 by Martin Richards at the University of Cambridge was originally developed as a compiler writing tool. Several compilers have been implemented, Richards' book provides insights to the language and its compiler. BCPL was not only an influential systems programming language that is still used in research but also provided a basis for the design of B and C languages. BLISS (Basic Language for Implementation of System Software) was developed for a Digital Equipment Corporation (DEC) PDP-10 computer by W. A. Wulf's Carnegie Mellon University (CMU) research team. The CMU team went on to develop BLISS-11 compiler one year later in 1970. Multics (Multiplexed Information and Computing Service), a time-sharing operating system project, involved MIT, Bell Labs, General Electric (later Honeywell) and was led by Fernando Corbató from MIT. Multics was written in the PL/I language developed by IBM and IBM User Group. IBM's goal was to satisfy business, scientific, and systems programming requirements. There were other languages that could have been considered but PL/I offered the most complete solution even though it had not been implemented. For the first few years of the Multics project, a subset of the language could be compiled to assembly language with the Early PL/I (EPL) compiler by Doug McIlory and Bob Morris from Bell Labs. EPL supported the project until a boot-strapping compiler for the full PL/I could be developed. Bell Labs left the Multics project in 1969, and developed a system programming language B based on BCPL concepts, written by Dennis Ritchie and Ken Thompson. Ritchie created a boot-strapping compiler for B and wrote Unics (Uniplexed Information and Computing Service) operating system for a PDP-7 in B. Unics eventually became spelled Unix. Bell Labs started the development and expansion of C based on B and BCPL. The BCPL compiler had been transported to Multics by Bell Labs and BCPL was a preferred language at Bell Labs. Initially, a front-end program to Bell Labs' B compiler was used while a C compiler was developed. In 1971, a new PDP-11 provided the resource to define extensions to B and rewrite the compiler. By 1973 the design of C language was essentially complete and the Unix kernel for a PDP-11 was rewritten in C. Steve Johnson started development of Portable C Compiler (PCC) to support retargeting of C compilers to new machines. Object-oriented programming (OOP) offered some interesting possibilities for application development and maintenance. OOP concepts go further back but were part of LISP and Simula language science. Bell Labs became interested in OOP with the development of C++. C++ was first used in 1980 for systems programming. The initial design leveraged C language systems programming capabilities with Simula concepts. Object-oriented facilities were added in 1983. The Cfront program implemented a C++ front-end for C84 language compiler. In subsequent years several C++ compilers were developed as C++ popularity grew. In many application domains, the idea of using a higher-level language quickly caught on. Because of the expanding functionality supported by newer programming languages and the increasing complexity of computer architectures, compilers became more complex. DARPA (Defense Advanced Research Projects Agency) sponsored a compiler project with Wulf's CMU research team in 1970. The Production Quality Compiler-Compiler PQCC design would produce a Production Quality Compiler (PQC) from formal definitions of source language and the target. PQCC tried to extend the term compiler-compiler beyond the traditional meaning as a parser generator (e.g., Yacc) without much success. PQCC might more properly be referred to as a compiler generator. PQCC research into code generation process sought to build a truly automatic compiler-writing system. The effort discovered and designed the phase structure of the PQC. The BLISS-11 compiler provided the initial structure. The phases included analyses (front end), intermediate translation to virtual machine (middle end), and translation to the target (back end). TCOL was developed for the PQCC research to handle language specific constructs in the intermediate representation. Variations of TCOL supported various languages. The PQCC project investigated techniques of automated compiler construction. The design concepts proved useful in optimizing compilers and compilers for the (since 1995, object-oriented) programming language Ada. The Ada STONEMAN document formalized the program support environment (APSE) along with the kernel (KAPSE) and minimal (MAPSE). An Ada interpreter NYU/ED supported development and standardization efforts with the American National Standards Institute (ANSI) and the International Standards Organization (ISO). Initial Ada compiler development by the U.S. Military Services included the compilers in a complete integrated design environment along the lines of the STONEMAN document. Army and Navy worked on the Ada Language System (ALS) project targeted to DEC/VAX architecture while the Air Force started on the Ada Integrated Environment (AIE) targeted to IBM 370 series. While the projects did not provide the desired results, they did contribute to the overall effort on Ada development. Other Ada compiler efforts got underway in Britain at the University of York and in Germany at the University of Karlsruhe. In the U. S., Verdix (later acquired by Rational) delivered the Verdix Ada Development System (VADS) to the Army. VADS provided a set of development tools including a compiler. Unix/VADS could be hosted on a variety of Unix platforms such as DEC Ultrix and the Sun 3/60 Solaris targeted to Motorola 68020 in an Army CECOM evaluation. There were soon many Ada compilers available that passed the Ada Validation tests. The Free Software Foundation GNU project developed the GNU Compiler Collection (GCC) which provides a core capability to support multiple languages and targets. The Ada version GNAT is one of the most widely used Ada compilers. GNAT is free but there is also commercial support, for example, AdaCore, was founded in 1994 to provide commercial software solutions for Ada. GNAT Pro includes the GNU GCC based GNAT with a tool suite to provide an integrated development environment. High-level languages continued to drive compiler research and development. Focus areas included optimization and automatic code generation. Trends in programming languages and development environments influenced compiler technology. More compilers became included in language distributions (PERL, Java Development Kit) and as a component of an IDE (VADS, Eclipse, Ada Pro). The interrelationship and interdependence of technologies grew. The advent of web services promoted growth of web languages and scripting languages. Scripts trace back to the early days of Command Line Interfaces (CLI) where the user could enter commands to be executed by the system. User Shell concepts developed with languages to write shell programs. Early Windows designs offered a simple batch programming capability. The conventional transformation of these language used an interpreter. While not widely used, Bash and Batch compilers have been written. More recently sophisticated interpreted languages became part of the developers tool kit. Modern scripting languages include PHP, Python, Ruby and Lua. (Lua is widely used in game development.) All of these have interpreter and compiler support. \"When the field of compiling began in the late 50s, its focus was limited to the translation of high-level language programs into machine code ... The compiler field is increasingly intertwined with other disciplines including computer architecture, programming languages, formal methods, software engineering, and computer security.\" The \"Compiler Research: The Next 50 Years\" article noted the importance of object-oriented languages and Java. Security and parallel computing were cited among the future research targets. == Compiler construction == A compiler implements a formal transformation from a high-level source program to a low-level target program. Compiler design can define an end-to-end solution or tackle a defined subset that interfaces with other compilation tools e.g. preprocessors, assemblers, linkers. Design requirements include rigorously defined interfaces both internally between compiler components and externally between supporting toolsets. In the early days, the approach taken to compiler design was directly affected by the complexity of the computer language to be processed, the experience of the person(s) designing it, and the resources available. Resource limitations led to the need to pass through the source code more than once. A compiler for a relatively simple language written by one person might be a single, monolithic piece of software. However, as the source language grows in complexity the design may be split into a number of interdependent phases. Separate phases provide design improvements that focus development on the functions in the compilation process. === One-pass vis-à-vis multi-pass compilers === Classifying compilers by number of passes has its background in the hardware resource limitations of computers. Compiling involves performing much work and early computers did not have enough memory to contain one program that did all of this work. As a result, compilers were split up into smaller programs which each made a pass over the source (or some representation of it) performing some of the required analysis and translations. The ability to compile in a single pass has classically been seen as a benefit because it simplifies the job of writing a compiler and one-pass compilers generally perform compilations faster than multi-pass compilers. Thus, partly driven by the resource limitations of early systems, many early languages were specifically designed so that they could be compiled in a single pass (e.g., Pascal). In some cases, the design of a language feature may require a compiler to perform more than one pass over the source. For instance, consider a declaration appearing on line 20 of the source which affects the translation of a statement appearing on line 10. In this case, the first pass needs to gather information about declarations appearing after statements that they affect, with the actual translation happening during a subsequent pass. The disadvantage of compiling in a single pass is that it is not possible to perform many of the sophisticated optimizations needed to generate high quality code. It can be difficult to count exactly how many passes an optimizing compiler makes. For instance, different phases of optimization may analyse one expression many times but only analyse another expression once. Splitting a compiler up into small programs is a technique used by researchers interested in producing provably correct compilers. Proving the correctness of a set of small programs often requires less effort than proving the correctness of a larger, single, equivalent program. === Three-stage compiler structure === Regardless of the exact number of phases in the compiler design, the phases can be assigned to one of three stages. The stages include a front end, a middle end, and a back end. The front end scans the input and verifies syntax and semantics according to a specific source language. For statically typed languages it performs type checking by collecting type information. If the input program is syntactically incorrect or has a type error, it generates error and/or warning messages, usually identifying the location in the source code where the problem was detected; in some cases the actual error may be (much) earlier in the program. Aspects of the front end include lexical analysis, syntax analysis, and semantic analysis. The front end transforms the input program into an intermediate representation (IR) for further processing by the middle end. This IR is usually a lower-level representation of the program with respect to the source code. The middle end performs optimizations on the IR that are independent of the CPU architecture being targeted. This source code/machine code independence is intended to enable generic optimizations to be shared between versions of the compiler supporting different languages and target processors. Examples of middle end optimizations are removal of useless (dead-code elimination) or unreachable code (reachability analysis), discovery and propagation of constant values (constant propagation), relocation of computation to a less frequently executed place (e.g., out of a loop), or specialization of computation based on the context, eventually producing the \"optimized\" IR that is used by the back end. The back end takes the optimized IR from the middle end. It may perform more analysis, transformations and optimizations that are specific for the target CPU architecture. The back end generates the target-dependent assembly code, performing register allocation in the process. The back end performs instruction scheduling, which re-orders instructions to keep parallel execution units busy by filling delay slots. Although most optimization problems are NP-hard, heuristic techniques for solving them are well-developed and implemented in production-quality compilers. Typically the output of a back end is machine code specialized for a particular processor and operating system. This front/middle/back-end approach makes it possible to combine front ends for different languages with back ends for different CPUs while sharing the optimizations of the middle end. Practical examples of this approach are the GNU Compiler Collection, Clang (LLVM-based C/C++ compiler), and the Amsterdam Compiler Kit, which have multiple front-ends, shared optimizations and multiple back-ends. ==== Front end ==== The front end analyzes the source code to build an internal representation of the program, called the intermediate representation (IR). It also manages the symbol table, a data structure mapping each symbol in the source code to associated information such as location, type and scope. While the frontend can be a single monolithic function or program, as in a scannerless parser, it was traditionally implemented and analyzed as several phases, which may execute sequentially or concurrently. This method is favored due to its modularity and separation of concerns. Most commonly, the frontend is broken into three phases: lexical analysis (also known as lexing or scanning), syntax analysis (also known as scanning or parsing), and semantic analysis. Lexing and parsing comprise the syntactic analysis (word syntax and phrase syntax, respectively), and in simple cases, these modules (the lexer and parser) can be automatically generated from a grammar for the language, though in more complex cases these require manual modification. The lexical grammar and phrase grammar are usually context-free grammars, which simplifies analysis significantly, with context-sensitivity handled at the semantic analysis phase. The semantic analysis phase is generally more complex and written by hand, but can be partially or fully automated using attribute grammars. These phases themselves can be further broken down: lexing as scanning and evaluating, and parsing as building a concrete syntax tree (CST, parse tree) and then transforming it into an abstract syntax tree (AST, syntax tree). In some cases additional phases are used, notably line reconstruction and preprocessing, but these are rare. The main phases of the front end include the following: Line reconstruction converts the input character sequence to a canonical form ready for the parser. Languages which strop their keywords or allow arbitrary spaces within identifiers require this phase. The top-down, recursive-descent, table-driven parsers used in the 1960s typically read the source one character at a time and did not require a separate tokenizing phase. Atlas Autocode and Imp (and some implementations of ALGOL and Coral 66) are examples of stropped languages whose compilers would have a Line Reconstruction phase. Preprocessing supports macro substitution and conditional compilation. Typically the preprocessing phase occurs before syntactic or semantic analysis; e.g. in the case of C, the preprocessor manipulates lexical tokens rather than syntactic forms. However, some languages such as Scheme support macro substitutions based on syntactic forms. Lexical analysis (also known as lexing or tokenization) breaks the source code text into a sequence of small pieces called lexical tokens. This phase can be divided into two stages: the scanning, which segments the input text into syntactic units called lexemes and assigns them a category; and the evaluating, which converts lexemes into a processed value. A token is a pair consisting of a token name and an optional token value. Common token categories may include identifiers, keywords, separators, operators, literals and comments, although the set of token categories varies in different programming languages. The lexeme syntax is typically a regular language, so a finite-state automaton constructed from a regular expression can be used to recognize it. The software doing lexical analysis is called a lexical analyzer. This may not be a separate step—it can be combined with the parsing step in scannerless parsing, in which case parsing is done at the character level, not the token level. Syntax analysis (also known as parsing) involves parsing the token sequence to identify the syntactic structure of the program. This phase typically builds a parse tree, which replaces the linear sequence of tokens with a tree structure built according to the rules of a formal grammar which define the language's syntax. The parse tree is often analyzed, augmented, and transformed by later phases in the compiler. Semantic analysis adds semantic information to the parse tree and builds the symbol table. This phase performs semantic checks such as type checking (checking for type errors), or object binding (associating variable and function references with their definitions), or definite assignment (requiring all local variables to be initialized before use), rejecting incorrect programs or issuing warnings. Semantic analysis usually requires a complete parse tree, meaning that this phase logically follows the parsing phase, and logically precedes the code generation phase, though it is often possible to fold multiple phases into one pass over the code in a compiler implementation. ==== Middle end ==== The middle end, also known as optimizer, performs optimizations on the intermediate representation in order to improve the performance and the quality of the produced machine code. The middle end contains those optimizations that are independent of the CPU architecture being targeted. The main phases of the middle end include the following: Analysis: This is the gathering of program information from the intermediate representation derived from the input; data-flow analysis is used to build use-define chains, together with dependence analysis, alias analysis, pointer analysis, escape analysis, etc. Accurate analysis is the basis for any compiler optimization. The control-flow graph of every compiled function and the call graph of the program are usually also built during the analysis phase. Optimization: the intermediate language representation is transformed into functionally equivalent but faster (or smaller) forms. Popular optimizations are inline expansion, dead-code elimination, constant propagation, loop transformation and even automatic parallelization. Compiler analysis is the prerequisite for any compiler optimization, and they tightly work together. For example, dependence analysis is crucial for loop transformation. The scope of compiler analysis and optimizations vary greatly; their scope may range from operating within a basic block, to whole procedures, or even the whole program. There is a trade-off between the granularity of the optimizations and the cost of compilation. For example, peephole optimizations are fast to perform during compilation but only affect a small local fragment of the code, and can be performed independently of the context in which the code fragment appears. In contrast, interprocedural optimization requires more compilation time and memory space, but enable optimizations that are only possible by considering the behavior of multiple functions simultaneously. Interprocedural analysis and optimizations are common in modern commercial compilers from HP, IBM, SGI, Intel, Microsoft, and Sun Microsystems. The free software GCC was criticized for a long time for lacking powerful interprocedural optimizations, but it is changing in this respect. Another open source compiler with full analysis and optimization infrastructure is Open64, which is used by many organizations for research and commercial purposes. Due to the extra time and space needed for compiler analysis and optimizations, some compilers skip them by default. Users have to use compilation options to explicitly tell the compiler which optimizations should be enabled. ==== Back end ==== The back end is responsible for the CPU architecture specific optimizations and for code generation. The main phases of the back end include the following: Machine dependent optimizations: optimizations that depend on the details of the CPU architecture that the compiler targets. A prominent example is peephole optimizations, which rewrites short sequences of assembler instructions into more efficient instructions. Code generation: the transformed intermediate language is translated into the output language, usually the native machine language of the system. This involves resource and storage decisions, such as deciding which variables to fit into registers and memory and the selection and scheduling of appropriate machine instructions along with their associated addressing modes (see also Sethi–Ullman algorithm). Debug data may also need to be generated to facilitate debugging. === Compiler correctness === Compiler correctness is the branch of software engineering that deals with trying to show that a compiler behaves according to its language specification. Techniques include developing the compiler using formal methods and using rigorous testing (often called compiler validation) on an existing compiler. == Compiled vis-à-vis interpreted languages == Higher-level programming languages usually appear with a type of translation in mind: either designed as compiled language or interpreted language. However, in practice there is rarely anything about a language that requires it to be exclusively compiled or exclusively interpreted, although it is possible to design languages that rely on re-interpretation at run time. The categorization usually reflects the most popular or widespread implementations of a language – for instance, BASIC is sometimes called an interpreted language, and C a compiled one, despite the existence of BASIC compilers and C interpreters. Interpretation does not replace compilation completely. It only hides it from the user and makes it gradual. Even though an interpreter can itself be interpreted, a set of directly executed machine instructions is needed somewhere at the bottom of the execution stack (see machine language). Furthermore, for optimization compilers can contain interpreter functionality, and interpreters may include ahead of time compilation techniques. For example, where an expression can be executed during compilation and the results inserted into the output program, then it prevents it having to be recalculated each time the program runs, which can greatly speed up the final program. Modern trends toward just-in-time compilation and bytecode interpretation at times blur the traditional categorizations of compilers and interpreters even further. Some language specifications spell out that implementations must include a compilation facility; for example, Common Lisp. However, there is nothing inherent in the definition of Common Lisp that stops it from being interpreted. Other languages have features that are very easy to implement in an interpreter, but make writing a compiler much harder; for example, APL, SNOBOL4, and many scripting languages allow programs to construct arbitrary source code at runtime with regular string operations, and then execute that code by passing it to a special evaluation function. To implement these features in a compiled language, programs must usually be shipped with a runtime library that includes a version of the compiler itself. == Types == One classification of compilers is by the platform on which their generated code executes. This is known as the target platform. A native or hosted compiler is one whose output is intended to directly run on the same type of computer and operating system that the compiler itself runs on. The output of a cross compiler is designed to run on a different platform. Cross compilers are often used when developing software for embedded systems that are not intended to support a software development environment. The output of a compiler that produces code for a virtual machine (VM) may or may not be executed on the same platform as the compiler that produced it. For this reason, such compilers are not usually classified as native or cross compilers. The lower level language that is the target of a compiler may itself be a high-level programming language. C, viewed by some as a sort of portable assembly language, is frequently the target language of such compilers. For example, Cfront, the original compiler for C++, used C as its target language. The C code generated by such a compiler is usually not intended to be readable and maintained by humans, so indent style and creating pretty C intermediate code are ignored. Some of the features of C that make it a good target language include the #line directive, which can be generated by the compiler to support debugging of the original source, and the wide platform support available with C compilers. While a common compiler type outputs machine code, there are many other types: Source-to-source compilers are a type of compiler that takes a high-level language as its input and outputs a high-level language. For example, an automatic parallelizing compiler will frequently take in a high-level language program as an input and then transform the code and annotate it with parallel code annotations (e.g. OpenMP) or language constructs (e.g. Fortran's DOALL statements). Other terms for a source-to-source compiler are transcompiler or transpiler. Bytecode compilers compile to assembly language of a theoretical machine, like some Prolog implementations This Prolog machine is also known as the Warren Abstract Machine (or WAM). Bytecode compilers for Java, Python are also examples of this category. Just-in-time compilers (JIT compiler) defer compilation until runtime. JIT compilers exist for many modern languages including Python, JavaScript, Smalltalk, Java, Microsoft .NET's Common Intermediate Language (CIL) and others. A JIT compiler generally runs inside an interpreter. When the interpreter detects that a code path is \"hot\", meaning it is executed frequently, the JIT compiler will be invoked and compile the \"hot\" code for increased performance. For some languages, such as Java, applications are first compiled using a bytecode compiler and delivered in a machine-independent intermediate representation. A bytecode interpreter executes the bytecode, but the JIT compiler will translate the bytecode to machine code when increased performance is necessary. Hardware compilers (also known as synthesis tools) are compilers whose input is a hardware description language and whose output is a description, in the form of a netlist or otherwise, of a hardware configuration. The output of these compilers target computer hardware at a very low level, for example a field-programmable gate array (FPGA) or structured application-specific integrated circuit (ASIC). Such compilers are said to be hardware compilers, because the source code they compile effectively controls the final configuration of the hardware and how it operates. The output of the compilation is only an interconnection of transistors or lookup tables. An example of hardware compiler is XST, the Xilinx Synthesis Tool used for configuring FPGAs. Similar tools are available from Altera, Synplicity, Synopsys and other hardware vendors. Research systems compile subsets of high level serial languages, such as Python or C++, directly into parallelized digital logic. This is typically easier to do for functional languages or functional subsets of multi-paradigm languages. A program that translates from a low-level language to a higher level one is a decompiler. A program that translates into an object code format that is not supported on the compilation machine is called a cross compiler and is commonly used to prepare code for execution on embedded software applications. A program that rewrites object code back into the same type of object code while applying optimisations and transformations is a binary recompiler. Assemblers, which translate human readable assembly language to the machine code instructions executed by hardware, are not considered compilers. (The inverse program that translates machine code to assembly language is called a disassembler.) == See also == == Notes and references == == Further reading == == External links == Incremental Approach to Compiler Construction – a PDF tutorial Basics of Compiler Design at the Wayback Machine (archived 15 May 2018) Short animation on YouTube explaining the key conceptual difference between compilers and interpreters Syntax Analysis & LL1 Parsing on YouTube Let's Build a Compiler, by Jack Crenshaw Forum about compiler development at the Wayback Machine (archived 10 October 2014)"
  },
  "chunks": [
    {
      "id": "compiler_476fddf4_c0000",
      "article_id": "compiler_476fddf4",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 771,
      "content": "In computing, a compiler is a computer program that translates computer code written in one programming language (the source language) into another language (the target language). The name \"compiler\" is primarily used for programs that translate source code from a high-level programming language to a low-level programming language (e.g. assembly language, object code, or machine code) to create an executable program. There are many different types of compilers which produce output in different useful forms. A cross-compiler produces code for a different CPU or operating system than the one on which the cross-compiler itself runs. A bootstrap compiler is often a temporary compiler, used for compiling a more permanent or better optimised compiler for a language.",
      "char_count": 770,
      "token_estimate": 192,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0000",
      "article_id": "compiler_476fddf4",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 0,
      "end_char": 771,
      "content": "In computing, a compiler is a computer program that translates computer code written in one programming language (the source language) into another language (the target language). The name \"compiler\" is primarily used for programs that translate source code from a high-level programming language to a low-level programming language (e.g. assembly language, object code, or machine code) to create an executable program. There are many different types of compilers which produce output in different useful forms. A cross-compiler produces code for a different CPU or operating system than the one on which the cross-compiler itself runs. A bootstrap compiler is often a temporary compiler, used for compiling a more permanent or better optimised compiler for a language.",
      "char_count": 770,
      "token_estimate": 192,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0001",
      "article_id": "compiler_476fddf4",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 771,
      "end_char": 1731,
      "content": "Related software include decompilers, programs that translate from low-level languages to higher level ones; programs that translate between high-level languages, usually called source-to-source compilers or transpilers; language rewriters, usually programs that translate the form of expressions without a change of language; and compiler-compilers, compilers that produce compilers (or parts of them), often in a generic and reusable way so as to be able to produce many differing compilers. A compiler is likely to perform some or all of the following operations, often called phases: preprocessing, lexical analysis, parsing, semantic analysis (syntax-directed translation), conversion of input programs to an intermediate representation, code optimization and machine specific code generation. Compilers generally implement these phases as modular components, promoting efficient design and correctness of transformations of source input to target output.",
      "char_count": 960,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0001",
      "article_id": "compiler_476fddf4",
      "section": "Lead",
      "heading_path": "Lead",
      "start_char": 771,
      "end_char": 1731,
      "content": "Related software include decompilers, programs that translate from low-level languages to higher level ones; programs that translate between high-level languages, usually called source-to-source compilers or transpilers; language rewriters, usually programs that translate the form of expressions without a change of language; and compiler-compilers, compilers that produce compilers (or parts of them), often in a generic and reusable way so as to be able to produce many differing compilers. A compiler is likely to perform some or all of the following operations, often called phases: preprocessing, lexical analysis, parsing, semantic analysis (syntax-directed translation), conversion of input programs to an intermediate representation, code optimization and machine specific code generation. Compilers generally implement these phases as modular components, promoting efficient design and correctness of transformations of source input to target output.",
      "char_count": 960,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0003",
      "article_id": "compiler_476fddf4",
      "section": "== Comparison with interpreter ==",
      "heading_path": "== Comparison with interpreter ==",
      "start_char": 1962,
      "end_char": 2903,
      "content": "== Comparison with interpreter == With respect to making source code runnable, an interpreter provides a similar function as a compiler, but via a different mechanism. An interpreter executes code without converting it to machine code. Some interpreters execute source code while others execute an intermediate form such as bytecode. A program compiled to native code tends to run faster than if interpreted. Environments with a bytecode intermediate form tend toward intermediate speed. Just-in-time compilation allows for native execution speed with a one-time startup processing time cost. Low-level programming languages, such as assembly and C, are typically compiled, especially when speed is a significant concern, rather than cross-platform support. For such languages, there are more one-to-one correspondences between the source code and the resulting machine code, making it easier for programmers to control the use of hardware.",
      "char_count": 940,
      "token_estimate": 235,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0003",
      "article_id": "compiler_476fddf4",
      "section": "== Comparison with interpreter ==",
      "heading_path": "== Comparison with interpreter ==",
      "start_char": 1962,
      "end_char": 2903,
      "content": "== Comparison with interpreter == With respect to making source code runnable, an interpreter provides a similar function as a compiler, but via a different mechanism. An interpreter executes code without converting it to machine code. Some interpreters execute source code while others execute an intermediate form such as bytecode. A program compiled to native code tends to run faster than if interpreted. Environments with a bytecode intermediate form tend toward intermediate speed. Just-in-time compilation allows for native execution speed with a one-time startup processing time cost. Low-level programming languages, such as assembly and C, are typically compiled, especially when speed is a significant concern, rather than cross-platform support. For such languages, there are more one-to-one correspondences between the source code and the resulting machine code, making it easier for programmers to control the use of hardware.",
      "char_count": 940,
      "token_estimate": 235,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0004",
      "article_id": "compiler_476fddf4",
      "section": "== Comparison with interpreter ==",
      "heading_path": "== Comparison with interpreter ==",
      "start_char": 2903,
      "end_char": 3339,
      "content": "In theory, a programming language can be used via either a compiler or an interpreter, but in practice, each language tends to be used with only one or the other. Nonetheless, it is possible to write a compiler for a language that is commonly interpreted. For example, Common Lisp can be compiled to Java bytecode (then interpreted by the Java virtual machine), C code (then compiled to native machine code), or directly to native code.",
      "char_count": 436,
      "token_estimate": 109,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0004",
      "article_id": "compiler_476fddf4",
      "section": "== Comparison with interpreter ==",
      "heading_path": "== Comparison with interpreter ==",
      "start_char": 2903,
      "end_char": 3339,
      "content": "In theory, a programming language can be used via either a compiler or an interpreter, but in practice, each language tends to be used with only one or the other. Nonetheless, it is possible to write a compiler for a language that is commonly interpreted. For example, Common Lisp can be compiled to Java bytecode (then interpreted by the Java virtual machine), C code (then compiled to native machine code), or directly to native code.",
      "char_count": 436,
      "token_estimate": 109,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0005",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 3320,
      "end_char": 4202,
      "content": "== History == Theoretical computing concepts developed by scientists, mathematicians, and engineers formed the basis of digital modern computing development during World War II. Primitive binary languages evolved because digital devices only understand ones and zeros and the circuit patterns in the underlying machine architecture. In the late 1940s, assembly languages were created to offer a more workable abstraction of the computer architectures. Limited memory capacity of early computers led to substantial technical challenges when the first compilers were designed. Therefore, the compilation process needed to be divided into several small programs. The front end programs produce the analysis products used by the back end programs to generate target code. As computer technology provided more resources, compiler designs could align better with the compilation process.",
      "char_count": 881,
      "token_estimate": 220,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0005",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 3320,
      "end_char": 4202,
      "content": "== History == Theoretical computing concepts developed by scientists, mathematicians, and engineers formed the basis of digital modern computing development during World War II. Primitive binary languages evolved because digital devices only understand ones and zeros and the circuit patterns in the underlying machine architecture. In the late 1940s, assembly languages were created to offer a more workable abstraction of the computer architectures. Limited memory capacity of early computers led to substantial technical challenges when the first compilers were designed. Therefore, the compilation process needed to be divided into several small programs. The front end programs produce the analysis products used by the back end programs to generate target code. As computer technology provided more resources, compiler designs could align better with the compilation process.",
      "char_count": 881,
      "token_estimate": 220,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0006",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 4202,
      "end_char": 5110,
      "content": "It is usually more productive for a programmer to use a high-level language, so the development of high-level languages followed naturally from the capabilities offered by digital computers. High-level languages are formal languages that are strictly defined by their syntax and semantics which form the high-level language architecture. Elements of these formal languages include: Alphabet, any finite set of symbols; String, a finite sequence of symbols; Language, any set of strings on an alphabet. The sentences in a language may be defined by a set of rules called a grammar. Backus–Naur form (BNF) describes the syntax of \"sentences\" of a language. It was developed by John Backus and used for the syntax of Algol 60. The ideas derive from the context-free grammar concepts by linguist Noam Chomsky. \"BNF and its extensions have become standard tools for describing the syntax of programming notations.",
      "char_count": 908,
      "token_estimate": 227,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0006",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 4202,
      "end_char": 5110,
      "content": "It is usually more productive for a programmer to use a high-level language, so the development of high-level languages followed naturally from the capabilities offered by digital computers. High-level languages are formal languages that are strictly defined by their syntax and semantics which form the high-level language architecture. Elements of these formal languages include: Alphabet, any finite set of symbols; String, a finite sequence of symbols; Language, any set of strings on an alphabet. The sentences in a language may be defined by a set of rules called a grammar. Backus–Naur form (BNF) describes the syntax of \"sentences\" of a language. It was developed by John Backus and used for the syntax of Algol 60. The ideas derive from the context-free grammar concepts by linguist Noam Chomsky. \"BNF and its extensions have become standard tools for describing the syntax of programming notations.",
      "char_count": 908,
      "token_estimate": 227,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0007",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 5111,
      "end_char": 5885,
      "content": "In many cases, parts of compilers are generated automatically from a BNF description.\" Between 1942 and 1945, Konrad Zuse designed the first (algorithmic) programming language for computers called Plankalkül (\"Plan Calculus\"). Zuse also envisioned a Planfertigungsgerät (\"Plan assembly device\") to automatically translate the mathematical formulation of a program into machine-readable punched film stock. While no actual implementation occurred until the 1970s, it presented concepts later seen in APL designed by Ken Iverson in the late 1950s. APL is a language for mathematical computations. Between 1949 and 1951, Heinz Rutishauser proposed Superplan, a high-level language and automatic translator. His ideas were later refined by Friedrich L. Bauer and Klaus Samelson.",
      "char_count": 774,
      "token_estimate": 193,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0007",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 5111,
      "end_char": 5885,
      "content": "In many cases, parts of compilers are generated automatically from a BNF description.\" Between 1942 and 1945, Konrad Zuse designed the first (algorithmic) programming language for computers called Plankalkül (\"Plan Calculus\"). Zuse also envisioned a Planfertigungsgerät (\"Plan assembly device\") to automatically translate the mathematical formulation of a program into machine-readable punched film stock. While no actual implementation occurred until the 1970s, it presented concepts later seen in APL designed by Ken Iverson in the late 1950s. APL is a language for mathematical computations. Between 1949 and 1951, Heinz Rutishauser proposed Superplan, a high-level language and automatic translator. His ideas were later refined by Friedrich L. Bauer and Klaus Samelson.",
      "char_count": 774,
      "token_estimate": 193,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0008",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 5886,
      "end_char": 6812,
      "content": "High-level language design during the formative years of digital computing provided useful programming tools for a variety of applications: FORTRAN (Formula Translation) for engineering and science applications is considered to be one of the first actually implemented high-level languages and first optimizing compiler. COBOL (Common Business-Oriented Language) evolved from A-0 and FLOW-MATIC to become the dominant high-level language for business applications. LISP (List Processor) for symbolic computation. Compiler technology evolved from the need for a strictly defined transformation of the high-level source program into a low-level target program for the digital computer. The compiler could be viewed as a front end to deal with the analysis of the source code and a back end to synthesize the analysis into the target code. Optimization between the front end and back end could produce more efficient target code.",
      "char_count": 926,
      "token_estimate": 231,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0008",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 5886,
      "end_char": 6812,
      "content": "High-level language design during the formative years of digital computing provided useful programming tools for a variety of applications: FORTRAN (Formula Translation) for engineering and science applications is considered to be one of the first actually implemented high-level languages and first optimizing compiler. COBOL (Common Business-Oriented Language) evolved from A-0 and FLOW-MATIC to become the dominant high-level language for business applications. LISP (List Processor) for symbolic computation. Compiler technology evolved from the need for a strictly defined transformation of the high-level source program into a low-level target program for the digital computer. The compiler could be viewed as a front end to deal with the analysis of the source code and a back end to synthesize the analysis into the target code. Optimization between the front end and back end could produce more efficient target code.",
      "char_count": 926,
      "token_estimate": 231,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0009",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 6813,
      "end_char": 7792,
      "content": "Some early milestones in the development of compiler technology: May 1952: Grace Hopper's team at Remington Rand wrote the compiler for the A-0 programming language (and coined the term compiler to describe it), although the A-0 compiler functioned more as a loader or linker than the modern notion of a full compiler. 1952, before September: An Autocode compiler developed by Alick Glennie for the Manchester Mark I computer at the University of Manchester is considered by some to be the first compiled programming language. 1954–1957: A team led by John Backus at IBM developed FORTRAN which is usually considered the first high-level language. In 1957, they completed a FORTRAN compiler that is generally credited as having introduced the first unambiguously complete compiler. 1959: The Conference on Data Systems Language (CODASYL) initiated development of COBOL. The COBOL design drew on A-0 and FLOW-MATIC. By the early 1960s COBOL was compiled on multiple architectures.",
      "char_count": 979,
      "token_estimate": 244,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0009",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 6813,
      "end_char": 7792,
      "content": "Some early milestones in the development of compiler technology: May 1952: Grace Hopper's team at Remington Rand wrote the compiler for the A-0 programming language (and coined the term compiler to describe it), although the A-0 compiler functioned more as a loader or linker than the modern notion of a full compiler. 1952, before September: An Autocode compiler developed by Alick Glennie for the Manchester Mark I computer at the University of Manchester is considered by some to be the first compiled programming language. 1954–1957: A team led by John Backus at IBM developed FORTRAN which is usually considered the first high-level language. In 1957, they completed a FORTRAN compiler that is generally credited as having introduced the first unambiguously complete compiler. 1959: The Conference on Data Systems Language (CODASYL) initiated development of COBOL. The COBOL design drew on A-0 and FLOW-MATIC. By the early 1960s COBOL was compiled on multiple architectures.",
      "char_count": 979,
      "token_estimate": 244,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0010",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 7793,
      "end_char": 8766,
      "content": "1958–1960: Algol 58 was the precursor to ALGOL 60. It introduced code blocks, a key advance in the rise of structured programming. ALGOL 60 was the first language to implement nested function definitions with lexical scope. It included recursion. Its syntax was defined using BNF. ALGOL 60 inspired many languages that followed it. Tony Hoare remarked: \"... it was not only an improvement on its predecessors but also on nearly all its successors.\" 1958–1962: John McCarthy at MIT designed LISP. The symbol processing capabilities provided useful features for artificial intelligence research. In 1962, LISP 1.5 release noted some tools: an interpreter written by Stephen Russell and Daniel J. Edwards, a compiler and assembler written by Tim Hart and Mike Levin. Early operating systems and software were written in assembly language. In the 1960s and early 1970s, the use of high-level languages for system programming was still controversial due to resource limitations.",
      "char_count": 973,
      "token_estimate": 243,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0010",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 7793,
      "end_char": 8766,
      "content": "1958–1960: Algol 58 was the precursor to ALGOL 60. It introduced code blocks, a key advance in the rise of structured programming. ALGOL 60 was the first language to implement nested function definitions with lexical scope. It included recursion. Its syntax was defined using BNF. ALGOL 60 inspired many languages that followed it. Tony Hoare remarked: \"... it was not only an improvement on its predecessors but also on nearly all its successors.\" 1958–1962: John McCarthy at MIT designed LISP. The symbol processing capabilities provided useful features for artificial intelligence research. In 1962, LISP 1.5 release noted some tools: an interpreter written by Stephen Russell and Daniel J. Edwards, a compiler and assembler written by Tim Hart and Mike Levin. Early operating systems and software were written in assembly language. In the 1960s and early 1970s, the use of high-level languages for system programming was still controversial due to resource limitations.",
      "char_count": 973,
      "token_estimate": 243,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0011",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 8767,
      "end_char": 9612,
      "content": "However, several research and industry efforts began the shift toward high-level systems programming languages, for example, BCPL, BLISS, B, and C. BCPL (Basic Combined Programming Language) designed in 1966 by Martin Richards at the University of Cambridge was originally developed as a compiler writing tool. Several compilers have been implemented, Richards' book provides insights to the language and its compiler. BCPL was not only an influential systems programming language that is still used in research but also provided a basis for the design of B and C languages. BLISS (Basic Language for Implementation of System Software) was developed for a Digital Equipment Corporation (DEC) PDP-10 computer by W. A. Wulf's Carnegie Mellon University (CMU) research team. The CMU team went on to develop BLISS-11 compiler one year later in 1970.",
      "char_count": 845,
      "token_estimate": 211,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0011",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 8767,
      "end_char": 9612,
      "content": "However, several research and industry efforts began the shift toward high-level systems programming languages, for example, BCPL, BLISS, B, and C. BCPL (Basic Combined Programming Language) designed in 1966 by Martin Richards at the University of Cambridge was originally developed as a compiler writing tool. Several compilers have been implemented, Richards' book provides insights to the language and its compiler. BCPL was not only an influential systems programming language that is still used in research but also provided a basis for the design of B and C languages. BLISS (Basic Language for Implementation of System Software) was developed for a Digital Equipment Corporation (DEC) PDP-10 computer by W. A. Wulf's Carnegie Mellon University (CMU) research team. The CMU team went on to develop BLISS-11 compiler one year later in 1970.",
      "char_count": 845,
      "token_estimate": 211,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0012",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 9613,
      "end_char": 10568,
      "content": "Multics (Multiplexed Information and Computing Service), a time-sharing operating system project, involved MIT, Bell Labs, General Electric (later Honeywell) and was led by Fernando Corbató from MIT. Multics was written in the PL/I language developed by IBM and IBM User Group. IBM's goal was to satisfy business, scientific, and systems programming requirements. There were other languages that could have been considered but PL/I offered the most complete solution even though it had not been implemented. For the first few years of the Multics project, a subset of the language could be compiled to assembly language with the Early PL/I (EPL) compiler by Doug McIlory and Bob Morris from Bell Labs. EPL supported the project until a boot-strapping compiler for the full PL/I could be developed. Bell Labs left the Multics project in 1969, and developed a system programming language B based on BCPL concepts, written by Dennis Ritchie and Ken Thompson.",
      "char_count": 955,
      "token_estimate": 238,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0012",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 9613,
      "end_char": 10568,
      "content": "Multics (Multiplexed Information and Computing Service), a time-sharing operating system project, involved MIT, Bell Labs, General Electric (later Honeywell) and was led by Fernando Corbató from MIT. Multics was written in the PL/I language developed by IBM and IBM User Group. IBM's goal was to satisfy business, scientific, and systems programming requirements. There were other languages that could have been considered but PL/I offered the most complete solution even though it had not been implemented. For the first few years of the Multics project, a subset of the language could be compiled to assembly language with the Early PL/I (EPL) compiler by Doug McIlory and Bob Morris from Bell Labs. EPL supported the project until a boot-strapping compiler for the full PL/I could be developed. Bell Labs left the Multics project in 1969, and developed a system programming language B based on BCPL concepts, written by Dennis Ritchie and Ken Thompson.",
      "char_count": 955,
      "token_estimate": 238,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0013",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 10569,
      "end_char": 11558,
      "content": "Ritchie created a boot-strapping compiler for B and wrote Unics (Uniplexed Information and Computing Service) operating system for a PDP-7 in B. Unics eventually became spelled Unix. Bell Labs started the development and expansion of C based on B and BCPL. The BCPL compiler had been transported to Multics by Bell Labs and BCPL was a preferred language at Bell Labs. Initially, a front-end program to Bell Labs' B compiler was used while a C compiler was developed. In 1971, a new PDP-11 provided the resource to define extensions to B and rewrite the compiler. By 1973 the design of C language was essentially complete and the Unix kernel for a PDP-11 was rewritten in C. Steve Johnson started development of Portable C Compiler (PCC) to support retargeting of C compilers to new machines. Object-oriented programming (OOP) offered some interesting possibilities for application development and maintenance. OOP concepts go further back but were part of LISP and Simula language science.",
      "char_count": 989,
      "token_estimate": 247,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0013",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 10569,
      "end_char": 11558,
      "content": "Ritchie created a boot-strapping compiler for B and wrote Unics (Uniplexed Information and Computing Service) operating system for a PDP-7 in B. Unics eventually became spelled Unix. Bell Labs started the development and expansion of C based on B and BCPL. The BCPL compiler had been transported to Multics by Bell Labs and BCPL was a preferred language at Bell Labs. Initially, a front-end program to Bell Labs' B compiler was used while a C compiler was developed. In 1971, a new PDP-11 provided the resource to define extensions to B and rewrite the compiler. By 1973 the design of C language was essentially complete and the Unix kernel for a PDP-11 was rewritten in C. Steve Johnson started development of Portable C Compiler (PCC) to support retargeting of C compilers to new machines. Object-oriented programming (OOP) offered some interesting possibilities for application development and maintenance. OOP concepts go further back but were part of LISP and Simula language science.",
      "char_count": 989,
      "token_estimate": 247,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0014",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 11559,
      "end_char": 12509,
      "content": "Bell Labs became interested in OOP with the development of C++. C++ was first used in 1980 for systems programming. The initial design leveraged C language systems programming capabilities with Simula concepts. Object-oriented facilities were added in 1983. The Cfront program implemented a C++ front-end for C84 language compiler. In subsequent years several C++ compilers were developed as C++ popularity grew. In many application domains, the idea of using a higher-level language quickly caught on. Because of the expanding functionality supported by newer programming languages and the increasing complexity of computer architectures, compilers became more complex. DARPA (Defense Advanced Research Projects Agency) sponsored a compiler project with Wulf's CMU research team in 1970. The Production Quality Compiler-Compiler PQCC design would produce a Production Quality Compiler (PQC) from formal definitions of source language and the target.",
      "char_count": 950,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0014",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 11559,
      "end_char": 12509,
      "content": "Bell Labs became interested in OOP with the development of C++. C++ was first used in 1980 for systems programming. The initial design leveraged C language systems programming capabilities with Simula concepts. Object-oriented facilities were added in 1983. The Cfront program implemented a C++ front-end for C84 language compiler. In subsequent years several C++ compilers were developed as C++ popularity grew. In many application domains, the idea of using a higher-level language quickly caught on. Because of the expanding functionality supported by newer programming languages and the increasing complexity of computer architectures, compilers became more complex. DARPA (Defense Advanced Research Projects Agency) sponsored a compiler project with Wulf's CMU research team in 1970. The Production Quality Compiler-Compiler PQCC design would produce a Production Quality Compiler (PQC) from formal definitions of source language and the target.",
      "char_count": 950,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0015",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 12510,
      "end_char": 13452,
      "content": "PQCC tried to extend the term compiler-compiler beyond the traditional meaning as a parser generator (e.g., Yacc) without much success. PQCC might more properly be referred to as a compiler generator. PQCC research into code generation process sought to build a truly automatic compiler-writing system. The effort discovered and designed the phase structure of the PQC. The BLISS-11 compiler provided the initial structure. The phases included analyses (front end), intermediate translation to virtual machine (middle end), and translation to the target (back end). TCOL was developed for the PQCC research to handle language specific constructs in the intermediate representation. Variations of TCOL supported various languages. The PQCC project investigated techniques of automated compiler construction. The design concepts proved useful in optimizing compilers and compilers for the (since 1995, object-oriented) programming language Ada.",
      "char_count": 942,
      "token_estimate": 235,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0015",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 12510,
      "end_char": 13452,
      "content": "PQCC tried to extend the term compiler-compiler beyond the traditional meaning as a parser generator (e.g., Yacc) without much success. PQCC might more properly be referred to as a compiler generator. PQCC research into code generation process sought to build a truly automatic compiler-writing system. The effort discovered and designed the phase structure of the PQC. The BLISS-11 compiler provided the initial structure. The phases included analyses (front end), intermediate translation to virtual machine (middle end), and translation to the target (back end). TCOL was developed for the PQCC research to handle language specific constructs in the intermediate representation. Variations of TCOL supported various languages. The PQCC project investigated techniques of automated compiler construction. The design concepts proved useful in optimizing compilers and compilers for the (since 1995, object-oriented) programming language Ada.",
      "char_count": 942,
      "token_estimate": 235,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0016",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 13453,
      "end_char": 14376,
      "content": "The Ada STONEMAN document formalized the program support environment (APSE) along with the kernel (KAPSE) and minimal (MAPSE). An Ada interpreter NYU/ED supported development and standardization efforts with the American National Standards Institute (ANSI) and the International Standards Organization (ISO). Initial Ada compiler development by the U.S. Military Services included the compilers in a complete integrated design environment along the lines of the STONEMAN document. Army and Navy worked on the Ada Language System (ALS) project targeted to DEC/VAX architecture while the Air Force started on the Ada Integrated Environment (AIE) targeted to IBM 370 series. While the projects did not provide the desired results, they did contribute to the overall effort on Ada development. Other Ada compiler efforts got underway in Britain at the University of York and in Germany at the University of Karlsruhe. In the U.",
      "char_count": 923,
      "token_estimate": 230,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0016",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 13453,
      "end_char": 14376,
      "content": "The Ada STONEMAN document formalized the program support environment (APSE) along with the kernel (KAPSE) and minimal (MAPSE). An Ada interpreter NYU/ED supported development and standardization efforts with the American National Standards Institute (ANSI) and the International Standards Organization (ISO). Initial Ada compiler development by the U.S. Military Services included the compilers in a complete integrated design environment along the lines of the STONEMAN document. Army and Navy worked on the Ada Language System (ALS) project targeted to DEC/VAX architecture while the Air Force started on the Ada Integrated Environment (AIE) targeted to IBM 370 series. While the projects did not provide the desired results, they did contribute to the overall effort on Ada development. Other Ada compiler efforts got underway in Britain at the University of York and in Germany at the University of Karlsruhe. In the U.",
      "char_count": 923,
      "token_estimate": 230,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0017",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 14377,
      "end_char": 15338,
      "content": "S., Verdix (later acquired by Rational) delivered the Verdix Ada Development System (VADS) to the Army. VADS provided a set of development tools including a compiler. Unix/VADS could be hosted on a variety of Unix platforms such as DEC Ultrix and the Sun 3/60 Solaris targeted to Motorola 68020 in an Army CECOM evaluation. There were soon many Ada compilers available that passed the Ada Validation tests. The Free Software Foundation GNU project developed the GNU Compiler Collection (GCC) which provides a core capability to support multiple languages and targets. The Ada version GNAT is one of the most widely used Ada compilers. GNAT is free but there is also commercial support, for example, AdaCore, was founded in 1994 to provide commercial software solutions for Ada. GNAT Pro includes the GNU GCC based GNAT with a tool suite to provide an integrated development environment. High-level languages continued to drive compiler research and development.",
      "char_count": 961,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0017",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 14377,
      "end_char": 15338,
      "content": "S., Verdix (later acquired by Rational) delivered the Verdix Ada Development System (VADS) to the Army. VADS provided a set of development tools including a compiler. Unix/VADS could be hosted on a variety of Unix platforms such as DEC Ultrix and the Sun 3/60 Solaris targeted to Motorola 68020 in an Army CECOM evaluation. There were soon many Ada compilers available that passed the Ada Validation tests. The Free Software Foundation GNU project developed the GNU Compiler Collection (GCC) which provides a core capability to support multiple languages and targets. The Ada version GNAT is one of the most widely used Ada compilers. GNAT is free but there is also commercial support, for example, AdaCore, was founded in 1994 to provide commercial software solutions for Ada. GNAT Pro includes the GNU GCC based GNAT with a tool suite to provide an integrated development environment. High-level languages continued to drive compiler research and development.",
      "char_count": 961,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0018",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 15339,
      "end_char": 16289,
      "content": "Focus areas included optimization and automatic code generation. Trends in programming languages and development environments influenced compiler technology. More compilers became included in language distributions (PERL, Java Development Kit) and as a component of an IDE (VADS, Eclipse, Ada Pro). The interrelationship and interdependence of technologies grew. The advent of web services promoted growth of web languages and scripting languages. Scripts trace back to the early days of Command Line Interfaces (CLI) where the user could enter commands to be executed by the system. User Shell concepts developed with languages to write shell programs. Early Windows designs offered a simple batch programming capability. The conventional transformation of these language used an interpreter. While not widely used, Bash and Batch compilers have been written. More recently sophisticated interpreted languages became part of the developers tool kit.",
      "char_count": 950,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0018",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 15339,
      "end_char": 16289,
      "content": "Focus areas included optimization and automatic code generation. Trends in programming languages and development environments influenced compiler technology. More compilers became included in language distributions (PERL, Java Development Kit) and as a component of an IDE (VADS, Eclipse, Ada Pro). The interrelationship and interdependence of technologies grew. The advent of web services promoted growth of web languages and scripting languages. Scripts trace back to the early days of Command Line Interfaces (CLI) where the user could enter commands to be executed by the system. User Shell concepts developed with languages to write shell programs. Early Windows designs offered a simple batch programming capability. The conventional transformation of these language used an interpreter. While not widely used, Bash and Batch compilers have been written. More recently sophisticated interpreted languages became part of the developers tool kit.",
      "char_count": 950,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0019",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 16290,
      "end_char": 16969,
      "content": "Modern scripting languages include PHP, Python, Ruby and Lua. (Lua is widely used in game development.) All of these have interpreter and compiler support. \"When the field of compiling began in the late 50s, its focus was limited to the translation of high-level language programs into machine code ... The compiler field is increasingly intertwined with other disciplines including computer architecture, programming languages, formal methods, software engineering, and computer security.\" The \"Compiler Research: The Next 50 Years\" article noted the importance of object-oriented languages and Java. Security and parallel computing were cited among the future research targets.",
      "char_count": 679,
      "token_estimate": 169,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0019",
      "article_id": "compiler_476fddf4",
      "section": "== History ==",
      "heading_path": "== History ==",
      "start_char": 16290,
      "end_char": 16969,
      "content": "Modern scripting languages include PHP, Python, Ruby and Lua. (Lua is widely used in game development.) All of these have interpreter and compiler support. \"When the field of compiling began in the late 50s, its focus was limited to the translation of high-level language programs into machine code ... The compiler field is increasingly intertwined with other disciplines including computer architecture, programming languages, formal methods, software engineering, and computer security.\" The \"Compiler Research: The Next 50 Years\" article noted the importance of object-oriented languages and Java. Security and parallel computing were cited among the future research targets.",
      "char_count": 679,
      "token_estimate": 169,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0020",
      "article_id": "compiler_476fddf4",
      "section": "== Compiler construction ==",
      "heading_path": "== Compiler construction ==",
      "start_char": 16984,
      "end_char": 17845,
      "content": "== Compiler construction == A compiler implements a formal transformation from a high-level source program to a low-level target program. Compiler design can define an end-to-end solution or tackle a defined subset that interfaces with other compilation tools e.g. preprocessors, assemblers, linkers. Design requirements include rigorously defined interfaces both internally between compiler components and externally between supporting toolsets. In the early days, the approach taken to compiler design was directly affected by the complexity of the computer language to be processed, the experience of the person(s) designing it, and the resources available. Resource limitations led to the need to pass through the source code more than once. A compiler for a relatively simple language written by one person might be a single, monolithic piece of software.",
      "char_count": 860,
      "token_estimate": 215,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0020",
      "article_id": "compiler_476fddf4",
      "section": "== Compiler construction ==",
      "heading_path": "== Compiler construction ==",
      "start_char": 16984,
      "end_char": 17845,
      "content": "== Compiler construction == A compiler implements a formal transformation from a high-level source program to a low-level target program. Compiler design can define an end-to-end solution or tackle a defined subset that interfaces with other compilation tools e.g. preprocessors, assemblers, linkers. Design requirements include rigorously defined interfaces both internally between compiler components and externally between supporting toolsets. In the early days, the approach taken to compiler design was directly affected by the complexity of the computer language to be processed, the experience of the person(s) designing it, and the resources available. Resource limitations led to the need to pass through the source code more than once. A compiler for a relatively simple language written by one person might be a single, monolithic piece of software.",
      "char_count": 860,
      "token_estimate": 215,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0021",
      "article_id": "compiler_476fddf4",
      "section": "== Compiler construction ==",
      "heading_path": "== Compiler construction ==",
      "start_char": 17845,
      "end_char": 18072,
      "content": "However, as the source language grows in complexity the design may be split into a number of interdependent phases. Separate phases provide design improvements that focus development on the functions in the compilation process.",
      "char_count": 227,
      "token_estimate": 56,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0021",
      "article_id": "compiler_476fddf4",
      "section": "== Compiler construction ==",
      "heading_path": "== Compiler construction ==",
      "start_char": 17845,
      "end_char": 18072,
      "content": "However, as the source language grows in complexity the design may be split into a number of interdependent phases. Separate phases provide design improvements that focus development on the functions in the compilation process.",
      "char_count": 227,
      "token_estimate": 56,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0022",
      "article_id": "compiler_476fddf4",
      "section": "== = One-pass vis-à-vis multi-pass compilers ==",
      "heading_path": "== = One-pass vis-à-vis multi-pass compilers ==",
      "start_char": 18093,
      "end_char": 18976,
      "content": "== = One-pass vis-à-vis multi-pass compilers === Classifying compilers by number of passes has its background in the hardware resource limitations of computers. Compiling involves performing much work and early computers did not have enough memory to contain one program that did all of this work. As a result, compilers were split up into smaller programs which each made a pass over the source (or some representation of it) performing some of the required analysis and translations. The ability to compile in a single pass has classically been seen as a benefit because it simplifies the job of writing a compiler and one-pass compilers generally perform compilations faster than multi-pass compilers. Thus, partly driven by the resource limitations of early systems, many early languages were specifically designed so that they could be compiled in a single pass (e.g., Pascal).",
      "char_count": 882,
      "token_estimate": 220,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0022",
      "article_id": "compiler_476fddf4",
      "section": "== = One-pass vis-à-vis multi-pass compilers ==",
      "heading_path": "== = One-pass vis-à-vis multi-pass compilers ==",
      "start_char": 18093,
      "end_char": 18976,
      "content": "== = One-pass vis-à-vis multi-pass compilers === Classifying compilers by number of passes has its background in the hardware resource limitations of computers. Compiling involves performing much work and early computers did not have enough memory to contain one program that did all of this work. As a result, compilers were split up into smaller programs which each made a pass over the source (or some representation of it) performing some of the required analysis and translations. The ability to compile in a single pass has classically been seen as a benefit because it simplifies the job of writing a compiler and one-pass compilers generally perform compilations faster than multi-pass compilers. Thus, partly driven by the resource limitations of early systems, many early languages were specifically designed so that they could be compiled in a single pass (e.g., Pascal).",
      "char_count": 882,
      "token_estimate": 220,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0023",
      "article_id": "compiler_476fddf4",
      "section": "== = One-pass vis-à-vis multi-pass compilers ==",
      "heading_path": "== = One-pass vis-à-vis multi-pass compilers ==",
      "start_char": 18976,
      "end_char": 19921,
      "content": "In some cases, the design of a language feature may require a compiler to perform more than one pass over the source. For instance, consider a declaration appearing on line 20 of the source which affects the translation of a statement appearing on line 10. In this case, the first pass needs to gather information about declarations appearing after statements that they affect, with the actual translation happening during a subsequent pass. The disadvantage of compiling in a single pass is that it is not possible to perform many of the sophisticated optimizations needed to generate high quality code. It can be difficult to count exactly how many passes an optimizing compiler makes. For instance, different phases of optimization may analyse one expression many times but only analyse another expression once. Splitting a compiler up into small programs is a technique used by researchers interested in producing provably correct compilers.",
      "char_count": 945,
      "token_estimate": 236,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0023",
      "article_id": "compiler_476fddf4",
      "section": "== = One-pass vis-à-vis multi-pass compilers ==",
      "heading_path": "== = One-pass vis-à-vis multi-pass compilers ==",
      "start_char": 18976,
      "end_char": 19921,
      "content": "In some cases, the design of a language feature may require a compiler to perform more than one pass over the source. For instance, consider a declaration appearing on line 20 of the source which affects the translation of a statement appearing on line 10. In this case, the first pass needs to gather information about declarations appearing after statements that they affect, with the actual translation happening during a subsequent pass. The disadvantage of compiling in a single pass is that it is not possible to perform many of the sophisticated optimizations needed to generate high quality code. It can be difficult to count exactly how many passes an optimizing compiler makes. For instance, different phases of optimization may analyse one expression many times but only analyse another expression once. Splitting a compiler up into small programs is a technique used by researchers interested in producing provably correct compilers.",
      "char_count": 945,
      "token_estimate": 236,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0025",
      "article_id": "compiler_476fddf4",
      "section": "== = Three-stage compiler structure ==",
      "heading_path": "== = Three-stage compiler structure ==",
      "start_char": 20061,
      "end_char": 20956,
      "content": "== = Three-stage compiler structure === Regardless of the exact number of phases in the compiler design, the phases can be assigned to one of three stages. The stages include a front end, a middle end, and a back end. The front end scans the input and verifies syntax and semantics according to a specific source language. For statically typed languages it performs type checking by collecting type information. If the input program is syntactically incorrect or has a type error, it generates error and/or warning messages, usually identifying the location in the source code where the problem was detected; in some cases the actual error may be (much) earlier in the program. Aspects of the front end include lexical analysis, syntax analysis, and semantic analysis. The front end transforms the input program into an intermediate representation (IR) for further processing by the middle end.",
      "char_count": 894,
      "token_estimate": 223,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0025",
      "article_id": "compiler_476fddf4",
      "section": "== = Three-stage compiler structure ==",
      "heading_path": "== = Three-stage compiler structure ==",
      "start_char": 20061,
      "end_char": 20956,
      "content": "== = Three-stage compiler structure === Regardless of the exact number of phases in the compiler design, the phases can be assigned to one of three stages. The stages include a front end, a middle end, and a back end. The front end scans the input and verifies syntax and semantics according to a specific source language. For statically typed languages it performs type checking by collecting type information. If the input program is syntactically incorrect or has a type error, it generates error and/or warning messages, usually identifying the location in the source code where the problem was detected; in some cases the actual error may be (much) earlier in the program. Aspects of the front end include lexical analysis, syntax analysis, and semantic analysis. The front end transforms the input program into an intermediate representation (IR) for further processing by the middle end.",
      "char_count": 894,
      "token_estimate": 223,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0026",
      "article_id": "compiler_476fddf4",
      "section": "== = Three-stage compiler structure ==",
      "heading_path": "== = Three-stage compiler structure ==",
      "start_char": 20956,
      "end_char": 21927,
      "content": "This IR is usually a lower-level representation of the program with respect to the source code. The middle end performs optimizations on the IR that are independent of the CPU architecture being targeted. This source code/machine code independence is intended to enable generic optimizations to be shared between versions of the compiler supporting different languages and target processors. Examples of middle end optimizations are removal of useless (dead-code elimination) or unreachable code (reachability analysis), discovery and propagation of constant values (constant propagation), relocation of computation to a less frequently executed place (e.g., out of a loop), or specialization of computation based on the context, eventually producing the \"optimized\" IR that is used by the back end. The back end takes the optimized IR from the middle end. It may perform more analysis, transformations and optimizations that are specific for the target CPU architecture.",
      "char_count": 971,
      "token_estimate": 242,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0026",
      "article_id": "compiler_476fddf4",
      "section": "== = Three-stage compiler structure ==",
      "heading_path": "== = Three-stage compiler structure ==",
      "start_char": 20956,
      "end_char": 21927,
      "content": "This IR is usually a lower-level representation of the program with respect to the source code. The middle end performs optimizations on the IR that are independent of the CPU architecture being targeted. This source code/machine code independence is intended to enable generic optimizations to be shared between versions of the compiler supporting different languages and target processors. Examples of middle end optimizations are removal of useless (dead-code elimination) or unreachable code (reachability analysis), discovery and propagation of constant values (constant propagation), relocation of computation to a less frequently executed place (e.g., out of a loop), or specialization of computation based on the context, eventually producing the \"optimized\" IR that is used by the back end. The back end takes the optimized IR from the middle end. It may perform more analysis, transformations and optimizations that are specific for the target CPU architecture.",
      "char_count": 971,
      "token_estimate": 242,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0027",
      "article_id": "compiler_476fddf4",
      "section": "== = Three-stage compiler structure ==",
      "heading_path": "== = Three-stage compiler structure ==",
      "start_char": 21928,
      "end_char": 22835,
      "content": "The back end generates the target-dependent assembly code, performing register allocation in the process. The back end performs instruction scheduling, which re-orders instructions to keep parallel execution units busy by filling delay slots. Although most optimization problems are NP-hard, heuristic techniques for solving them are well-developed and implemented in production-quality compilers. Typically the output of a back end is machine code specialized for a particular processor and operating system. This front/middle/back-end approach makes it possible to combine front ends for different languages with back ends for different CPUs while sharing the optimizations of the middle end. Practical examples of this approach are the GNU Compiler Collection, Clang (LLVM-based C/C++ compiler), and the Amsterdam Compiler Kit, which have multiple front-ends, shared optimizations and multiple back-ends.",
      "char_count": 907,
      "token_estimate": 226,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0027",
      "article_id": "compiler_476fddf4",
      "section": "== = Three-stage compiler structure ==",
      "heading_path": "== = Three-stage compiler structure ==",
      "start_char": 21928,
      "end_char": 22835,
      "content": "The back end generates the target-dependent assembly code, performing register allocation in the process. The back end performs instruction scheduling, which re-orders instructions to keep parallel execution units busy by filling delay slots. Although most optimization problems are NP-hard, heuristic techniques for solving them are well-developed and implemented in production-quality compilers. Typically the output of a back end is machine code specialized for a particular processor and operating system. This front/middle/back-end approach makes it possible to combine front ends for different languages with back ends for different CPUs while sharing the optimizations of the middle end. Practical examples of this approach are the GNU Compiler Collection, Clang (LLVM-based C/C++ compiler), and the Amsterdam Compiler Kit, which have multiple front-ends, shared optimizations and multiple back-ends.",
      "char_count": 907,
      "token_estimate": 226,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0028",
      "article_id": "compiler_476fddf4",
      "section": "== = Compiler correctness ==",
      "heading_path": "== = Compiler correctness ==",
      "start_char": 22826,
      "end_char": 23134,
      "content": "== = Compiler correctness === Compiler correctness is the branch of software engineering that deals with trying to show that a compiler behaves according to its language specification. Techniques include developing the compiler using formal methods and using rigorous testing (often called compiler validation) on an existing compiler.",
      "char_count": 335,
      "token_estimate": 83,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0028",
      "article_id": "compiler_476fddf4",
      "section": "== = Compiler correctness ==",
      "heading_path": "== = Compiler correctness ==",
      "start_char": 22826,
      "end_char": 23134,
      "content": "== = Compiler correctness === Compiler correctness is the branch of software engineering that deals with trying to show that a compiler behaves according to its language specification. Techniques include developing the compiler using formal methods and using rigorous testing (often called compiler validation) on an existing compiler.",
      "char_count": 335,
      "token_estimate": 83,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0029",
      "article_id": "compiler_476fddf4",
      "section": "== Compiled vis-à-vis interpreted languages ==",
      "heading_path": "== Compiled vis-à-vis interpreted languages ==",
      "start_char": 23180,
      "end_char": 23954,
      "content": "== Compiled vis-à-vis interpreted languages == Higher-level programming languages usually appear with a type of translation in mind: either designed as compiled language or interpreted language. However, in practice there is rarely anything about a language that requires it to be exclusively compiled or exclusively interpreted, although it is possible to design languages that rely on re-interpretation at run time. The categorization usually reflects the most popular or widespread implementations of a language – for instance, BASIC is sometimes called an interpreted language, and C a compiled one, despite the existence of BASIC compilers and C interpreters. Interpretation does not replace compilation completely. It only hides it from the user and makes it gradual.",
      "char_count": 773,
      "token_estimate": 193,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0029",
      "article_id": "compiler_476fddf4",
      "section": "== Compiled vis-à-vis interpreted languages ==",
      "heading_path": "== Compiled vis-à-vis interpreted languages ==",
      "start_char": 23180,
      "end_char": 23954,
      "content": "== Compiled vis-à-vis interpreted languages == Higher-level programming languages usually appear with a type of translation in mind: either designed as compiled language or interpreted language. However, in practice there is rarely anything about a language that requires it to be exclusively compiled or exclusively interpreted, although it is possible to design languages that rely on re-interpretation at run time. The categorization usually reflects the most popular or widespread implementations of a language – for instance, BASIC is sometimes called an interpreted language, and C a compiled one, despite the existence of BASIC compilers and C interpreters. Interpretation does not replace compilation completely. It only hides it from the user and makes it gradual.",
      "char_count": 773,
      "token_estimate": 193,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0030",
      "article_id": "compiler_476fddf4",
      "section": "== Compiled vis-à-vis interpreted languages ==",
      "heading_path": "== Compiled vis-à-vis interpreted languages ==",
      "start_char": 23954,
      "end_char": 24913,
      "content": "Even though an interpreter can itself be interpreted, a set of directly executed machine instructions is needed somewhere at the bottom of the execution stack (see machine language). Furthermore, for optimization compilers can contain interpreter functionality, and interpreters may include ahead of time compilation techniques. For example, where an expression can be executed during compilation and the results inserted into the output program, then it prevents it having to be recalculated each time the program runs, which can greatly speed up the final program. Modern trends toward just-in-time compilation and bytecode interpretation at times blur the traditional categorizations of compilers and interpreters even further. Some language specifications spell out that implementations must include a compilation facility; for example, Common Lisp. However, there is nothing inherent in the definition of Common Lisp that stops it from being interpreted.",
      "char_count": 959,
      "token_estimate": 239,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0030",
      "article_id": "compiler_476fddf4",
      "section": "== Compiled vis-à-vis interpreted languages ==",
      "heading_path": "== Compiled vis-à-vis interpreted languages ==",
      "start_char": 23954,
      "end_char": 24913,
      "content": "Even though an interpreter can itself be interpreted, a set of directly executed machine instructions is needed somewhere at the bottom of the execution stack (see machine language). Furthermore, for optimization compilers can contain interpreter functionality, and interpreters may include ahead of time compilation techniques. For example, where an expression can be executed during compilation and the results inserted into the output program, then it prevents it having to be recalculated each time the program runs, which can greatly speed up the final program. Modern trends toward just-in-time compilation and bytecode interpretation at times blur the traditional categorizations of compilers and interpreters even further. Some language specifications spell out that implementations must include a compilation facility; for example, Common Lisp. However, there is nothing inherent in the definition of Common Lisp that stops it from being interpreted.",
      "char_count": 959,
      "token_estimate": 239,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0031",
      "article_id": "compiler_476fddf4",
      "section": "== Compiled vis-à-vis interpreted languages ==",
      "heading_path": "== Compiled vis-à-vis interpreted languages ==",
      "start_char": 24914,
      "end_char": 25415,
      "content": "Other languages have features that are very easy to implement in an interpreter, but make writing a compiler much harder; for example, APL, SNOBOL4, and many scripting languages allow programs to construct arbitrary source code at runtime with regular string operations, and then execute that code by passing it to a special evaluation function. To implement these features in a compiled language, programs must usually be shipped with a runtime library that includes a version of the compiler itself.",
      "char_count": 501,
      "token_estimate": 125,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0031",
      "article_id": "compiler_476fddf4",
      "section": "== Compiled vis-à-vis interpreted languages ==",
      "heading_path": "== Compiled vis-à-vis interpreted languages ==",
      "start_char": 24914,
      "end_char": 25415,
      "content": "Other languages have features that are very easy to implement in an interpreter, but make writing a compiler much harder; for example, APL, SNOBOL4, and many scripting languages allow programs to construct arbitrary source code at runtime with regular string operations, and then execute that code by passing it to a special evaluation function. To implement these features in a compiled language, programs must usually be shipped with a runtime library that includes a version of the compiler itself.",
      "char_count": 501,
      "token_estimate": 125,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0032",
      "article_id": "compiler_476fddf4",
      "section": "== Types ==",
      "heading_path": "== Types ==",
      "start_char": 25381,
      "end_char": 26364,
      "content": "== Types == One classification of compilers is by the platform on which their generated code executes. This is known as the target platform. A native or hosted compiler is one whose output is intended to directly run on the same type of computer and operating system that the compiler itself runs on. The output of a cross compiler is designed to run on a different platform. Cross compilers are often used when developing software for embedded systems that are not intended to support a software development environment. The output of a compiler that produces code for a virtual machine (VM) may or may not be executed on the same platform as the compiler that produced it. For this reason, such compilers are not usually classified as native or cross compilers. The lower level language that is the target of a compiler may itself be a high-level programming language. C, viewed by some as a sort of portable assembly language, is frequently the target language of such compilers.",
      "char_count": 982,
      "token_estimate": 245,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0032",
      "article_id": "compiler_476fddf4",
      "section": "== Types ==",
      "heading_path": "== Types ==",
      "start_char": 25381,
      "end_char": 26364,
      "content": "== Types == One classification of compilers is by the platform on which their generated code executes. This is known as the target platform. A native or hosted compiler is one whose output is intended to directly run on the same type of computer and operating system that the compiler itself runs on. The output of a cross compiler is designed to run on a different platform. Cross compilers are often used when developing software for embedded systems that are not intended to support a software development environment. The output of a compiler that produces code for a virtual machine (VM) may or may not be executed on the same platform as the compiler that produced it. For this reason, such compilers are not usually classified as native or cross compilers. The lower level language that is the target of a compiler may itself be a high-level programming language. C, viewed by some as a sort of portable assembly language, is frequently the target language of such compilers.",
      "char_count": 982,
      "token_estimate": 245,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0033",
      "article_id": "compiler_476fddf4",
      "section": "== Types ==",
      "heading_path": "== Types ==",
      "start_char": 26364,
      "end_char": 27325,
      "content": "For example, Cfront, the original compiler for C++, used C as its target language. The C code generated by such a compiler is usually not intended to be readable and maintained by humans, so indent style and creating pretty C intermediate code are ignored. Some of the features of C that make it a good target language include the #line directive, which can be generated by the compiler to support debugging of the original source, and the wide platform support available with C compilers. While a common compiler type outputs machine code, there are many other types: Source-to-source compilers are a type of compiler that takes a high-level language as its input and outputs a high-level language. For example, an automatic parallelizing compiler will frequently take in a high-level language program as an input and then transform the code and annotate it with parallel code annotations (e.g. OpenMP) or language constructs (e.g. Fortran's DOALL statements).",
      "char_count": 961,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0033",
      "article_id": "compiler_476fddf4",
      "section": "== Types ==",
      "heading_path": "== Types ==",
      "start_char": 26364,
      "end_char": 27325,
      "content": "For example, Cfront, the original compiler for C++, used C as its target language. The C code generated by such a compiler is usually not intended to be readable and maintained by humans, so indent style and creating pretty C intermediate code are ignored. Some of the features of C that make it a good target language include the #line directive, which can be generated by the compiler to support debugging of the original source, and the wide platform support available with C compilers. While a common compiler type outputs machine code, there are many other types: Source-to-source compilers are a type of compiler that takes a high-level language as its input and outputs a high-level language. For example, an automatic parallelizing compiler will frequently take in a high-level language program as an input and then transform the code and annotate it with parallel code annotations (e.g. OpenMP) or language constructs (e.g. Fortran's DOALL statements).",
      "char_count": 961,
      "token_estimate": 240,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0034",
      "article_id": "compiler_476fddf4",
      "section": "== Types ==",
      "heading_path": "== Types ==",
      "start_char": 27326,
      "end_char": 28275,
      "content": "Other terms for a source-to-source compiler are transcompiler or transpiler. Bytecode compilers compile to assembly language of a theoretical machine, like some Prolog implementations This Prolog machine is also known as the Warren Abstract Machine (or WAM). Bytecode compilers for Java, Python are also examples of this category. Just-in-time compilers (JIT compiler) defer compilation until runtime. JIT compilers exist for many modern languages including Python, JavaScript, Smalltalk, Java, Microsoft .NET's Common Intermediate Language (CIL) and others. A JIT compiler generally runs inside an interpreter. When the interpreter detects that a code path is \"hot\", meaning it is executed frequently, the JIT compiler will be invoked and compile the \"hot\" code for increased performance. For some languages, such as Java, applications are first compiled using a bytecode compiler and delivered in a machine-independent intermediate representation.",
      "char_count": 949,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0034",
      "article_id": "compiler_476fddf4",
      "section": "== Types ==",
      "heading_path": "== Types ==",
      "start_char": 27326,
      "end_char": 28275,
      "content": "Other terms for a source-to-source compiler are transcompiler or transpiler. Bytecode compilers compile to assembly language of a theoretical machine, like some Prolog implementations This Prolog machine is also known as the Warren Abstract Machine (or WAM). Bytecode compilers for Java, Python are also examples of this category. Just-in-time compilers (JIT compiler) defer compilation until runtime. JIT compilers exist for many modern languages including Python, JavaScript, Smalltalk, Java, Microsoft .NET's Common Intermediate Language (CIL) and others. A JIT compiler generally runs inside an interpreter. When the interpreter detects that a code path is \"hot\", meaning it is executed frequently, the JIT compiler will be invoked and compile the \"hot\" code for increased performance. For some languages, such as Java, applications are first compiled using a bytecode compiler and delivered in a machine-independent intermediate representation.",
      "char_count": 949,
      "token_estimate": 237,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0035",
      "article_id": "compiler_476fddf4",
      "section": "== Types ==",
      "heading_path": "== Types ==",
      "start_char": 28276,
      "end_char": 29274,
      "content": "A bytecode interpreter executes the bytecode, but the JIT compiler will translate the bytecode to machine code when increased performance is necessary. Hardware compilers (also known as synthesis tools) are compilers whose input is a hardware description language and whose output is a description, in the form of a netlist or otherwise, of a hardware configuration. The output of these compilers target computer hardware at a very low level, for example a field-programmable gate array (FPGA) or structured application-specific integrated circuit (ASIC). Such compilers are said to be hardware compilers, because the source code they compile effectively controls the final configuration of the hardware and how it operates. The output of the compilation is only an interconnection of transistors or lookup tables. An example of hardware compiler is XST, the Xilinx Synthesis Tool used for configuring FPGAs. Similar tools are available from Altera, Synplicity, Synopsys and other hardware vendors.",
      "char_count": 998,
      "token_estimate": 249,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0035",
      "article_id": "compiler_476fddf4",
      "section": "== Types ==",
      "heading_path": "== Types ==",
      "start_char": 28276,
      "end_char": 29274,
      "content": "A bytecode interpreter executes the bytecode, but the JIT compiler will translate the bytecode to machine code when increased performance is necessary. Hardware compilers (also known as synthesis tools) are compilers whose input is a hardware description language and whose output is a description, in the form of a netlist or otherwise, of a hardware configuration. The output of these compilers target computer hardware at a very low level, for example a field-programmable gate array (FPGA) or structured application-specific integrated circuit (ASIC). Such compilers are said to be hardware compilers, because the source code they compile effectively controls the final configuration of the hardware and how it operates. The output of the compilation is only an interconnection of transistors or lookup tables. An example of hardware compiler is XST, the Xilinx Synthesis Tool used for configuring FPGAs. Similar tools are available from Altera, Synplicity, Synopsys and other hardware vendors.",
      "char_count": 998,
      "token_estimate": 249,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0036",
      "article_id": "compiler_476fddf4",
      "section": "== Types ==",
      "heading_path": "== Types ==",
      "start_char": 29275,
      "end_char": 30209,
      "content": "Research systems compile subsets of high level serial languages, such as Python or C++, directly into parallelized digital logic. This is typically easier to do for functional languages or functional subsets of multi-paradigm languages. A program that translates from a low-level language to a higher level one is a decompiler. A program that translates into an object code format that is not supported on the compilation machine is called a cross compiler and is commonly used to prepare code for execution on embedded software applications. A program that rewrites object code back into the same type of object code while applying optimisations and transformations is a binary recompiler. Assemblers, which translate human readable assembly language to the machine code instructions executed by hardware, are not considered compilers. (The inverse program that translates machine code to assembly language is called a disassembler.)",
      "char_count": 934,
      "token_estimate": 233,
      "token_start": null,
      "token_end": null
    },
    {
      "id": "compiler_476fddf4_c0036",
      "article_id": "compiler_476fddf4",
      "section": "== Types ==",
      "heading_path": "== Types ==",
      "start_char": 29275,
      "end_char": 30209,
      "content": "Research systems compile subsets of high level serial languages, such as Python or C++, directly into parallelized digital logic. This is typically easier to do for functional languages or functional subsets of multi-paradigm languages. A program that translates from a low-level language to a higher level one is a decompiler. A program that translates into an object code format that is not supported on the compilation machine is called a cross compiler and is commonly used to prepare code for execution on embedded software applications. A program that rewrites object code back into the same type of object code while applying optimisations and transformations is a binary recompiler. Assemblers, which translate human readable assembly language to the machine code instructions executed by hardware, are not considered compilers. (The inverse program that translates machine code to assembly language is called a disassembler.)",
      "char_count": 934,
      "token_estimate": 233,
      "token_start": null,
      "token_end": null
    }
  ],
  "questions": {
    "total_questions": 10,
    "items": [
      {
        "question": "What is an example of a hardware compiler mentioned in the text?",
        "answer": "An example of a hardware compiler is XST, the Xilinx Synthesis Tool, which is used for configuring FPGAs.",
        "related_chunk_ids": [
          "compiler_476fddf4_c0035"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "By what year was the design of the C language essentially complete, and what major software component was subsequently rewritten in it?",
        "answer": "By 1973, the design of the C language was essentially complete, and the Unix kernel for a PDP-11 was rewritten in C.",
        "related_chunk_ids": [
          "compiler_476fddf4_c0013"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What is the term for a compiler whose output is designed to run on the same type of computer and operating system that the compiler itself runs on?",
        "answer": "A compiler whose output is intended to directly run on the same type of computer and operating system that the compiler itself runs on is known as a native or hosted compiler.",
        "related_chunk_ids": [
          "compiler_476fddf4_c0032"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What are some examples of middle-end optimizations performed by a compiler?",
        "answer": "Examples of middle-end optimizations include the removal of useless code (dead-code elimination) or unreachable code (reachability analysis), the discovery and propagation of constant values (constant propagation), the relocation of computation to a less frequently executed place (e.g., out of a loop), or the specialization of computation based on context.",
        "related_chunk_ids": [
          "compiler_476fddf4_c0026"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "What are the common operations, often called phases, that a compiler is likely to perform?",
        "answer": "A compiler is likely to perform some or all of the following operations (phases): preprocessing, lexical analysis, parsing, semantic analysis (syntax-directed translation), conversion of input programs to an intermediate representation, code optimization, and machine-specific code generation.",
        "related_chunk_ids": [
          "compiler_476fddf4_c0001"
        ],
        "category": "LONG_ANSWER"
      },
      {
        "question": "What language is cited as an example where the specification requires implementations to include a compilation facility?",
        "answer": "Common Lisp is an example of a language whose specification spells out that implementations must include a compilation facility.",
        "related_chunk_ids": [
          "compiler_476fddf4_c0030"
        ],
        "category": "FACTUAL"
      },
      {
        "question": "Explain the fundamental difference in how compilers and interpreters make source code runnable, including the general steps a compiler takes and the resulting performance implications of each approach.",
        "answer": "A compiler translates source code from a high-level language into a low-level language like machine code to create a standalone executable program. This process involves multiple phases, such as lexical analysis, parsing, and code generation. In contrast, an interpreter executes code directly without converting it to machine code, sometimes using an intermediate form like bytecode. The primary performance implication is that a program compiled to native code generally runs faster than an interpreted program.",
        "related_chunk_ids": [
          "compiler_476fddf4_c0000",
          "compiler_476fddf4_c0001",
          "compiler_476fddf4_c0003"
        ],
        "category": "LONG_ANSWER"
      },
      {
        "question": "Summarize the evolution of programming languages from early binary forms to formally defined high-level languages, and explain the relationship between these languages and their implementation via compilers or interpreters.",
        "answer": "Programming languages evolved from primitive binary languages understood by early digital devices. In the late 1940s, assembly languages were created to offer a more workable abstraction. Following this, high-level languages were developed to improve programmer productivity. These are formal languages strictly defined by their syntax and semantics, with grammars described by tools like Backus–Naur form (BNF). In terms of implementation, any language can theoretically be processed by either a compiler or an interpreter. Although a language typically favors one method in practice, it is possible to create a compiler for a traditionally interpreted language, as seen with Common Lisp, which can be compiled to various targets like Java bytecode or native code.",
        "related_chunk_ids": [
          "compiler_476fddf4_c0004",
          "compiler_476fddf4_c0005",
          "compiler_476fddf4_c0006"
        ],
        "category": "LONG_ANSWER"
      },
      {
        "question": "Provide a comprehensive overview of a compiler, including its primary function, different types, and the operational phases it typically performs.",
        "answer": "A compiler is a computer program that translates source code from a high-level programming language into a low-level language (like assembly or machine code) to create an executable program. There are various types, including cross-compilers that produce code for a different CPU or operating system, and bootstrap compilers used to compile more permanent compilers. A compiler is likely to perform several operational phases, such as preprocessing, lexical analysis, parsing, semantic analysis, conversion to an intermediate representation, code optimization, and machine-specific code generation.",
        "related_chunk_ids": [
          "compiler_476fddf4_c0000",
          "compiler_476fddf4_c0001"
        ],
        "category": "LONG_ANSWER"
      },
      {
        "question": "While low-level languages are typically compiled for performance, how does a language like Common Lisp demonstrate flexibility in its execution methods to achieve similar results?",
        "answer": "Low-level languages such as C are typically compiled to achieve high speed. However, the distinction is not always rigid, as a language like Common Lisp can also be compiled to achieve high performance. It can be compiled to C code (which is then compiled to native machine code), directly to native code, or to Java bytecode, demonstrating that a language commonly interpreted can also leverage compilation for speed.",
        "related_chunk_ids": [
          "compiler_476fddf4_c0003",
          "compiler_476fddf4_c0004"
        ],
        "category": "INTERPRETATION"
      }
    ]
  },
  "metadata": {
    "export_date": "2025-07-30T06:52:25.439Z",
    "content_format": "markdown",
    "total_chunks": 70,
    "description": "Complete article dataset including content, chunks, and generated questions"
  }
}